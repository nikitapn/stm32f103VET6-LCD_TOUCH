ARM GAS  /tmp/ccrgBt0i.s 			page 1


   1              		.cpu cortex-m3
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 1
   9              		.eabi_attribute 34, 1
  10              		.eabi_attribute 18, 4
  11              		.file	"tasks.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.section	.text.prvTaskIsTaskSuspended,"ax",%progbits
  16              		.align	1
  17              		.syntax unified
  18              		.thumb
  19              		.thumb_func
  20              		.fpu softvfp
  22              	prvTaskIsTaskSuspended:
  23              	.LFB15:
  24              		.file 1 "FreeRTOS/tasks.c"
   1:FreeRTOS/tasks.c **** /*
   2:FreeRTOS/tasks.c ****  * FreeRTOS Kernel V10.4.6
   3:FreeRTOS/tasks.c ****  * Copyright (C) 2021 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
   4:FreeRTOS/tasks.c ****  *
   5:FreeRTOS/tasks.c ****  * SPDX-License-Identifier: MIT
   6:FreeRTOS/tasks.c ****  *
   7:FreeRTOS/tasks.c ****  * Permission is hereby granted, free of charge, to any person obtaining a copy of
   8:FreeRTOS/tasks.c ****  * this software and associated documentation files (the "Software"), to deal in
   9:FreeRTOS/tasks.c ****  * the Software without restriction, including without limitation the rights to
  10:FreeRTOS/tasks.c ****  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
  11:FreeRTOS/tasks.c ****  * the Software, and to permit persons to whom the Software is furnished to do so,
  12:FreeRTOS/tasks.c ****  * subject to the following conditions:
  13:FreeRTOS/tasks.c ****  *
  14:FreeRTOS/tasks.c ****  * The above copyright notice and this permission notice shall be included in all
  15:FreeRTOS/tasks.c ****  * copies or substantial portions of the Software.
  16:FreeRTOS/tasks.c ****  *
  17:FreeRTOS/tasks.c ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  18:FreeRTOS/tasks.c ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  19:FreeRTOS/tasks.c ****  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  20:FreeRTOS/tasks.c ****  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  21:FreeRTOS/tasks.c ****  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  22:FreeRTOS/tasks.c ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  23:FreeRTOS/tasks.c ****  *
  24:FreeRTOS/tasks.c ****  * https://www.FreeRTOS.org
  25:FreeRTOS/tasks.c ****  * https://github.com/FreeRTOS
  26:FreeRTOS/tasks.c ****  *
  27:FreeRTOS/tasks.c ****  */
  28:FreeRTOS/tasks.c **** 
  29:FreeRTOS/tasks.c **** /* Standard includes. */
  30:FreeRTOS/tasks.c **** #include <stdlib.h>
  31:FreeRTOS/tasks.c **** #include <string.h>
  32:FreeRTOS/tasks.c **** 
  33:FreeRTOS/tasks.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  34:FreeRTOS/tasks.c ****  * all the API functions to use the MPU wrappers.  That should only be done when
ARM GAS  /tmp/ccrgBt0i.s 			page 2


  35:FreeRTOS/tasks.c ****  * task.h is included from an application file. */
  36:FreeRTOS/tasks.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  37:FreeRTOS/tasks.c **** 
  38:FreeRTOS/tasks.c **** /* FreeRTOS includes. */
  39:FreeRTOS/tasks.c **** #include "FreeRTOS.h"
  40:FreeRTOS/tasks.c **** #include "task.h"
  41:FreeRTOS/tasks.c **** #include "timers.h"
  42:FreeRTOS/tasks.c **** #include "stack_macros.h"
  43:FreeRTOS/tasks.c **** 
  44:FreeRTOS/tasks.c **** /* Lint e9021, e961 and e750 are suppressed as a MISRA exception justified
  45:FreeRTOS/tasks.c ****  * because the MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined
  46:FreeRTOS/tasks.c ****  * for the header files above, but not in this file, in order to generate the
  47:FreeRTOS/tasks.c ****  * correct privileged Vs unprivileged linkage and placement. */
  48:FreeRTOS/tasks.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750 !e9021. */
  49:FreeRTOS/tasks.c **** 
  50:FreeRTOS/tasks.c **** /* Set configUSE_STATS_FORMATTING_FUNCTIONS to 2 to include the stats formatting
  51:FreeRTOS/tasks.c ****  * functions but without including stdio.h here. */
  52:FreeRTOS/tasks.c **** #if ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 )
  53:FreeRTOS/tasks.c **** 
  54:FreeRTOS/tasks.c **** /* At the bottom of this file are two optional functions that can be used
  55:FreeRTOS/tasks.c ****  * to generate human readable text from the raw data generated by the
  56:FreeRTOS/tasks.c ****  * uxTaskGetSystemState() function.  Note the formatting functions are provided
  57:FreeRTOS/tasks.c ****  * for convenience only, and are NOT considered part of the kernel. */
  58:FreeRTOS/tasks.c ****     #include <stdio.h>
  59:FreeRTOS/tasks.c **** #endif /* configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) */
  60:FreeRTOS/tasks.c **** 
  61:FreeRTOS/tasks.c **** #if ( configUSE_PREEMPTION == 0 )
  62:FreeRTOS/tasks.c **** 
  63:FreeRTOS/tasks.c **** /* If the cooperative scheduler is being used then a yield should not be
  64:FreeRTOS/tasks.c ****  * performed just because a higher priority task has been woken. */
  65:FreeRTOS/tasks.c ****     #define taskYIELD_IF_USING_PREEMPTION()
  66:FreeRTOS/tasks.c **** #else
  67:FreeRTOS/tasks.c ****     #define taskYIELD_IF_USING_PREEMPTION()    portYIELD_WITHIN_API()
  68:FreeRTOS/tasks.c **** #endif
  69:FreeRTOS/tasks.c **** 
  70:FreeRTOS/tasks.c **** /* Values that can be assigned to the ucNotifyState member of the TCB. */
  71:FreeRTOS/tasks.c **** #define taskNOT_WAITING_NOTIFICATION              ( ( uint8_t ) 0 ) /* Must be zero as it is the in
  72:FreeRTOS/tasks.c **** #define taskWAITING_NOTIFICATION                  ( ( uint8_t ) 1 )
  73:FreeRTOS/tasks.c **** #define taskNOTIFICATION_RECEIVED                 ( ( uint8_t ) 2 )
  74:FreeRTOS/tasks.c **** 
  75:FreeRTOS/tasks.c **** /*
  76:FreeRTOS/tasks.c ****  * The value used to fill the stack of a task when the task is created.  This
  77:FreeRTOS/tasks.c ****  * is used purely for checking the high water mark for tasks.
  78:FreeRTOS/tasks.c ****  */
  79:FreeRTOS/tasks.c **** #define tskSTACK_FILL_BYTE                        ( 0xa5U )
  80:FreeRTOS/tasks.c **** 
  81:FreeRTOS/tasks.c **** /* Bits used to record how a task's stack and TCB were allocated. */
  82:FreeRTOS/tasks.c **** #define tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB    ( ( uint8_t ) 0 )
  83:FreeRTOS/tasks.c **** #define tskSTATICALLY_ALLOCATED_STACK_ONLY        ( ( uint8_t ) 1 )
  84:FreeRTOS/tasks.c **** #define tskSTATICALLY_ALLOCATED_STACK_AND_TCB     ( ( uint8_t ) 2 )
  85:FreeRTOS/tasks.c **** 
  86:FreeRTOS/tasks.c **** /* If any of the following are set then task stacks are filled with a known
  87:FreeRTOS/tasks.c ****  * value so the high water mark can be determined.  If none of the following are
  88:FreeRTOS/tasks.c ****  * set then don't fill the stack so there is no unnecessary dependency on memset. */
  89:FreeRTOS/tasks.c **** #if ( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTa
  90:FreeRTOS/tasks.c ****     #define tskSET_NEW_STACKS_TO_KNOWN_VALUE    1
  91:FreeRTOS/tasks.c **** #else
ARM GAS  /tmp/ccrgBt0i.s 			page 3


  92:FreeRTOS/tasks.c ****     #define tskSET_NEW_STACKS_TO_KNOWN_VALUE    0
  93:FreeRTOS/tasks.c **** #endif
  94:FreeRTOS/tasks.c **** 
  95:FreeRTOS/tasks.c **** /*
  96:FreeRTOS/tasks.c ****  * Macros used by vListTask to indicate which state a task is in.
  97:FreeRTOS/tasks.c ****  */
  98:FreeRTOS/tasks.c **** #define tskRUNNING_CHAR      ( 'X' )
  99:FreeRTOS/tasks.c **** #define tskBLOCKED_CHAR      ( 'B' )
 100:FreeRTOS/tasks.c **** #define tskREADY_CHAR        ( 'R' )
 101:FreeRTOS/tasks.c **** #define tskDELETED_CHAR      ( 'D' )
 102:FreeRTOS/tasks.c **** #define tskSUSPENDED_CHAR    ( 'S' )
 103:FreeRTOS/tasks.c **** 
 104:FreeRTOS/tasks.c **** /*
 105:FreeRTOS/tasks.c ****  * Some kernel aware debuggers require the data the debugger needs access to to
 106:FreeRTOS/tasks.c ****  * be global, rather than file scope.
 107:FreeRTOS/tasks.c ****  */
 108:FreeRTOS/tasks.c **** #ifdef portREMOVE_STATIC_QUALIFIER
 109:FreeRTOS/tasks.c ****     #define static
 110:FreeRTOS/tasks.c **** #endif
 111:FreeRTOS/tasks.c **** 
 112:FreeRTOS/tasks.c **** /* The name allocated to the Idle task.  This can be overridden by defining
 113:FreeRTOS/tasks.c ****  * configIDLE_TASK_NAME in FreeRTOSConfig.h. */
 114:FreeRTOS/tasks.c **** #ifndef configIDLE_TASK_NAME
 115:FreeRTOS/tasks.c ****     #define configIDLE_TASK_NAME    "IDLE"
 116:FreeRTOS/tasks.c **** #endif
 117:FreeRTOS/tasks.c **** 
 118:FreeRTOS/tasks.c **** #if ( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
 119:FreeRTOS/tasks.c **** 
 120:FreeRTOS/tasks.c **** /* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 0 then task selection is
 121:FreeRTOS/tasks.c ****  * performed in a generic way that is not optimised to any particular
 122:FreeRTOS/tasks.c ****  * microcontroller architecture. */
 123:FreeRTOS/tasks.c **** 
 124:FreeRTOS/tasks.c **** /* uxTopReadyPriority holds the priority of the highest priority ready
 125:FreeRTOS/tasks.c ****  * state task. */
 126:FreeRTOS/tasks.c ****     #define taskRECORD_READY_PRIORITY( uxPriority ) \
 127:FreeRTOS/tasks.c ****     {                                               \
 128:FreeRTOS/tasks.c ****         if( ( uxPriority ) > uxTopReadyPriority )   \
 129:FreeRTOS/tasks.c ****         {                                           \
 130:FreeRTOS/tasks.c ****             uxTopReadyPriority = ( uxPriority );    \
 131:FreeRTOS/tasks.c ****         }                                           \
 132:FreeRTOS/tasks.c ****     } /* taskRECORD_READY_PRIORITY */
 133:FreeRTOS/tasks.c **** 
 134:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 135:FreeRTOS/tasks.c **** 
 136:FreeRTOS/tasks.c ****     #define taskSELECT_HIGHEST_PRIORITY_TASK()                                \
 137:FreeRTOS/tasks.c ****     {                                                                         \
 138:FreeRTOS/tasks.c ****         UBaseType_t uxTopPriority = uxTopReadyPriority;                       \
 139:FreeRTOS/tasks.c ****                                                                               \
 140:FreeRTOS/tasks.c ****         /* Find the highest priority queue that contains ready tasks. */      \
 141:FreeRTOS/tasks.c ****         while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopPriority ] ) ) ) \
 142:FreeRTOS/tasks.c ****         {                                                                     \
 143:FreeRTOS/tasks.c ****             configASSERT( uxTopPriority );                                    \
 144:FreeRTOS/tasks.c ****             --uxTopPriority;                                                  \
 145:FreeRTOS/tasks.c ****         }                                                                     \
 146:FreeRTOS/tasks.c ****                                                                               \
 147:FreeRTOS/tasks.c ****         /* listGET_OWNER_OF_NEXT_ENTRY indexes through the list, so the tasks of \
 148:FreeRTOS/tasks.c ****          * the  same priority get an equal share of the processor time. */                    \
ARM GAS  /tmp/ccrgBt0i.s 			page 4


 149:FreeRTOS/tasks.c ****         listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) ); \
 150:FreeRTOS/tasks.c ****         uxTopReadyPriority = uxTopPriority;                                                   \
 151:FreeRTOS/tasks.c ****     } /* taskSELECT_HIGHEST_PRIORITY_TASK */
 152:FreeRTOS/tasks.c **** 
 153:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 154:FreeRTOS/tasks.c **** 
 155:FreeRTOS/tasks.c **** /* Define away taskRESET_READY_PRIORITY() and portRESET_READY_PRIORITY() as
 156:FreeRTOS/tasks.c ****  * they are only required when a port optimised method of task selection is
 157:FreeRTOS/tasks.c ****  * being used. */
 158:FreeRTOS/tasks.c ****     #define taskRESET_READY_PRIORITY( uxPriority )
 159:FreeRTOS/tasks.c ****     #define portRESET_READY_PRIORITY( uxPriority, uxTopReadyPriority )
 160:FreeRTOS/tasks.c **** 
 161:FreeRTOS/tasks.c **** #else /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 162:FreeRTOS/tasks.c **** 
 163:FreeRTOS/tasks.c **** /* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 1 then task selection is
 164:FreeRTOS/tasks.c ****  * performed in a way that is tailored to the particular microcontroller
 165:FreeRTOS/tasks.c ****  * architecture being used. */
 166:FreeRTOS/tasks.c **** 
 167:FreeRTOS/tasks.c **** /* A port optimised version is provided.  Call the port defined macros. */
 168:FreeRTOS/tasks.c ****     #define taskRECORD_READY_PRIORITY( uxPriority )    portRECORD_READY_PRIORITY( uxPriority, uxTop
 169:FreeRTOS/tasks.c **** 
 170:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 171:FreeRTOS/tasks.c **** 
 172:FreeRTOS/tasks.c ****     #define taskSELECT_HIGHEST_PRIORITY_TASK()                                                  \
 173:FreeRTOS/tasks.c ****     {                                                                                           \
 174:FreeRTOS/tasks.c ****         UBaseType_t uxTopPriority;                                                              \
 175:FreeRTOS/tasks.c ****                                                                                                 \
 176:FreeRTOS/tasks.c ****         /* Find the highest priority list that contains ready tasks. */                         \
 177:FreeRTOS/tasks.c ****         portGET_HIGHEST_PRIORITY( uxTopPriority, uxTopReadyPriority );                          \
 178:FreeRTOS/tasks.c ****         configASSERT( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ uxTopPriority ] ) ) > 0 ); \
 179:FreeRTOS/tasks.c ****         listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );   \
 180:FreeRTOS/tasks.c ****     } /* taskSELECT_HIGHEST_PRIORITY_TASK() */
 181:FreeRTOS/tasks.c **** 
 182:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 183:FreeRTOS/tasks.c **** 
 184:FreeRTOS/tasks.c **** /* A port optimised version is provided, call it only if the TCB being reset
 185:FreeRTOS/tasks.c ****  * is being referenced from a ready list.  If it is referenced from a delayed
 186:FreeRTOS/tasks.c ****  * or suspended list then it won't be in a ready list. */
 187:FreeRTOS/tasks.c ****     #define taskRESET_READY_PRIORITY( uxPriority )                                                 
 188:FreeRTOS/tasks.c ****     {                                                                                              
 189:FreeRTOS/tasks.c ****         if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ ( uxPriority ) ] ) ) == ( UBaseType_t ) 
 190:FreeRTOS/tasks.c ****         {                                                                                          
 191:FreeRTOS/tasks.c ****             portRESET_READY_PRIORITY( ( uxPriority ), ( uxTopReadyPriority ) );                    
 192:FreeRTOS/tasks.c ****         }                                                                                          
 193:FreeRTOS/tasks.c ****     }
 194:FreeRTOS/tasks.c **** 
 195:FreeRTOS/tasks.c **** #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 196:FreeRTOS/tasks.c **** 
 197:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 198:FreeRTOS/tasks.c **** 
 199:FreeRTOS/tasks.c **** /* pxDelayedTaskList and pxOverflowDelayedTaskList are switched when the tick
 200:FreeRTOS/tasks.c ****  * count overflows. */
 201:FreeRTOS/tasks.c **** #define taskSWITCH_DELAYED_LISTS()                                                \
 202:FreeRTOS/tasks.c ****     {                                                                             \
 203:FreeRTOS/tasks.c ****         List_t * pxTemp;                                                          \
 204:FreeRTOS/tasks.c ****                                                                                   \
 205:FreeRTOS/tasks.c ****         /* The delayed tasks list should be empty when the lists are switched. */ \
ARM GAS  /tmp/ccrgBt0i.s 			page 5


 206:FreeRTOS/tasks.c ****         configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );               \
 207:FreeRTOS/tasks.c ****                                                                                   \
 208:FreeRTOS/tasks.c ****         pxTemp = pxDelayedTaskList;                                               \
 209:FreeRTOS/tasks.c ****         pxDelayedTaskList = pxOverflowDelayedTaskList;                            \
 210:FreeRTOS/tasks.c ****         pxOverflowDelayedTaskList = pxTemp;                                       \
 211:FreeRTOS/tasks.c ****         xNumOfOverflows++;                                                        \
 212:FreeRTOS/tasks.c ****         prvResetNextTaskUnblockTime();                                            \
 213:FreeRTOS/tasks.c ****     }
 214:FreeRTOS/tasks.c **** 
 215:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 216:FreeRTOS/tasks.c **** 
 217:FreeRTOS/tasks.c **** /*
 218:FreeRTOS/tasks.c ****  * Place the task represented by pxTCB into the appropriate ready list for
 219:FreeRTOS/tasks.c ****  * the task.  It is inserted at the end of the list.
 220:FreeRTOS/tasks.c ****  */
 221:FreeRTOS/tasks.c **** #define prvAddTaskToReadyList( pxTCB )                                                             
 222:FreeRTOS/tasks.c ****     traceMOVED_TASK_TO_READY_STATE( pxTCB );                                                       
 223:FreeRTOS/tasks.c ****     taskRECORD_READY_PRIORITY( ( pxTCB )->uxPriority );                                            
 224:FreeRTOS/tasks.c ****     listINSERT_END( &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xStateListItem )
 225:FreeRTOS/tasks.c ****     tracePOST_MOVED_TASK_TO_READY_STATE( pxTCB )
 226:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 227:FreeRTOS/tasks.c **** 
 228:FreeRTOS/tasks.c **** /*
 229:FreeRTOS/tasks.c ****  * Several functions take a TaskHandle_t parameter that can optionally be NULL,
 230:FreeRTOS/tasks.c ****  * where NULL is used to indicate that the handle of the currently executing
 231:FreeRTOS/tasks.c ****  * task should be used in place of the parameter.  This macro simply checks to
 232:FreeRTOS/tasks.c ****  * see if the parameter is NULL and returns a pointer to the appropriate TCB.
 233:FreeRTOS/tasks.c ****  */
 234:FreeRTOS/tasks.c **** #define prvGetTCBFromHandle( pxHandle )    ( ( ( pxHandle ) == NULL ) ? pxCurrentTCB : ( pxHandle )
 235:FreeRTOS/tasks.c **** 
 236:FreeRTOS/tasks.c **** /* The item value of the event list item is normally used to hold the priority
 237:FreeRTOS/tasks.c ****  * of the task to which it belongs (coded to allow it to be held in reverse
 238:FreeRTOS/tasks.c ****  * priority order).  However, it is occasionally borrowed for other purposes.  It
 239:FreeRTOS/tasks.c ****  * is important its value is not updated due to a task priority change while it is
 240:FreeRTOS/tasks.c ****  * being used for another purpose.  The following bit definition is used to inform
 241:FreeRTOS/tasks.c ****  * the scheduler that the value should not be changed - in which case it is the
 242:FreeRTOS/tasks.c ****  * responsibility of whichever module is using the value to ensure it gets set back
 243:FreeRTOS/tasks.c ****  * to its original value when it is released. */
 244:FreeRTOS/tasks.c **** #if ( configUSE_16_BIT_TICKS == 1 )
 245:FreeRTOS/tasks.c ****     #define taskEVENT_LIST_ITEM_VALUE_IN_USE    0x8000U
 246:FreeRTOS/tasks.c **** #else
 247:FreeRTOS/tasks.c ****     #define taskEVENT_LIST_ITEM_VALUE_IN_USE    0x80000000UL
 248:FreeRTOS/tasks.c **** #endif
 249:FreeRTOS/tasks.c **** 
 250:FreeRTOS/tasks.c **** /*
 251:FreeRTOS/tasks.c ****  * Task control block.  A task control block (TCB) is allocated for each task,
 252:FreeRTOS/tasks.c ****  * and stores task state information, including a pointer to the task's context
 253:FreeRTOS/tasks.c ****  * (the task's run time environment, including register values)
 254:FreeRTOS/tasks.c ****  */
 255:FreeRTOS/tasks.c **** typedef struct tskTaskControlBlock       /* The old naming convention is used to prevent breaking k
 256:FreeRTOS/tasks.c **** {
 257:FreeRTOS/tasks.c ****     volatile StackType_t * pxTopOfStack; /*< Points to the location of the last item placed on the 
 258:FreeRTOS/tasks.c **** 
 259:FreeRTOS/tasks.c ****     #if ( portUSING_MPU_WRAPPERS == 1 )
 260:FreeRTOS/tasks.c ****         xMPU_SETTINGS xMPUSettings; /*< The MPU settings are defined as part of the port layer.  TH
 261:FreeRTOS/tasks.c ****     #endif
 262:FreeRTOS/tasks.c **** 
ARM GAS  /tmp/ccrgBt0i.s 			page 6


 263:FreeRTOS/tasks.c ****     ListItem_t xStateListItem;                  /*< The list that the state list item of a task is 
 264:FreeRTOS/tasks.c ****     ListItem_t xEventListItem;                  /*< Used to reference a task from an event list. */
 265:FreeRTOS/tasks.c ****     UBaseType_t uxPriority;                     /*< The priority of the task.  0 is the lowest prio
 266:FreeRTOS/tasks.c ****     StackType_t * pxStack;                      /*< Points to the start of the stack. */
 267:FreeRTOS/tasks.c ****     char pcTaskName[ configMAX_TASK_NAME_LEN ]; /*< Descriptive name given to the task when created
 268:FreeRTOS/tasks.c **** 
 269:FreeRTOS/tasks.c ****     #if ( ( portSTACK_GROWTH > 0 ) || ( configRECORD_STACK_HIGH_ADDRESS == 1 ) )
 270:FreeRTOS/tasks.c ****         StackType_t * pxEndOfStack; /*< Points to the highest valid address for the stack. */
 271:FreeRTOS/tasks.c ****     #endif
 272:FreeRTOS/tasks.c **** 
 273:FreeRTOS/tasks.c ****     #if ( portCRITICAL_NESTING_IN_TCB == 1 )
 274:FreeRTOS/tasks.c ****         UBaseType_t uxCriticalNesting; /*< Holds the critical section nesting depth for ports that 
 275:FreeRTOS/tasks.c ****     #endif
 276:FreeRTOS/tasks.c **** 
 277:FreeRTOS/tasks.c ****     #if ( configUSE_TRACE_FACILITY == 1 )
 278:FreeRTOS/tasks.c ****         UBaseType_t uxTCBNumber;  /*< Stores a number that increments each time a TCB is created.  
 279:FreeRTOS/tasks.c ****         UBaseType_t uxTaskNumber; /*< Stores a number specifically for use by third party trace cod
 280:FreeRTOS/tasks.c ****     #endif
 281:FreeRTOS/tasks.c **** 
 282:FreeRTOS/tasks.c ****     #if ( configUSE_MUTEXES == 1 )
 283:FreeRTOS/tasks.c ****         UBaseType_t uxBasePriority; /*< The priority last assigned to the task - used by the priori
 284:FreeRTOS/tasks.c ****         UBaseType_t uxMutexesHeld;
 285:FreeRTOS/tasks.c ****     #endif
 286:FreeRTOS/tasks.c **** 
 287:FreeRTOS/tasks.c ****     #if ( configUSE_APPLICATION_TASK_TAG == 1 )
 288:FreeRTOS/tasks.c ****         TaskHookFunction_t pxTaskTag;
 289:FreeRTOS/tasks.c ****     #endif
 290:FreeRTOS/tasks.c **** 
 291:FreeRTOS/tasks.c ****     #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0 )
 292:FreeRTOS/tasks.c ****         void * pvThreadLocalStoragePointers[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ];
 293:FreeRTOS/tasks.c ****     #endif
 294:FreeRTOS/tasks.c **** 
 295:FreeRTOS/tasks.c ****     #if ( configGENERATE_RUN_TIME_STATS == 1 )
 296:FreeRTOS/tasks.c ****         configRUN_TIME_COUNTER_TYPE ulRunTimeCounter; /*< Stores the amount of time the task has sp
 297:FreeRTOS/tasks.c ****     #endif
 298:FreeRTOS/tasks.c **** 
 299:FreeRTOS/tasks.c ****     #if ( configUSE_NEWLIB_REENTRANT == 1 )
 300:FreeRTOS/tasks.c **** 
 301:FreeRTOS/tasks.c ****         /* Allocate a Newlib reent structure that is specific to this task.
 302:FreeRTOS/tasks.c ****          * Note Newlib support has been included by popular demand, but is not
 303:FreeRTOS/tasks.c ****          * used by the FreeRTOS maintainers themselves.  FreeRTOS is not
 304:FreeRTOS/tasks.c ****          * responsible for resulting newlib operation.  User must be familiar with
 305:FreeRTOS/tasks.c ****          * newlib and must provide system-wide implementations of the necessary
 306:FreeRTOS/tasks.c ****          * stubs. Be warned that (at the time of writing) the current newlib design
 307:FreeRTOS/tasks.c ****          * implements a system-wide malloc() that must be provided with locks.
 308:FreeRTOS/tasks.c ****          *
 309:FreeRTOS/tasks.c ****          * See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html
 310:FreeRTOS/tasks.c ****          * for additional information. */
 311:FreeRTOS/tasks.c ****         struct  _reent xNewLib_reent;
 312:FreeRTOS/tasks.c ****     #endif
 313:FreeRTOS/tasks.c **** 
 314:FreeRTOS/tasks.c ****     #if ( configUSE_TASK_NOTIFICATIONS == 1 )
 315:FreeRTOS/tasks.c ****         volatile uint32_t ulNotifiedValue[ configTASK_NOTIFICATION_ARRAY_ENTRIES ];
 316:FreeRTOS/tasks.c ****         volatile uint8_t ucNotifyState[ configTASK_NOTIFICATION_ARRAY_ENTRIES ];
 317:FreeRTOS/tasks.c ****     #endif
 318:FreeRTOS/tasks.c **** 
 319:FreeRTOS/tasks.c ****     /* See the comments in FreeRTOS.h with the definition of
ARM GAS  /tmp/ccrgBt0i.s 			page 7


 320:FreeRTOS/tasks.c ****      * tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE. */
 321:FreeRTOS/tasks.c ****     #if ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been conso
 322:FreeRTOS/tasks.c ****         uint8_t ucStaticallyAllocated;                     /*< Set to pdTRUE if the task is a stati
 323:FreeRTOS/tasks.c ****     #endif
 324:FreeRTOS/tasks.c **** 
 325:FreeRTOS/tasks.c ****     #if ( INCLUDE_xTaskAbortDelay == 1 )
 326:FreeRTOS/tasks.c ****         uint8_t ucDelayAborted;
 327:FreeRTOS/tasks.c ****     #endif
 328:FreeRTOS/tasks.c **** 
 329:FreeRTOS/tasks.c ****     #if ( configUSE_POSIX_ERRNO == 1 )
 330:FreeRTOS/tasks.c ****         int iTaskErrno;
 331:FreeRTOS/tasks.c ****     #endif
 332:FreeRTOS/tasks.c **** } tskTCB;
 333:FreeRTOS/tasks.c **** 
 334:FreeRTOS/tasks.c **** /* The old tskTCB name is maintained above then typedefed to the new TCB_t name
 335:FreeRTOS/tasks.c ****  * below to enable the use of older kernel aware debuggers. */
 336:FreeRTOS/tasks.c **** typedef tskTCB TCB_t;
 337:FreeRTOS/tasks.c **** 
 338:FreeRTOS/tasks.c **** /*lint -save -e956 A manual analysis and inspection has been used to determine
 339:FreeRTOS/tasks.c ****  * which static variables must be declared volatile. */
 340:FreeRTOS/tasks.c **** PRIVILEGED_DATA TCB_t * volatile pxCurrentTCB = NULL;
 341:FreeRTOS/tasks.c **** 
 342:FreeRTOS/tasks.c **** /* Lists for ready and blocked tasks. --------------------
 343:FreeRTOS/tasks.c ****  * xDelayedTaskList1 and xDelayedTaskList2 could be moved to function scope but
 344:FreeRTOS/tasks.c ****  * doing so breaks some kernel aware debuggers and debuggers that rely on removing
 345:FreeRTOS/tasks.c ****  * the static qualifier. */
 346:FreeRTOS/tasks.c **** PRIVILEGED_DATA static List_t pxReadyTasksLists[ configMAX_PRIORITIES ]; /*< Prioritised ready task
 347:FreeRTOS/tasks.c **** PRIVILEGED_DATA static List_t xDelayedTaskList1;                         /*< Delayed tasks. */
 348:FreeRTOS/tasks.c **** PRIVILEGED_DATA static List_t xDelayedTaskList2;                         /*< Delayed tasks (two lis
 349:FreeRTOS/tasks.c **** PRIVILEGED_DATA static List_t * volatile pxDelayedTaskList;              /*< Points to the delayed 
 350:FreeRTOS/tasks.c **** PRIVILEGED_DATA static List_t * volatile pxOverflowDelayedTaskList;      /*< Points to the delayed 
 351:FreeRTOS/tasks.c **** PRIVILEGED_DATA static List_t xPendingReadyList;                         /*< Tasks that have been r
 352:FreeRTOS/tasks.c **** 
 353:FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 354:FreeRTOS/tasks.c **** 
 355:FreeRTOS/tasks.c ****     PRIVILEGED_DATA static List_t xTasksWaitingTermination; /*< Tasks that have been deleted - but 
 356:FreeRTOS/tasks.c ****     PRIVILEGED_DATA static volatile UBaseType_t uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
 357:FreeRTOS/tasks.c **** 
 358:FreeRTOS/tasks.c **** #endif
 359:FreeRTOS/tasks.c **** 
 360:FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 361:FreeRTOS/tasks.c **** 
 362:FreeRTOS/tasks.c ****     PRIVILEGED_DATA static List_t xSuspendedTaskList; /*< Tasks that are currently suspended. */
 363:FreeRTOS/tasks.c **** 
 364:FreeRTOS/tasks.c **** #endif
 365:FreeRTOS/tasks.c **** 
 366:FreeRTOS/tasks.c **** /* Global POSIX errno. Its value is changed upon context switching to match
 367:FreeRTOS/tasks.c ****  * the errno of the currently running task. */
 368:FreeRTOS/tasks.c **** #if ( configUSE_POSIX_ERRNO == 1 )
 369:FreeRTOS/tasks.c ****     int FreeRTOS_errno = 0;
 370:FreeRTOS/tasks.c **** #endif
 371:FreeRTOS/tasks.c **** 
 372:FreeRTOS/tasks.c **** /* Other file private variables. --------------------------------*/
 373:FreeRTOS/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxCurrentNumberOfTasks = ( UBaseType_t ) 0U;
 374:FreeRTOS/tasks.c **** PRIVILEGED_DATA static volatile TickType_t xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
 375:FreeRTOS/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxTopReadyPriority = tskIDLE_PRIORITY;
 376:FreeRTOS/tasks.c **** PRIVILEGED_DATA static volatile BaseType_t xSchedulerRunning = pdFALSE;
ARM GAS  /tmp/ccrgBt0i.s 			page 8


 377:FreeRTOS/tasks.c **** PRIVILEGED_DATA static volatile TickType_t xPendedTicks = ( TickType_t ) 0U;
 378:FreeRTOS/tasks.c **** PRIVILEGED_DATA static volatile BaseType_t xYieldPending = pdFALSE;
 379:FreeRTOS/tasks.c **** PRIVILEGED_DATA static volatile BaseType_t xNumOfOverflows = ( BaseType_t ) 0;
 380:FreeRTOS/tasks.c **** PRIVILEGED_DATA static UBaseType_t uxTaskNumber = ( UBaseType_t ) 0U;
 381:FreeRTOS/tasks.c **** PRIVILEGED_DATA static volatile TickType_t xNextTaskUnblockTime = ( TickType_t ) 0U; /* Initialised
 382:FreeRTOS/tasks.c **** PRIVILEGED_DATA static TaskHandle_t xIdleTaskHandle = NULL;                          /*< Holds the 
 383:FreeRTOS/tasks.c **** 
 384:FreeRTOS/tasks.c **** /* Improve support for OpenOCD. The kernel tracks Ready tasks via priority lists.
 385:FreeRTOS/tasks.c ****  * For tracking the state of remote threads, OpenOCD uses uxTopUsedPriority
 386:FreeRTOS/tasks.c ****  * to determine the number of priority lists to read back from the remote target. */
 387:FreeRTOS/tasks.c **** const volatile UBaseType_t uxTopUsedPriority = configMAX_PRIORITIES - 1U;
 388:FreeRTOS/tasks.c **** 
 389:FreeRTOS/tasks.c **** /* Context switches are held pending while the scheduler is suspended.  Also,
 390:FreeRTOS/tasks.c ****  * interrupts must not manipulate the xStateListItem of a TCB, or any of the
 391:FreeRTOS/tasks.c ****  * lists the xStateListItem can be referenced from, if the scheduler is suspended.
 392:FreeRTOS/tasks.c ****  * If an interrupt needs to unblock a task while the scheduler is suspended then it
 393:FreeRTOS/tasks.c ****  * moves the task's event list item into the xPendingReadyList, ready for the
 394:FreeRTOS/tasks.c ****  * kernel to move the task from the pending ready list into the real ready list
 395:FreeRTOS/tasks.c ****  * when the scheduler is unsuspended.  The pending ready list itself can only be
 396:FreeRTOS/tasks.c ****  * accessed from a critical section. */
 397:FreeRTOS/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxSchedulerSuspended = ( UBaseType_t ) pdFALSE;
 398:FreeRTOS/tasks.c **** 
 399:FreeRTOS/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
 400:FreeRTOS/tasks.c **** 
 401:FreeRTOS/tasks.c **** /* Do not move these variables to function scope as doing so prevents the
 402:FreeRTOS/tasks.c ****  * code working with debuggers that need to remove the static qualifier. */
 403:FreeRTOS/tasks.c ****     PRIVILEGED_DATA static configRUN_TIME_COUNTER_TYPE ulTaskSwitchedInTime = 0UL;    /*< Holds the
 404:FreeRTOS/tasks.c ****     PRIVILEGED_DATA static volatile configRUN_TIME_COUNTER_TYPE ulTotalRunTime = 0UL; /*< Holds the
 405:FreeRTOS/tasks.c **** 
 406:FreeRTOS/tasks.c **** #endif
 407:FreeRTOS/tasks.c **** 
 408:FreeRTOS/tasks.c **** /*lint -restore */
 409:FreeRTOS/tasks.c **** 
 410:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 411:FreeRTOS/tasks.c **** 
 412:FreeRTOS/tasks.c **** /* File private functions. --------------------------------*/
 413:FreeRTOS/tasks.c **** 
 414:FreeRTOS/tasks.c **** /**
 415:FreeRTOS/tasks.c ****  * Utility task that simply returns pdTRUE if the task referenced by xTask is
 416:FreeRTOS/tasks.c ****  * currently in the Suspended state, or pdFALSE if the task referenced by xTask
 417:FreeRTOS/tasks.c ****  * is in any other state.
 418:FreeRTOS/tasks.c ****  */
 419:FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 420:FreeRTOS/tasks.c **** 
 421:FreeRTOS/tasks.c ****     static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
 422:FreeRTOS/tasks.c **** 
 423:FreeRTOS/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
 424:FreeRTOS/tasks.c **** 
 425:FreeRTOS/tasks.c **** /*
 426:FreeRTOS/tasks.c ****  * Utility to ready all the lists used by the scheduler.  This is called
 427:FreeRTOS/tasks.c ****  * automatically upon the creation of the first task.
 428:FreeRTOS/tasks.c ****  */
 429:FreeRTOS/tasks.c **** static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
 430:FreeRTOS/tasks.c **** 
 431:FreeRTOS/tasks.c **** /*
 432:FreeRTOS/tasks.c ****  * The idle task, which as all tasks is implemented as a never ending loop.
 433:FreeRTOS/tasks.c ****  * The idle task is automatically created and added to the ready lists upon
ARM GAS  /tmp/ccrgBt0i.s 			page 9


 434:FreeRTOS/tasks.c ****  * creation of the first user task.
 435:FreeRTOS/tasks.c ****  *
 436:FreeRTOS/tasks.c ****  * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
 437:FreeRTOS/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
 438:FreeRTOS/tasks.c ****  *
 439:FreeRTOS/tasks.c ****  * void prvIdleTask( void *pvParameters );
 440:FreeRTOS/tasks.c ****  *
 441:FreeRTOS/tasks.c ****  */
 442:FreeRTOS/tasks.c **** static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters ) PRIVILEGED_FUNCTION;
 443:FreeRTOS/tasks.c **** 
 444:FreeRTOS/tasks.c **** /*
 445:FreeRTOS/tasks.c ****  * Utility to free all memory allocated by the scheduler to hold a TCB,
 446:FreeRTOS/tasks.c ****  * including the stack pointed to by the TCB.
 447:FreeRTOS/tasks.c ****  *
 448:FreeRTOS/tasks.c ****  * This does not free memory allocated by the task itself (i.e. memory
 449:FreeRTOS/tasks.c ****  * allocated by calls to pvPortMalloc from within the tasks application code).
 450:FreeRTOS/tasks.c ****  */
 451:FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 452:FreeRTOS/tasks.c **** 
 453:FreeRTOS/tasks.c ****     static void prvDeleteTCB( TCB_t * pxTCB ) PRIVILEGED_FUNCTION;
 454:FreeRTOS/tasks.c **** 
 455:FreeRTOS/tasks.c **** #endif
 456:FreeRTOS/tasks.c **** 
 457:FreeRTOS/tasks.c **** /*
 458:FreeRTOS/tasks.c ****  * Used only by the idle task.  This checks to see if anything has been placed
 459:FreeRTOS/tasks.c ****  * in the list of tasks waiting to be deleted.  If so the task is cleaned up
 460:FreeRTOS/tasks.c ****  * and its TCB deleted.
 461:FreeRTOS/tasks.c ****  */
 462:FreeRTOS/tasks.c **** static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
 463:FreeRTOS/tasks.c **** 
 464:FreeRTOS/tasks.c **** /*
 465:FreeRTOS/tasks.c ****  * The currently executing task is entering the Blocked state.  Add the task to
 466:FreeRTOS/tasks.c ****  * either the current or the overflow delayed task list.
 467:FreeRTOS/tasks.c ****  */
 468:FreeRTOS/tasks.c **** static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
 469:FreeRTOS/tasks.c ****                                             const BaseType_t xCanBlockIndefinitely ) PRIVILEGED_FUN
 470:FreeRTOS/tasks.c **** 
 471:FreeRTOS/tasks.c **** /*
 472:FreeRTOS/tasks.c ****  * Fills an TaskStatus_t structure with information on each task that is
 473:FreeRTOS/tasks.c ****  * referenced from the pxList list (which may be a ready list, a delayed list,
 474:FreeRTOS/tasks.c ****  * a suspended list, etc.).
 475:FreeRTOS/tasks.c ****  *
 476:FreeRTOS/tasks.c ****  * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
 477:FreeRTOS/tasks.c ****  * NORMAL APPLICATION CODE.
 478:FreeRTOS/tasks.c ****  */
 479:FreeRTOS/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
 480:FreeRTOS/tasks.c **** 
 481:FreeRTOS/tasks.c ****     static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t * pxTaskStatusArray,
 482:FreeRTOS/tasks.c ****                                                      List_t * pxList,
 483:FreeRTOS/tasks.c ****                                                      eTaskState eState ) PRIVILEGED_FUNCTION;
 484:FreeRTOS/tasks.c **** 
 485:FreeRTOS/tasks.c **** #endif
 486:FreeRTOS/tasks.c **** 
 487:FreeRTOS/tasks.c **** /*
 488:FreeRTOS/tasks.c ****  * Searches pxList for a task with name pcNameToQuery - returning a handle to
 489:FreeRTOS/tasks.c ****  * the task if it is found, or NULL if the task is not found.
 490:FreeRTOS/tasks.c ****  */
ARM GAS  /tmp/ccrgBt0i.s 			page 10


 491:FreeRTOS/tasks.c **** #if ( INCLUDE_xTaskGetHandle == 1 )
 492:FreeRTOS/tasks.c **** 
 493:FreeRTOS/tasks.c ****     static TCB_t * prvSearchForNameWithinSingleList( List_t * pxList,
 494:FreeRTOS/tasks.c ****                                                      const char pcNameToQuery[] ) PRIVILEGED_FUNCTI
 495:FreeRTOS/tasks.c **** 
 496:FreeRTOS/tasks.c **** #endif
 497:FreeRTOS/tasks.c **** 
 498:FreeRTOS/tasks.c **** /*
 499:FreeRTOS/tasks.c ****  * When a task is created, the stack of the task is filled with a known value.
 500:FreeRTOS/tasks.c ****  * This function determines the 'high water mark' of the task stack by
 501:FreeRTOS/tasks.c ****  * determining how much of the stack remains at the original preset value.
 502:FreeRTOS/tasks.c ****  */
 503:FreeRTOS/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) || ( INCLUD
 504:FreeRTOS/tasks.c **** 
 505:FreeRTOS/tasks.c ****     static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte ) PRIVIL
 506:FreeRTOS/tasks.c **** 
 507:FreeRTOS/tasks.c **** #endif
 508:FreeRTOS/tasks.c **** 
 509:FreeRTOS/tasks.c **** /*
 510:FreeRTOS/tasks.c ****  * Return the amount of time, in ticks, that will pass before the kernel will
 511:FreeRTOS/tasks.c ****  * next move a task from the Blocked state to the Running state.
 512:FreeRTOS/tasks.c ****  *
 513:FreeRTOS/tasks.c ****  * This conditional compilation should use inequality to 0, not equality to 1.
 514:FreeRTOS/tasks.c ****  * This is to ensure portSUPPRESS_TICKS_AND_SLEEP() can be called when user
 515:FreeRTOS/tasks.c ****  * defined low power mode implementations require configUSE_TICKLESS_IDLE to be
 516:FreeRTOS/tasks.c ****  * set to a value other than 1.
 517:FreeRTOS/tasks.c ****  */
 518:FreeRTOS/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
 519:FreeRTOS/tasks.c **** 
 520:FreeRTOS/tasks.c ****     static TickType_t prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;
 521:FreeRTOS/tasks.c **** 
 522:FreeRTOS/tasks.c **** #endif
 523:FreeRTOS/tasks.c **** 
 524:FreeRTOS/tasks.c **** /*
 525:FreeRTOS/tasks.c ****  * Set xNextTaskUnblockTime to the time at which the next Blocked state task
 526:FreeRTOS/tasks.c ****  * will exit the Blocked state.
 527:FreeRTOS/tasks.c ****  */
 528:FreeRTOS/tasks.c **** static void prvResetNextTaskUnblockTime( void ) PRIVILEGED_FUNCTION;
 529:FreeRTOS/tasks.c **** 
 530:FreeRTOS/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
 531:FreeRTOS/tasks.c **** 
 532:FreeRTOS/tasks.c **** /*
 533:FreeRTOS/tasks.c ****  * Helper function used to pad task names with spaces when printing out
 534:FreeRTOS/tasks.c ****  * human readable tables of task information.
 535:FreeRTOS/tasks.c ****  */
 536:FreeRTOS/tasks.c ****     static char * prvWriteNameToBuffer( char * pcBuffer,
 537:FreeRTOS/tasks.c ****                                         const char * pcTaskName ) PRIVILEGED_FUNCTION;
 538:FreeRTOS/tasks.c **** 
 539:FreeRTOS/tasks.c **** #endif
 540:FreeRTOS/tasks.c **** 
 541:FreeRTOS/tasks.c **** /*
 542:FreeRTOS/tasks.c ****  * Called after a Task_t structure has been allocated either statically or
 543:FreeRTOS/tasks.c ****  * dynamically to fill in the structure's members.
 544:FreeRTOS/tasks.c ****  */
 545:FreeRTOS/tasks.c **** static void prvInitialiseNewTask( TaskFunction_t pxTaskCode,
 546:FreeRTOS/tasks.c ****                                   const char * const pcName, /*lint !e971 Unqualified char types ar
 547:FreeRTOS/tasks.c ****                                   const uint32_t ulStackDepth,
ARM GAS  /tmp/ccrgBt0i.s 			page 11


 548:FreeRTOS/tasks.c ****                                   void * const pvParameters,
 549:FreeRTOS/tasks.c ****                                   UBaseType_t uxPriority,
 550:FreeRTOS/tasks.c ****                                   TaskHandle_t * const pxCreatedTask,
 551:FreeRTOS/tasks.c ****                                   TCB_t * pxNewTCB,
 552:FreeRTOS/tasks.c ****                                   const MemoryRegion_t * const xRegions ) PRIVILEGED_FUNCTION;
 553:FreeRTOS/tasks.c **** 
 554:FreeRTOS/tasks.c **** /*
 555:FreeRTOS/tasks.c ****  * Called after a new task has been created and initialised to place the task
 556:FreeRTOS/tasks.c ****  * under the control of the scheduler.
 557:FreeRTOS/tasks.c ****  */
 558:FreeRTOS/tasks.c **** static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB ) PRIVILEGED_FUNCTION;
 559:FreeRTOS/tasks.c **** 
 560:FreeRTOS/tasks.c **** /*
 561:FreeRTOS/tasks.c ****  * freertos_tasks_c_additions_init() should only be called if the user definable
 562:FreeRTOS/tasks.c ****  * macro FREERTOS_TASKS_C_ADDITIONS_INIT() is defined, as that is the only macro
 563:FreeRTOS/tasks.c ****  * called by the function.
 564:FreeRTOS/tasks.c ****  */
 565:FreeRTOS/tasks.c **** #ifdef FREERTOS_TASKS_C_ADDITIONS_INIT
 566:FreeRTOS/tasks.c **** 
 567:FreeRTOS/tasks.c ****     static void freertos_tasks_c_additions_init( void ) PRIVILEGED_FUNCTION;
 568:FreeRTOS/tasks.c **** 
 569:FreeRTOS/tasks.c **** #endif
 570:FreeRTOS/tasks.c **** 
 571:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 572:FreeRTOS/tasks.c **** 
 573:FreeRTOS/tasks.c **** #if ( configSUPPORT_STATIC_ALLOCATION == 1 )
 574:FreeRTOS/tasks.c **** 
 575:FreeRTOS/tasks.c ****     TaskHandle_t xTaskCreateStatic( TaskFunction_t pxTaskCode,
 576:FreeRTOS/tasks.c ****                                     const char * const pcName, /*lint !e971 Unqualified char types 
 577:FreeRTOS/tasks.c ****                                     const uint32_t ulStackDepth,
 578:FreeRTOS/tasks.c ****                                     void * const pvParameters,
 579:FreeRTOS/tasks.c ****                                     UBaseType_t uxPriority,
 580:FreeRTOS/tasks.c ****                                     StackType_t * const puxStackBuffer,
 581:FreeRTOS/tasks.c ****                                     StaticTask_t * const pxTaskBuffer )
 582:FreeRTOS/tasks.c ****     {
 583:FreeRTOS/tasks.c ****         TCB_t * pxNewTCB;
 584:FreeRTOS/tasks.c ****         TaskHandle_t xReturn;
 585:FreeRTOS/tasks.c **** 
 586:FreeRTOS/tasks.c ****         configASSERT( puxStackBuffer != NULL );
 587:FreeRTOS/tasks.c ****         configASSERT( pxTaskBuffer != NULL );
 588:FreeRTOS/tasks.c **** 
 589:FreeRTOS/tasks.c ****         #if ( configASSERT_DEFINED == 1 )
 590:FreeRTOS/tasks.c ****             {
 591:FreeRTOS/tasks.c ****                 /* Sanity check that the size of the structure used to declare a
 592:FreeRTOS/tasks.c ****                  * variable of type StaticTask_t equals the size of the real task
 593:FreeRTOS/tasks.c ****                  * structure. */
 594:FreeRTOS/tasks.c ****                 volatile size_t xSize = sizeof( StaticTask_t );
 595:FreeRTOS/tasks.c ****                 configASSERT( xSize == sizeof( TCB_t ) );
 596:FreeRTOS/tasks.c ****                 ( void ) xSize; /* Prevent lint warning when configASSERT() is not used. */
 597:FreeRTOS/tasks.c ****             }
 598:FreeRTOS/tasks.c ****         #endif /* configASSERT_DEFINED */
 599:FreeRTOS/tasks.c **** 
 600:FreeRTOS/tasks.c ****         if( ( pxTaskBuffer != NULL ) && ( puxStackBuffer != NULL ) )
 601:FreeRTOS/tasks.c ****         {
 602:FreeRTOS/tasks.c ****             /* The memory used for the task's TCB and stack are passed into this
 603:FreeRTOS/tasks.c ****              * function - use them. */
 604:FreeRTOS/tasks.c ****             pxNewTCB = ( TCB_t * ) pxTaskBuffer; /*lint !e740 !e9087 Unusual cast is ok as the stru
ARM GAS  /tmp/ccrgBt0i.s 			page 12


 605:FreeRTOS/tasks.c ****             pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
 606:FreeRTOS/tasks.c **** 
 607:FreeRTOS/tasks.c ****             #if ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has be
 608:FreeRTOS/tasks.c ****                 {
 609:FreeRTOS/tasks.c ****                     /* Tasks can be created statically or dynamically, so note this
 610:FreeRTOS/tasks.c ****                      * task was created statically in case the task is later deleted. */
 611:FreeRTOS/tasks.c ****                     pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
 612:FreeRTOS/tasks.c ****                 }
 613:FreeRTOS/tasks.c ****             #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */
 614:FreeRTOS/tasks.c **** 
 615:FreeRTOS/tasks.c ****             prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xRet
 616:FreeRTOS/tasks.c ****             prvAddNewTaskToReadyList( pxNewTCB );
 617:FreeRTOS/tasks.c ****         }
 618:FreeRTOS/tasks.c ****         else
 619:FreeRTOS/tasks.c ****         {
 620:FreeRTOS/tasks.c ****             xReturn = NULL;
 621:FreeRTOS/tasks.c ****         }
 622:FreeRTOS/tasks.c **** 
 623:FreeRTOS/tasks.c ****         return xReturn;
 624:FreeRTOS/tasks.c ****     }
 625:FreeRTOS/tasks.c **** 
 626:FreeRTOS/tasks.c **** #endif /* SUPPORT_STATIC_ALLOCATION */
 627:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 628:FreeRTOS/tasks.c **** 
 629:FreeRTOS/tasks.c **** #if ( ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
 630:FreeRTOS/tasks.c **** 
 631:FreeRTOS/tasks.c ****     BaseType_t xTaskCreateRestrictedStatic( const TaskParameters_t * const pxTaskDefinition,
 632:FreeRTOS/tasks.c ****                                             TaskHandle_t * pxCreatedTask )
 633:FreeRTOS/tasks.c ****     {
 634:FreeRTOS/tasks.c ****         TCB_t * pxNewTCB;
 635:FreeRTOS/tasks.c ****         BaseType_t xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 636:FreeRTOS/tasks.c **** 
 637:FreeRTOS/tasks.c ****         configASSERT( pxTaskDefinition->puxStackBuffer != NULL );
 638:FreeRTOS/tasks.c ****         configASSERT( pxTaskDefinition->pxTaskBuffer != NULL );
 639:FreeRTOS/tasks.c **** 
 640:FreeRTOS/tasks.c ****         if( ( pxTaskDefinition->puxStackBuffer != NULL ) && ( pxTaskDefinition->pxTaskBuffer != NUL
 641:FreeRTOS/tasks.c ****         {
 642:FreeRTOS/tasks.c ****             /* Allocate space for the TCB.  Where the memory comes from depends
 643:FreeRTOS/tasks.c ****              * on the implementation of the port malloc function and whether or
 644:FreeRTOS/tasks.c ****              * not static allocation is being used. */
 645:FreeRTOS/tasks.c ****             pxNewTCB = ( TCB_t * ) pxTaskDefinition->pxTaskBuffer;
 646:FreeRTOS/tasks.c **** 
 647:FreeRTOS/tasks.c ****             /* Store the stack location in the TCB. */
 648:FreeRTOS/tasks.c ****             pxNewTCB->pxStack = pxTaskDefinition->puxStackBuffer;
 649:FreeRTOS/tasks.c **** 
 650:FreeRTOS/tasks.c ****             #if ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )
 651:FreeRTOS/tasks.c ****                 {
 652:FreeRTOS/tasks.c ****                     /* Tasks can be created statically or dynamically, so note this
 653:FreeRTOS/tasks.c ****                      * task was created statically in case the task is later deleted. */
 654:FreeRTOS/tasks.c ****                     pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
 655:FreeRTOS/tasks.c ****                 }
 656:FreeRTOS/tasks.c ****             #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */
 657:FreeRTOS/tasks.c **** 
 658:FreeRTOS/tasks.c ****             prvInitialiseNewTask( pxTaskDefinition->pvTaskCode,
 659:FreeRTOS/tasks.c ****                                   pxTaskDefinition->pcName,
 660:FreeRTOS/tasks.c ****                                   ( uint32_t ) pxTaskDefinition->usStackDepth,
 661:FreeRTOS/tasks.c ****                                   pxTaskDefinition->pvParameters,
ARM GAS  /tmp/ccrgBt0i.s 			page 13


 662:FreeRTOS/tasks.c ****                                   pxTaskDefinition->uxPriority,
 663:FreeRTOS/tasks.c ****                                   pxCreatedTask, pxNewTCB,
 664:FreeRTOS/tasks.c ****                                   pxTaskDefinition->xRegions );
 665:FreeRTOS/tasks.c **** 
 666:FreeRTOS/tasks.c ****             prvAddNewTaskToReadyList( pxNewTCB );
 667:FreeRTOS/tasks.c ****             xReturn = pdPASS;
 668:FreeRTOS/tasks.c ****         }
 669:FreeRTOS/tasks.c **** 
 670:FreeRTOS/tasks.c ****         return xReturn;
 671:FreeRTOS/tasks.c ****     }
 672:FreeRTOS/tasks.c **** 
 673:FreeRTOS/tasks.c **** #endif /* ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
 674:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 675:FreeRTOS/tasks.c **** 
 676:FreeRTOS/tasks.c **** #if ( ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 677:FreeRTOS/tasks.c **** 
 678:FreeRTOS/tasks.c ****     BaseType_t xTaskCreateRestricted( const TaskParameters_t * const pxTaskDefinition,
 679:FreeRTOS/tasks.c ****                                       TaskHandle_t * pxCreatedTask )
 680:FreeRTOS/tasks.c ****     {
 681:FreeRTOS/tasks.c ****         TCB_t * pxNewTCB;
 682:FreeRTOS/tasks.c ****         BaseType_t xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 683:FreeRTOS/tasks.c **** 
 684:FreeRTOS/tasks.c ****         configASSERT( pxTaskDefinition->puxStackBuffer );
 685:FreeRTOS/tasks.c **** 
 686:FreeRTOS/tasks.c ****         if( pxTaskDefinition->puxStackBuffer != NULL )
 687:FreeRTOS/tasks.c ****         {
 688:FreeRTOS/tasks.c ****             /* Allocate space for the TCB.  Where the memory comes from depends
 689:FreeRTOS/tasks.c ****              * on the implementation of the port malloc function and whether or
 690:FreeRTOS/tasks.c ****              * not static allocation is being used. */
 691:FreeRTOS/tasks.c ****             pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
 692:FreeRTOS/tasks.c **** 
 693:FreeRTOS/tasks.c ****             if( pxNewTCB != NULL )
 694:FreeRTOS/tasks.c ****             {
 695:FreeRTOS/tasks.c ****                 /* Store the stack location in the TCB. */
 696:FreeRTOS/tasks.c ****                 pxNewTCB->pxStack = pxTaskDefinition->puxStackBuffer;
 697:FreeRTOS/tasks.c **** 
 698:FreeRTOS/tasks.c ****                 #if ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )
 699:FreeRTOS/tasks.c ****                     {
 700:FreeRTOS/tasks.c ****                         /* Tasks can be created statically or dynamically, so note
 701:FreeRTOS/tasks.c ****                          * this task had a statically allocated stack in case it is
 702:FreeRTOS/tasks.c ****                          * later deleted.  The TCB was allocated dynamically. */
 703:FreeRTOS/tasks.c ****                         pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_ONLY;
 704:FreeRTOS/tasks.c ****                     }
 705:FreeRTOS/tasks.c ****                 #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */
 706:FreeRTOS/tasks.c **** 
 707:FreeRTOS/tasks.c ****                 prvInitialiseNewTask( pxTaskDefinition->pvTaskCode,
 708:FreeRTOS/tasks.c ****                                       pxTaskDefinition->pcName,
 709:FreeRTOS/tasks.c ****                                       ( uint32_t ) pxTaskDefinition->usStackDepth,
 710:FreeRTOS/tasks.c ****                                       pxTaskDefinition->pvParameters,
 711:FreeRTOS/tasks.c ****                                       pxTaskDefinition->uxPriority,
 712:FreeRTOS/tasks.c ****                                       pxCreatedTask, pxNewTCB,
 713:FreeRTOS/tasks.c ****                                       pxTaskDefinition->xRegions );
 714:FreeRTOS/tasks.c **** 
 715:FreeRTOS/tasks.c ****                 prvAddNewTaskToReadyList( pxNewTCB );
 716:FreeRTOS/tasks.c ****                 xReturn = pdPASS;
 717:FreeRTOS/tasks.c ****             }
 718:FreeRTOS/tasks.c ****         }
ARM GAS  /tmp/ccrgBt0i.s 			page 14


 719:FreeRTOS/tasks.c **** 
 720:FreeRTOS/tasks.c ****         return xReturn;
 721:FreeRTOS/tasks.c ****     }
 722:FreeRTOS/tasks.c **** 
 723:FreeRTOS/tasks.c **** #endif /* portUSING_MPU_WRAPPERS */
 724:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 725:FreeRTOS/tasks.c **** 
 726:FreeRTOS/tasks.c **** #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
 727:FreeRTOS/tasks.c **** 
 728:FreeRTOS/tasks.c ****     BaseType_t xTaskCreate( TaskFunction_t pxTaskCode,
 729:FreeRTOS/tasks.c ****                             const char * const pcName, /*lint !e971 Unqualified char types are allo
 730:FreeRTOS/tasks.c ****                             const configSTACK_DEPTH_TYPE usStackDepth,
 731:FreeRTOS/tasks.c ****                             void * const pvParameters,
 732:FreeRTOS/tasks.c ****                             UBaseType_t uxPriority,
 733:FreeRTOS/tasks.c ****                             TaskHandle_t * const pxCreatedTask )
 734:FreeRTOS/tasks.c ****     {
 735:FreeRTOS/tasks.c ****         TCB_t * pxNewTCB;
 736:FreeRTOS/tasks.c ****         BaseType_t xReturn;
 737:FreeRTOS/tasks.c **** 
 738:FreeRTOS/tasks.c ****         /* If the stack grows down then allocate the stack then the TCB so the stack
 739:FreeRTOS/tasks.c ****          * does not grow into the TCB.  Likewise if the stack grows up then allocate
 740:FreeRTOS/tasks.c ****          * the TCB then the stack. */
 741:FreeRTOS/tasks.c ****         #if ( portSTACK_GROWTH > 0 )
 742:FreeRTOS/tasks.c ****             {
 743:FreeRTOS/tasks.c ****                 /* Allocate space for the TCB.  Where the memory comes from depends on
 744:FreeRTOS/tasks.c ****                  * the implementation of the port malloc function and whether or not static
 745:FreeRTOS/tasks.c ****                  * allocation is being used. */
 746:FreeRTOS/tasks.c ****                 pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
 747:FreeRTOS/tasks.c **** 
 748:FreeRTOS/tasks.c ****                 if( pxNewTCB != NULL )
 749:FreeRTOS/tasks.c ****                 {
 750:FreeRTOS/tasks.c ****                     /* Allocate space for the stack used by the task being created.
 751:FreeRTOS/tasks.c ****                      * The base of the stack memory stored in the TCB so the task can
 752:FreeRTOS/tasks.c ****                      * be deleted later if required. */
 753:FreeRTOS/tasks.c ****                     pxNewTCB->pxStack = ( StackType_t * ) pvPortMallocStack( ( ( ( size_t ) usStack
 754:FreeRTOS/tasks.c **** 
 755:FreeRTOS/tasks.c ****                     if( pxNewTCB->pxStack == NULL )
 756:FreeRTOS/tasks.c ****                     {
 757:FreeRTOS/tasks.c ****                         /* Could not allocate the stack.  Delete the allocated TCB. */
 758:FreeRTOS/tasks.c ****                         vPortFree( pxNewTCB );
 759:FreeRTOS/tasks.c ****                         pxNewTCB = NULL;
 760:FreeRTOS/tasks.c ****                     }
 761:FreeRTOS/tasks.c ****                 }
 762:FreeRTOS/tasks.c ****             }
 763:FreeRTOS/tasks.c ****         #else /* portSTACK_GROWTH */
 764:FreeRTOS/tasks.c ****             {
 765:FreeRTOS/tasks.c ****                 StackType_t * pxStack;
 766:FreeRTOS/tasks.c **** 
 767:FreeRTOS/tasks.c ****                 /* Allocate space for the stack used by the task being created. */
 768:FreeRTOS/tasks.c ****                 pxStack = pvPortMallocStack( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) 
 769:FreeRTOS/tasks.c **** 
 770:FreeRTOS/tasks.c ****                 if( pxStack != NULL )
 771:FreeRTOS/tasks.c ****                 {
 772:FreeRTOS/tasks.c ****                     /* Allocate space for the TCB. */
 773:FreeRTOS/tasks.c ****                     pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 Al
 774:FreeRTOS/tasks.c **** 
 775:FreeRTOS/tasks.c ****                     if( pxNewTCB != NULL )
ARM GAS  /tmp/ccrgBt0i.s 			page 15


 776:FreeRTOS/tasks.c ****                     {
 777:FreeRTOS/tasks.c ****                         /* Store the stack location in the TCB. */
 778:FreeRTOS/tasks.c ****                         pxNewTCB->pxStack = pxStack;
 779:FreeRTOS/tasks.c ****                     }
 780:FreeRTOS/tasks.c ****                     else
 781:FreeRTOS/tasks.c ****                     {
 782:FreeRTOS/tasks.c ****                         /* The stack cannot be used as the TCB was not created.  Free
 783:FreeRTOS/tasks.c ****                          * it again. */
 784:FreeRTOS/tasks.c ****                         vPortFreeStack( pxStack );
 785:FreeRTOS/tasks.c ****                     }
 786:FreeRTOS/tasks.c ****                 }
 787:FreeRTOS/tasks.c ****                 else
 788:FreeRTOS/tasks.c ****                 {
 789:FreeRTOS/tasks.c ****                     pxNewTCB = NULL;
 790:FreeRTOS/tasks.c ****                 }
 791:FreeRTOS/tasks.c ****             }
 792:FreeRTOS/tasks.c ****         #endif /* portSTACK_GROWTH */
 793:FreeRTOS/tasks.c **** 
 794:FreeRTOS/tasks.c ****         if( pxNewTCB != NULL )
 795:FreeRTOS/tasks.c ****         {
 796:FreeRTOS/tasks.c ****             #if ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e9029 !e731 Macro has be
 797:FreeRTOS/tasks.c ****                 {
 798:FreeRTOS/tasks.c ****                     /* Tasks can be created statically or dynamically, so note this
 799:FreeRTOS/tasks.c ****                      * task was created dynamically in case it is later deleted. */
 800:FreeRTOS/tasks.c ****                     pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
 801:FreeRTOS/tasks.c ****                 }
 802:FreeRTOS/tasks.c ****             #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */
 803:FreeRTOS/tasks.c **** 
 804:FreeRTOS/tasks.c ****             prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPr
 805:FreeRTOS/tasks.c ****             prvAddNewTaskToReadyList( pxNewTCB );
 806:FreeRTOS/tasks.c ****             xReturn = pdPASS;
 807:FreeRTOS/tasks.c ****         }
 808:FreeRTOS/tasks.c ****         else
 809:FreeRTOS/tasks.c ****         {
 810:FreeRTOS/tasks.c ****             xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 811:FreeRTOS/tasks.c ****         }
 812:FreeRTOS/tasks.c **** 
 813:FreeRTOS/tasks.c ****         return xReturn;
 814:FreeRTOS/tasks.c ****     }
 815:FreeRTOS/tasks.c **** 
 816:FreeRTOS/tasks.c **** #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
 817:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 818:FreeRTOS/tasks.c **** 
 819:FreeRTOS/tasks.c **** static void prvInitialiseNewTask( TaskFunction_t pxTaskCode,
 820:FreeRTOS/tasks.c ****                                   const char * const pcName, /*lint !e971 Unqualified char types ar
 821:FreeRTOS/tasks.c ****                                   const uint32_t ulStackDepth,
 822:FreeRTOS/tasks.c ****                                   void * const pvParameters,
 823:FreeRTOS/tasks.c ****                                   UBaseType_t uxPriority,
 824:FreeRTOS/tasks.c ****                                   TaskHandle_t * const pxCreatedTask,
 825:FreeRTOS/tasks.c ****                                   TCB_t * pxNewTCB,
 826:FreeRTOS/tasks.c ****                                   const MemoryRegion_t * const xRegions )
 827:FreeRTOS/tasks.c **** {
 828:FreeRTOS/tasks.c ****     StackType_t * pxTopOfStack;
 829:FreeRTOS/tasks.c ****     UBaseType_t x;
 830:FreeRTOS/tasks.c **** 
 831:FreeRTOS/tasks.c ****     #if ( portUSING_MPU_WRAPPERS == 1 )
 832:FreeRTOS/tasks.c ****         /* Should the task be created in privileged mode? */
ARM GAS  /tmp/ccrgBt0i.s 			page 16


 833:FreeRTOS/tasks.c ****         BaseType_t xRunPrivileged;
 834:FreeRTOS/tasks.c **** 
 835:FreeRTOS/tasks.c ****         if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
 836:FreeRTOS/tasks.c ****         {
 837:FreeRTOS/tasks.c ****             xRunPrivileged = pdTRUE;
 838:FreeRTOS/tasks.c ****         }
 839:FreeRTOS/tasks.c ****         else
 840:FreeRTOS/tasks.c ****         {
 841:FreeRTOS/tasks.c ****             xRunPrivileged = pdFALSE;
 842:FreeRTOS/tasks.c ****         }
 843:FreeRTOS/tasks.c ****         uxPriority &= ~portPRIVILEGE_BIT;
 844:FreeRTOS/tasks.c ****     #endif /* portUSING_MPU_WRAPPERS == 1 */
 845:FreeRTOS/tasks.c **** 
 846:FreeRTOS/tasks.c ****     /* Avoid dependency on memset() if it is not required. */
 847:FreeRTOS/tasks.c ****     #if ( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )
 848:FreeRTOS/tasks.c ****         {
 849:FreeRTOS/tasks.c ****             /* Fill the stack with a known value to assist debugging. */
 850:FreeRTOS/tasks.c ****             ( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth
 851:FreeRTOS/tasks.c ****         }
 852:FreeRTOS/tasks.c ****     #endif /* tskSET_NEW_STACKS_TO_KNOWN_VALUE */
 853:FreeRTOS/tasks.c **** 
 854:FreeRTOS/tasks.c ****     /* Calculate the top of stack address.  This depends on whether the stack
 855:FreeRTOS/tasks.c ****      * grows from high memory to low (as per the 80x86) or vice versa.
 856:FreeRTOS/tasks.c ****      * portSTACK_GROWTH is used to make the result positive or negative as required
 857:FreeRTOS/tasks.c ****      * by the port. */
 858:FreeRTOS/tasks.c ****     #if ( portSTACK_GROWTH < 0 )
 859:FreeRTOS/tasks.c ****         {
 860:FreeRTOS/tasks.c ****             pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
 861:FreeRTOS/tasks.c ****             pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( 
 862:FreeRTOS/tasks.c **** 
 863:FreeRTOS/tasks.c ****             /* Check the alignment of the calculated top of stack is correct. */
 864:FreeRTOS/tasks.c ****             configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) po
 865:FreeRTOS/tasks.c **** 
 866:FreeRTOS/tasks.c ****             #if ( configRECORD_STACK_HIGH_ADDRESS == 1 )
 867:FreeRTOS/tasks.c ****                 {
 868:FreeRTOS/tasks.c ****                     /* Also record the stack's high address, which may assist
 869:FreeRTOS/tasks.c ****                      * debugging. */
 870:FreeRTOS/tasks.c ****                     pxNewTCB->pxEndOfStack = pxTopOfStack;
 871:FreeRTOS/tasks.c ****                 }
 872:FreeRTOS/tasks.c ****             #endif /* configRECORD_STACK_HIGH_ADDRESS */
 873:FreeRTOS/tasks.c ****         }
 874:FreeRTOS/tasks.c ****     #else /* portSTACK_GROWTH */
 875:FreeRTOS/tasks.c ****         {
 876:FreeRTOS/tasks.c ****             pxTopOfStack = pxNewTCB->pxStack;
 877:FreeRTOS/tasks.c **** 
 878:FreeRTOS/tasks.c ****             /* Check the alignment of the stack buffer is correct. */
 879:FreeRTOS/tasks.c ****             configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxNewTCB->pxStack & ( portPOINTER_SIZE_TYPE
 880:FreeRTOS/tasks.c **** 
 881:FreeRTOS/tasks.c ****             /* The other extreme of the stack space is required if stack checking is
 882:FreeRTOS/tasks.c ****              * performed. */
 883:FreeRTOS/tasks.c ****             pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
 884:FreeRTOS/tasks.c ****         }
 885:FreeRTOS/tasks.c ****     #endif /* portSTACK_GROWTH */
 886:FreeRTOS/tasks.c **** 
 887:FreeRTOS/tasks.c ****     /* Store the task name in the TCB. */
 888:FreeRTOS/tasks.c ****     if( pcName != NULL )
 889:FreeRTOS/tasks.c ****     {
ARM GAS  /tmp/ccrgBt0i.s 			page 17


 890:FreeRTOS/tasks.c ****         for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 891:FreeRTOS/tasks.c ****         {
 892:FreeRTOS/tasks.c ****             pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 893:FreeRTOS/tasks.c **** 
 894:FreeRTOS/tasks.c ****             /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
 895:FreeRTOS/tasks.c ****              * configMAX_TASK_NAME_LEN characters just in case the memory after the
 896:FreeRTOS/tasks.c ****              * string is not accessible (extremely unlikely). */
 897:FreeRTOS/tasks.c ****             if( pcName[ x ] == ( char ) 0x00 )
 898:FreeRTOS/tasks.c ****             {
 899:FreeRTOS/tasks.c ****                 break;
 900:FreeRTOS/tasks.c ****             }
 901:FreeRTOS/tasks.c ****             else
 902:FreeRTOS/tasks.c ****             {
 903:FreeRTOS/tasks.c ****                 mtCOVERAGE_TEST_MARKER();
 904:FreeRTOS/tasks.c ****             }
 905:FreeRTOS/tasks.c ****         }
 906:FreeRTOS/tasks.c **** 
 907:FreeRTOS/tasks.c ****         /* Ensure the name string is terminated in the case that the string length
 908:FreeRTOS/tasks.c ****          * was greater or equal to configMAX_TASK_NAME_LEN. */
 909:FreeRTOS/tasks.c ****         pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 910:FreeRTOS/tasks.c ****     }
 911:FreeRTOS/tasks.c ****     else
 912:FreeRTOS/tasks.c ****     {
 913:FreeRTOS/tasks.c ****         /* The task has not been given a name, so just ensure there is a NULL
 914:FreeRTOS/tasks.c ****          * terminator when it is read out. */
 915:FreeRTOS/tasks.c ****         pxNewTCB->pcTaskName[ 0 ] = 0x00;
 916:FreeRTOS/tasks.c ****     }
 917:FreeRTOS/tasks.c **** 
 918:FreeRTOS/tasks.c ****     /* This is used as an array index so must ensure it's not too large. */
 919:FreeRTOS/tasks.c ****     configASSERT( uxPriority < configMAX_PRIORITIES );
 920:FreeRTOS/tasks.c **** 
 921:FreeRTOS/tasks.c ****     if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 922:FreeRTOS/tasks.c ****     {
 923:FreeRTOS/tasks.c ****         uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 924:FreeRTOS/tasks.c ****     }
 925:FreeRTOS/tasks.c ****     else
 926:FreeRTOS/tasks.c ****     {
 927:FreeRTOS/tasks.c ****         mtCOVERAGE_TEST_MARKER();
 928:FreeRTOS/tasks.c ****     }
 929:FreeRTOS/tasks.c **** 
 930:FreeRTOS/tasks.c ****     pxNewTCB->uxPriority = uxPriority;
 931:FreeRTOS/tasks.c ****     #if ( configUSE_MUTEXES == 1 )
 932:FreeRTOS/tasks.c ****         {
 933:FreeRTOS/tasks.c ****             pxNewTCB->uxBasePriority = uxPriority;
 934:FreeRTOS/tasks.c ****             pxNewTCB->uxMutexesHeld = 0;
 935:FreeRTOS/tasks.c ****         }
 936:FreeRTOS/tasks.c ****     #endif /* configUSE_MUTEXES */
 937:FreeRTOS/tasks.c **** 
 938:FreeRTOS/tasks.c ****     vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 939:FreeRTOS/tasks.c ****     vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 940:FreeRTOS/tasks.c **** 
 941:FreeRTOS/tasks.c ****     /* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
 942:FreeRTOS/tasks.c ****      * back to  the containing TCB from a generic item in a list. */
 943:FreeRTOS/tasks.c ****     listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 944:FreeRTOS/tasks.c **** 
 945:FreeRTOS/tasks.c ****     /* Event lists are always in priority order. */
 946:FreeRTOS/tasks.c ****     listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - (
ARM GAS  /tmp/ccrgBt0i.s 			page 18


 947:FreeRTOS/tasks.c ****     listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 948:FreeRTOS/tasks.c **** 
 949:FreeRTOS/tasks.c ****     #if ( portCRITICAL_NESTING_IN_TCB == 1 )
 950:FreeRTOS/tasks.c ****         {
 951:FreeRTOS/tasks.c ****             pxNewTCB->uxCriticalNesting = ( UBaseType_t ) 0U;
 952:FreeRTOS/tasks.c ****         }
 953:FreeRTOS/tasks.c ****     #endif /* portCRITICAL_NESTING_IN_TCB */
 954:FreeRTOS/tasks.c **** 
 955:FreeRTOS/tasks.c ****     #if ( configUSE_APPLICATION_TASK_TAG == 1 )
 956:FreeRTOS/tasks.c ****         {
 957:FreeRTOS/tasks.c ****             pxNewTCB->pxTaskTag = NULL;
 958:FreeRTOS/tasks.c ****         }
 959:FreeRTOS/tasks.c ****     #endif /* configUSE_APPLICATION_TASK_TAG */
 960:FreeRTOS/tasks.c **** 
 961:FreeRTOS/tasks.c ****     #if ( configGENERATE_RUN_TIME_STATS == 1 )
 962:FreeRTOS/tasks.c ****         {
 963:FreeRTOS/tasks.c ****             pxNewTCB->ulRunTimeCounter = ( configRUN_TIME_COUNTER_TYPE ) 0;
 964:FreeRTOS/tasks.c ****         }
 965:FreeRTOS/tasks.c ****     #endif /* configGENERATE_RUN_TIME_STATS */
 966:FreeRTOS/tasks.c **** 
 967:FreeRTOS/tasks.c ****     #if ( portUSING_MPU_WRAPPERS == 1 )
 968:FreeRTOS/tasks.c ****         {
 969:FreeRTOS/tasks.c ****             vPortStoreTaskMPUSettings( &( pxNewTCB->xMPUSettings ), xRegions, pxNewTCB->pxStack, ul
 970:FreeRTOS/tasks.c ****         }
 971:FreeRTOS/tasks.c ****     #else
 972:FreeRTOS/tasks.c ****         {
 973:FreeRTOS/tasks.c ****             /* Avoid compiler warning about unreferenced parameter. */
 974:FreeRTOS/tasks.c ****             ( void ) xRegions;
 975:FreeRTOS/tasks.c ****         }
 976:FreeRTOS/tasks.c ****     #endif
 977:FreeRTOS/tasks.c **** 
 978:FreeRTOS/tasks.c ****     #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
 979:FreeRTOS/tasks.c ****         {
 980:FreeRTOS/tasks.c ****             memset( ( void * ) &( pxNewTCB->pvThreadLocalStoragePointers[ 0 ] ), 0x00, sizeof( pxNe
 981:FreeRTOS/tasks.c ****         }
 982:FreeRTOS/tasks.c ****     #endif
 983:FreeRTOS/tasks.c **** 
 984:FreeRTOS/tasks.c ****     #if ( configUSE_TASK_NOTIFICATIONS == 1 )
 985:FreeRTOS/tasks.c ****         {
 986:FreeRTOS/tasks.c ****             memset( ( void * ) &( pxNewTCB->ulNotifiedValue[ 0 ] ), 0x00, sizeof( pxNewTCB->ulNotif
 987:FreeRTOS/tasks.c ****             memset( ( void * ) &( pxNewTCB->ucNotifyState[ 0 ] ), 0x00, sizeof( pxNewTCB->ucNotifyS
 988:FreeRTOS/tasks.c ****         }
 989:FreeRTOS/tasks.c ****     #endif
 990:FreeRTOS/tasks.c **** 
 991:FreeRTOS/tasks.c ****     #if ( configUSE_NEWLIB_REENTRANT == 1 )
 992:FreeRTOS/tasks.c ****         {
 993:FreeRTOS/tasks.c ****             /* Initialise this task's Newlib reent structure.
 994:FreeRTOS/tasks.c ****              * See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html
 995:FreeRTOS/tasks.c ****              * for additional information. */
 996:FreeRTOS/tasks.c ****             _REENT_INIT_PTR( ( &( pxNewTCB->xNewLib_reent ) ) );
 997:FreeRTOS/tasks.c ****         }
 998:FreeRTOS/tasks.c ****     #endif
 999:FreeRTOS/tasks.c **** 
1000:FreeRTOS/tasks.c ****     #if ( INCLUDE_xTaskAbortDelay == 1 )
1001:FreeRTOS/tasks.c ****         {
1002:FreeRTOS/tasks.c ****             pxNewTCB->ucDelayAborted = pdFALSE;
1003:FreeRTOS/tasks.c ****         }
ARM GAS  /tmp/ccrgBt0i.s 			page 19


1004:FreeRTOS/tasks.c ****     #endif
1005:FreeRTOS/tasks.c **** 
1006:FreeRTOS/tasks.c ****     /* Initialize the TCB stack to look as if the task was already running,
1007:FreeRTOS/tasks.c ****      * but had been interrupted by the scheduler.  The return address is set
1008:FreeRTOS/tasks.c ****      * to the start of the task function. Once the stack has been initialised
1009:FreeRTOS/tasks.c ****      * the top of stack variable is updated. */
1010:FreeRTOS/tasks.c ****     #if ( portUSING_MPU_WRAPPERS == 1 )
1011:FreeRTOS/tasks.c ****         {
1012:FreeRTOS/tasks.c ****             /* If the port has capability to detect stack overflow,
1013:FreeRTOS/tasks.c ****              * pass the stack end address to the stack initialization
1014:FreeRTOS/tasks.c ****              * function as well. */
1015:FreeRTOS/tasks.c ****             #if ( portHAS_STACK_OVERFLOW_CHECKING == 1 )
1016:FreeRTOS/tasks.c ****                 {
1017:FreeRTOS/tasks.c ****                     #if ( portSTACK_GROWTH < 0 )
1018:FreeRTOS/tasks.c ****                         {
1019:FreeRTOS/tasks.c ****                             pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxNewTCB-
1020:FreeRTOS/tasks.c ****                         }
1021:FreeRTOS/tasks.c ****                     #else /* portSTACK_GROWTH */
1022:FreeRTOS/tasks.c ****                         {
1023:FreeRTOS/tasks.c ****                             pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxNewTCB-
1024:FreeRTOS/tasks.c ****                         }
1025:FreeRTOS/tasks.c ****                     #endif /* portSTACK_GROWTH */
1026:FreeRTOS/tasks.c ****                 }
1027:FreeRTOS/tasks.c ****             #else /* portHAS_STACK_OVERFLOW_CHECKING */
1028:FreeRTOS/tasks.c ****                 {
1029:FreeRTOS/tasks.c ****                     pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvPar
1030:FreeRTOS/tasks.c ****                 }
1031:FreeRTOS/tasks.c ****             #endif /* portHAS_STACK_OVERFLOW_CHECKING */
1032:FreeRTOS/tasks.c ****         }
1033:FreeRTOS/tasks.c ****     #else /* portUSING_MPU_WRAPPERS */
1034:FreeRTOS/tasks.c ****         {
1035:FreeRTOS/tasks.c ****             /* If the port has capability to detect stack overflow,
1036:FreeRTOS/tasks.c ****              * pass the stack end address to the stack initialization
1037:FreeRTOS/tasks.c ****              * function as well. */
1038:FreeRTOS/tasks.c ****             #if ( portHAS_STACK_OVERFLOW_CHECKING == 1 )
1039:FreeRTOS/tasks.c ****                 {
1040:FreeRTOS/tasks.c ****                     #if ( portSTACK_GROWTH < 0 )
1041:FreeRTOS/tasks.c ****                         {
1042:FreeRTOS/tasks.c ****                             pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxNewTCB-
1043:FreeRTOS/tasks.c ****                         }
1044:FreeRTOS/tasks.c ****                     #else /* portSTACK_GROWTH */
1045:FreeRTOS/tasks.c ****                         {
1046:FreeRTOS/tasks.c ****                             pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxNewTCB-
1047:FreeRTOS/tasks.c ****                         }
1048:FreeRTOS/tasks.c ****                     #endif /* portSTACK_GROWTH */
1049:FreeRTOS/tasks.c ****                 }
1050:FreeRTOS/tasks.c ****             #else /* portHAS_STACK_OVERFLOW_CHECKING */
1051:FreeRTOS/tasks.c ****                 {
1052:FreeRTOS/tasks.c ****                     pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvPar
1053:FreeRTOS/tasks.c ****                 }
1054:FreeRTOS/tasks.c ****             #endif /* portHAS_STACK_OVERFLOW_CHECKING */
1055:FreeRTOS/tasks.c ****         }
1056:FreeRTOS/tasks.c ****     #endif /* portUSING_MPU_WRAPPERS */
1057:FreeRTOS/tasks.c **** 
1058:FreeRTOS/tasks.c ****     if( pxCreatedTask != NULL )
1059:FreeRTOS/tasks.c ****     {
1060:FreeRTOS/tasks.c ****         /* Pass the handle out in an anonymous way.  The handle can be used to
ARM GAS  /tmp/ccrgBt0i.s 			page 20


1061:FreeRTOS/tasks.c ****          * change the created task's priority, delete the created task, etc.*/
1062:FreeRTOS/tasks.c ****         *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
1063:FreeRTOS/tasks.c ****     }
1064:FreeRTOS/tasks.c ****     else
1065:FreeRTOS/tasks.c ****     {
1066:FreeRTOS/tasks.c ****         mtCOVERAGE_TEST_MARKER();
1067:FreeRTOS/tasks.c ****     }
1068:FreeRTOS/tasks.c **** }
1069:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1070:FreeRTOS/tasks.c **** 
1071:FreeRTOS/tasks.c **** static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB )
1072:FreeRTOS/tasks.c **** {
1073:FreeRTOS/tasks.c ****     /* Ensure interrupts don't access the task lists while the lists are being
1074:FreeRTOS/tasks.c ****      * updated. */
1075:FreeRTOS/tasks.c ****     taskENTER_CRITICAL();
1076:FreeRTOS/tasks.c ****     {
1077:FreeRTOS/tasks.c ****         uxCurrentNumberOfTasks++;
1078:FreeRTOS/tasks.c **** 
1079:FreeRTOS/tasks.c ****         if( pxCurrentTCB == NULL )
1080:FreeRTOS/tasks.c ****         {
1081:FreeRTOS/tasks.c ****             /* There are no other tasks, or all the other tasks are in
1082:FreeRTOS/tasks.c ****              * the suspended state - make this the current task. */
1083:FreeRTOS/tasks.c ****             pxCurrentTCB = pxNewTCB;
1084:FreeRTOS/tasks.c **** 
1085:FreeRTOS/tasks.c ****             if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
1086:FreeRTOS/tasks.c ****             {
1087:FreeRTOS/tasks.c ****                 /* This is the first task to be created so do the preliminary
1088:FreeRTOS/tasks.c ****                  * initialisation required.  We will not recover if this call
1089:FreeRTOS/tasks.c ****                  * fails, but we will report the failure. */
1090:FreeRTOS/tasks.c ****                 prvInitialiseTaskLists();
1091:FreeRTOS/tasks.c ****             }
1092:FreeRTOS/tasks.c ****             else
1093:FreeRTOS/tasks.c ****             {
1094:FreeRTOS/tasks.c ****                 mtCOVERAGE_TEST_MARKER();
1095:FreeRTOS/tasks.c ****             }
1096:FreeRTOS/tasks.c ****         }
1097:FreeRTOS/tasks.c ****         else
1098:FreeRTOS/tasks.c ****         {
1099:FreeRTOS/tasks.c ****             /* If the scheduler is not already running, make this task the
1100:FreeRTOS/tasks.c ****              * current task if it is the highest priority task to be created
1101:FreeRTOS/tasks.c ****              * so far. */
1102:FreeRTOS/tasks.c ****             if( xSchedulerRunning == pdFALSE )
1103:FreeRTOS/tasks.c ****             {
1104:FreeRTOS/tasks.c ****                 if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
1105:FreeRTOS/tasks.c ****                 {
1106:FreeRTOS/tasks.c ****                     pxCurrentTCB = pxNewTCB;
1107:FreeRTOS/tasks.c ****                 }
1108:FreeRTOS/tasks.c ****                 else
1109:FreeRTOS/tasks.c ****                 {
1110:FreeRTOS/tasks.c ****                     mtCOVERAGE_TEST_MARKER();
1111:FreeRTOS/tasks.c ****                 }
1112:FreeRTOS/tasks.c ****             }
1113:FreeRTOS/tasks.c ****             else
1114:FreeRTOS/tasks.c ****             {
1115:FreeRTOS/tasks.c ****                 mtCOVERAGE_TEST_MARKER();
1116:FreeRTOS/tasks.c ****             }
1117:FreeRTOS/tasks.c ****         }
ARM GAS  /tmp/ccrgBt0i.s 			page 21


1118:FreeRTOS/tasks.c **** 
1119:FreeRTOS/tasks.c ****         uxTaskNumber++;
1120:FreeRTOS/tasks.c **** 
1121:FreeRTOS/tasks.c ****         #if ( configUSE_TRACE_FACILITY == 1 )
1122:FreeRTOS/tasks.c ****             {
1123:FreeRTOS/tasks.c ****                 /* Add a counter into the TCB for tracing only. */
1124:FreeRTOS/tasks.c ****                 pxNewTCB->uxTCBNumber = uxTaskNumber;
1125:FreeRTOS/tasks.c ****             }
1126:FreeRTOS/tasks.c ****         #endif /* configUSE_TRACE_FACILITY */
1127:FreeRTOS/tasks.c ****         traceTASK_CREATE( pxNewTCB );
1128:FreeRTOS/tasks.c **** 
1129:FreeRTOS/tasks.c ****         prvAddTaskToReadyList( pxNewTCB );
1130:FreeRTOS/tasks.c **** 
1131:FreeRTOS/tasks.c ****         portSETUP_TCB( pxNewTCB );
1132:FreeRTOS/tasks.c ****     }
1133:FreeRTOS/tasks.c ****     taskEXIT_CRITICAL();
1134:FreeRTOS/tasks.c **** 
1135:FreeRTOS/tasks.c ****     if( xSchedulerRunning != pdFALSE )
1136:FreeRTOS/tasks.c ****     {
1137:FreeRTOS/tasks.c ****         /* If the created task is of a higher priority than the current task
1138:FreeRTOS/tasks.c ****          * then it should run now. */
1139:FreeRTOS/tasks.c ****         if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
1140:FreeRTOS/tasks.c ****         {
1141:FreeRTOS/tasks.c ****             taskYIELD_IF_USING_PREEMPTION();
1142:FreeRTOS/tasks.c ****         }
1143:FreeRTOS/tasks.c ****         else
1144:FreeRTOS/tasks.c ****         {
1145:FreeRTOS/tasks.c ****             mtCOVERAGE_TEST_MARKER();
1146:FreeRTOS/tasks.c ****         }
1147:FreeRTOS/tasks.c ****     }
1148:FreeRTOS/tasks.c ****     else
1149:FreeRTOS/tasks.c ****     {
1150:FreeRTOS/tasks.c ****         mtCOVERAGE_TEST_MARKER();
1151:FreeRTOS/tasks.c ****     }
1152:FreeRTOS/tasks.c **** }
1153:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1154:FreeRTOS/tasks.c **** 
1155:FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
1156:FreeRTOS/tasks.c **** 
1157:FreeRTOS/tasks.c ****     void vTaskDelete( TaskHandle_t xTaskToDelete )
1158:FreeRTOS/tasks.c ****     {
1159:FreeRTOS/tasks.c ****         TCB_t * pxTCB;
1160:FreeRTOS/tasks.c **** 
1161:FreeRTOS/tasks.c ****         taskENTER_CRITICAL();
1162:FreeRTOS/tasks.c ****         {
1163:FreeRTOS/tasks.c ****             /* If null is passed in here then it is the calling task that is
1164:FreeRTOS/tasks.c ****              * being deleted. */
1165:FreeRTOS/tasks.c ****             pxTCB = prvGetTCBFromHandle( xTaskToDelete );
1166:FreeRTOS/tasks.c **** 
1167:FreeRTOS/tasks.c ****             /* Remove task from the ready/delayed list. */
1168:FreeRTOS/tasks.c ****             if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
1169:FreeRTOS/tasks.c ****             {
1170:FreeRTOS/tasks.c ****                 taskRESET_READY_PRIORITY( pxTCB->uxPriority );
1171:FreeRTOS/tasks.c ****             }
1172:FreeRTOS/tasks.c ****             else
1173:FreeRTOS/tasks.c ****             {
1174:FreeRTOS/tasks.c ****                 mtCOVERAGE_TEST_MARKER();
ARM GAS  /tmp/ccrgBt0i.s 			page 22


1175:FreeRTOS/tasks.c ****             }
1176:FreeRTOS/tasks.c **** 
1177:FreeRTOS/tasks.c ****             /* Is the task waiting on an event also? */
1178:FreeRTOS/tasks.c ****             if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
1179:FreeRTOS/tasks.c ****             {
1180:FreeRTOS/tasks.c ****                 ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
1181:FreeRTOS/tasks.c ****             }
1182:FreeRTOS/tasks.c ****             else
1183:FreeRTOS/tasks.c ****             {
1184:FreeRTOS/tasks.c ****                 mtCOVERAGE_TEST_MARKER();
1185:FreeRTOS/tasks.c ****             }
1186:FreeRTOS/tasks.c **** 
1187:FreeRTOS/tasks.c ****             /* Increment the uxTaskNumber also so kernel aware debuggers can
1188:FreeRTOS/tasks.c ****              * detect that the task lists need re-generating.  This is done before
1189:FreeRTOS/tasks.c ****              * portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
1190:FreeRTOS/tasks.c ****              * not return. */
1191:FreeRTOS/tasks.c ****             uxTaskNumber++;
1192:FreeRTOS/tasks.c **** 
1193:FreeRTOS/tasks.c ****             if( pxTCB == pxCurrentTCB )
1194:FreeRTOS/tasks.c ****             {
1195:FreeRTOS/tasks.c ****                 /* A task is deleting itself.  This cannot complete within the
1196:FreeRTOS/tasks.c ****                  * task itself, as a context switch to another task is required.
1197:FreeRTOS/tasks.c ****                  * Place the task in the termination list.  The idle task will
1198:FreeRTOS/tasks.c ****                  * check the termination list and free up any memory allocated by
1199:FreeRTOS/tasks.c ****                  * the scheduler for the TCB and stack of the deleted task. */
1200:FreeRTOS/tasks.c ****                 vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
1201:FreeRTOS/tasks.c **** 
1202:FreeRTOS/tasks.c ****                 /* Increment the ucTasksDeleted variable so the idle task knows
1203:FreeRTOS/tasks.c ****                  * there is a task that has been deleted and that it should therefore
1204:FreeRTOS/tasks.c ****                  * check the xTasksWaitingTermination list. */
1205:FreeRTOS/tasks.c ****                 ++uxDeletedTasksWaitingCleanUp;
1206:FreeRTOS/tasks.c **** 
1207:FreeRTOS/tasks.c ****                 /* Call the delete hook before portPRE_TASK_DELETE_HOOK() as
1208:FreeRTOS/tasks.c ****                  * portPRE_TASK_DELETE_HOOK() does not return in the Win32 port. */
1209:FreeRTOS/tasks.c ****                 traceTASK_DELETE( pxTCB );
1210:FreeRTOS/tasks.c **** 
1211:FreeRTOS/tasks.c ****                 /* The pre-delete hook is primarily for the Windows simulator,
1212:FreeRTOS/tasks.c ****                  * in which Windows specific clean up operations are performed,
1213:FreeRTOS/tasks.c ****                  * after which it is not possible to yield away from this task -
1214:FreeRTOS/tasks.c ****                  * hence xYieldPending is used to latch that a context switch is
1215:FreeRTOS/tasks.c ****                  * required. */
1216:FreeRTOS/tasks.c ****                 portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
1217:FreeRTOS/tasks.c ****             }
1218:FreeRTOS/tasks.c ****             else
1219:FreeRTOS/tasks.c ****             {
1220:FreeRTOS/tasks.c ****                 --uxCurrentNumberOfTasks;
1221:FreeRTOS/tasks.c ****                 traceTASK_DELETE( pxTCB );
1222:FreeRTOS/tasks.c **** 
1223:FreeRTOS/tasks.c ****                 /* Reset the next expected unblock time in case it referred to
1224:FreeRTOS/tasks.c ****                  * the task that has just been deleted. */
1225:FreeRTOS/tasks.c ****                 prvResetNextTaskUnblockTime();
1226:FreeRTOS/tasks.c ****             }
1227:FreeRTOS/tasks.c ****         }
1228:FreeRTOS/tasks.c ****         taskEXIT_CRITICAL();
1229:FreeRTOS/tasks.c **** 
1230:FreeRTOS/tasks.c ****         /* If the task is not deleting itself, call prvDeleteTCB from outside of
1231:FreeRTOS/tasks.c ****          * critical section. If a task deletes itself, prvDeleteTCB is called
ARM GAS  /tmp/ccrgBt0i.s 			page 23


1232:FreeRTOS/tasks.c ****          * from prvCheckTasksWaitingTermination which is called from Idle task. */
1233:FreeRTOS/tasks.c ****         if( pxTCB != pxCurrentTCB )
1234:FreeRTOS/tasks.c ****         {
1235:FreeRTOS/tasks.c ****             prvDeleteTCB( pxTCB );
1236:FreeRTOS/tasks.c ****         }
1237:FreeRTOS/tasks.c **** 
1238:FreeRTOS/tasks.c ****         /* Force a reschedule if it is the currently running task that has just
1239:FreeRTOS/tasks.c ****          * been deleted. */
1240:FreeRTOS/tasks.c ****         if( xSchedulerRunning != pdFALSE )
1241:FreeRTOS/tasks.c ****         {
1242:FreeRTOS/tasks.c ****             if( pxTCB == pxCurrentTCB )
1243:FreeRTOS/tasks.c ****             {
1244:FreeRTOS/tasks.c ****                 configASSERT( uxSchedulerSuspended == 0 );
1245:FreeRTOS/tasks.c ****                 portYIELD_WITHIN_API();
1246:FreeRTOS/tasks.c ****             }
1247:FreeRTOS/tasks.c ****             else
1248:FreeRTOS/tasks.c ****             {
1249:FreeRTOS/tasks.c ****                 mtCOVERAGE_TEST_MARKER();
1250:FreeRTOS/tasks.c ****             }
1251:FreeRTOS/tasks.c ****         }
1252:FreeRTOS/tasks.c ****     }
1253:FreeRTOS/tasks.c **** 
1254:FreeRTOS/tasks.c **** #endif /* INCLUDE_vTaskDelete */
1255:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1256:FreeRTOS/tasks.c **** 
1257:FreeRTOS/tasks.c **** #if ( INCLUDE_xTaskDelayUntil == 1 )
1258:FreeRTOS/tasks.c **** 
1259:FreeRTOS/tasks.c ****     BaseType_t xTaskDelayUntil( TickType_t * const pxPreviousWakeTime,
1260:FreeRTOS/tasks.c ****                                 const TickType_t xTimeIncrement )
1261:FreeRTOS/tasks.c ****     {
1262:FreeRTOS/tasks.c ****         TickType_t xTimeToWake;
1263:FreeRTOS/tasks.c ****         BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
1264:FreeRTOS/tasks.c **** 
1265:FreeRTOS/tasks.c ****         configASSERT( pxPreviousWakeTime );
1266:FreeRTOS/tasks.c ****         configASSERT( ( xTimeIncrement > 0U ) );
1267:FreeRTOS/tasks.c ****         configASSERT( uxSchedulerSuspended == 0 );
1268:FreeRTOS/tasks.c **** 
1269:FreeRTOS/tasks.c ****         vTaskSuspendAll();
1270:FreeRTOS/tasks.c ****         {
1271:FreeRTOS/tasks.c ****             /* Minor optimisation.  The tick count cannot change in this
1272:FreeRTOS/tasks.c ****              * block. */
1273:FreeRTOS/tasks.c ****             const TickType_t xConstTickCount = xTickCount;
1274:FreeRTOS/tasks.c **** 
1275:FreeRTOS/tasks.c ****             /* Generate the tick time at which the task wants to wake. */
1276:FreeRTOS/tasks.c ****             xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
1277:FreeRTOS/tasks.c **** 
1278:FreeRTOS/tasks.c ****             if( xConstTickCount < *pxPreviousWakeTime )
1279:FreeRTOS/tasks.c ****             {
1280:FreeRTOS/tasks.c ****                 /* The tick count has overflowed since this function was
1281:FreeRTOS/tasks.c ****                  * lasted called.  In this case the only time we should ever
1282:FreeRTOS/tasks.c ****                  * actually delay is if the wake time has also  overflowed,
1283:FreeRTOS/tasks.c ****                  * and the wake time is greater than the tick time.  When this
1284:FreeRTOS/tasks.c ****                  * is the case it is as if neither time had overflowed. */
1285:FreeRTOS/tasks.c ****                 if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
1286:FreeRTOS/tasks.c ****                 {
1287:FreeRTOS/tasks.c ****                     xShouldDelay = pdTRUE;
1288:FreeRTOS/tasks.c ****                 }
ARM GAS  /tmp/ccrgBt0i.s 			page 24


1289:FreeRTOS/tasks.c ****                 else
1290:FreeRTOS/tasks.c ****                 {
1291:FreeRTOS/tasks.c ****                     mtCOVERAGE_TEST_MARKER();
1292:FreeRTOS/tasks.c ****                 }
1293:FreeRTOS/tasks.c ****             }
1294:FreeRTOS/tasks.c ****             else
1295:FreeRTOS/tasks.c ****             {
1296:FreeRTOS/tasks.c ****                 /* The tick time has not overflowed.  In this case we will
1297:FreeRTOS/tasks.c ****                  * delay if either the wake time has overflowed, and/or the
1298:FreeRTOS/tasks.c ****                  * tick time is less than the wake time. */
1299:FreeRTOS/tasks.c ****                 if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
1300:FreeRTOS/tasks.c ****                 {
1301:FreeRTOS/tasks.c ****                     xShouldDelay = pdTRUE;
1302:FreeRTOS/tasks.c ****                 }
1303:FreeRTOS/tasks.c ****                 else
1304:FreeRTOS/tasks.c ****                 {
1305:FreeRTOS/tasks.c ****                     mtCOVERAGE_TEST_MARKER();
1306:FreeRTOS/tasks.c ****                 }
1307:FreeRTOS/tasks.c ****             }
1308:FreeRTOS/tasks.c **** 
1309:FreeRTOS/tasks.c ****             /* Update the wake time ready for the next call. */
1310:FreeRTOS/tasks.c ****             *pxPreviousWakeTime = xTimeToWake;
1311:FreeRTOS/tasks.c **** 
1312:FreeRTOS/tasks.c ****             if( xShouldDelay != pdFALSE )
1313:FreeRTOS/tasks.c ****             {
1314:FreeRTOS/tasks.c ****                 traceTASK_DELAY_UNTIL( xTimeToWake );
1315:FreeRTOS/tasks.c **** 
1316:FreeRTOS/tasks.c ****                 /* prvAddCurrentTaskToDelayedList() needs the block time, not
1317:FreeRTOS/tasks.c ****                  * the time to wake, so subtract the current tick count. */
1318:FreeRTOS/tasks.c ****                 prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
1319:FreeRTOS/tasks.c ****             }
1320:FreeRTOS/tasks.c ****             else
1321:FreeRTOS/tasks.c ****             {
1322:FreeRTOS/tasks.c ****                 mtCOVERAGE_TEST_MARKER();
1323:FreeRTOS/tasks.c ****             }
1324:FreeRTOS/tasks.c ****         }
1325:FreeRTOS/tasks.c ****         xAlreadyYielded = xTaskResumeAll();
1326:FreeRTOS/tasks.c **** 
1327:FreeRTOS/tasks.c ****         /* Force a reschedule if xTaskResumeAll has not already done so, we may
1328:FreeRTOS/tasks.c ****          * have put ourselves to sleep. */
1329:FreeRTOS/tasks.c ****         if( xAlreadyYielded == pdFALSE )
1330:FreeRTOS/tasks.c ****         {
1331:FreeRTOS/tasks.c ****             portYIELD_WITHIN_API();
1332:FreeRTOS/tasks.c ****         }
1333:FreeRTOS/tasks.c ****         else
1334:FreeRTOS/tasks.c ****         {
1335:FreeRTOS/tasks.c ****             mtCOVERAGE_TEST_MARKER();
1336:FreeRTOS/tasks.c ****         }
1337:FreeRTOS/tasks.c **** 
1338:FreeRTOS/tasks.c ****         return xShouldDelay;
1339:FreeRTOS/tasks.c ****     }
1340:FreeRTOS/tasks.c **** 
1341:FreeRTOS/tasks.c **** #endif /* INCLUDE_xTaskDelayUntil */
1342:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1343:FreeRTOS/tasks.c **** 
1344:FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskDelay == 1 )
1345:FreeRTOS/tasks.c **** 
ARM GAS  /tmp/ccrgBt0i.s 			page 25


1346:FreeRTOS/tasks.c ****     void vTaskDelay( const TickType_t xTicksToDelay )
1347:FreeRTOS/tasks.c ****     {
1348:FreeRTOS/tasks.c ****         BaseType_t xAlreadyYielded = pdFALSE;
1349:FreeRTOS/tasks.c **** 
1350:FreeRTOS/tasks.c ****         /* A delay time of zero just forces a reschedule. */
1351:FreeRTOS/tasks.c ****         if( xTicksToDelay > ( TickType_t ) 0U )
1352:FreeRTOS/tasks.c ****         {
1353:FreeRTOS/tasks.c ****             configASSERT( uxSchedulerSuspended == 0 );
1354:FreeRTOS/tasks.c ****             vTaskSuspendAll();
1355:FreeRTOS/tasks.c ****             {
1356:FreeRTOS/tasks.c ****                 traceTASK_DELAY();
1357:FreeRTOS/tasks.c **** 
1358:FreeRTOS/tasks.c ****                 /* A task that is removed from the event list while the
1359:FreeRTOS/tasks.c ****                  * scheduler is suspended will not get placed in the ready
1360:FreeRTOS/tasks.c ****                  * list or removed from the blocked list until the scheduler
1361:FreeRTOS/tasks.c ****                  * is resumed.
1362:FreeRTOS/tasks.c ****                  *
1363:FreeRTOS/tasks.c ****                  * This task cannot be in an event list as it is the currently
1364:FreeRTOS/tasks.c ****                  * executing task. */
1365:FreeRTOS/tasks.c ****                 prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
1366:FreeRTOS/tasks.c ****             }
1367:FreeRTOS/tasks.c ****             xAlreadyYielded = xTaskResumeAll();
1368:FreeRTOS/tasks.c ****         }
1369:FreeRTOS/tasks.c ****         else
1370:FreeRTOS/tasks.c ****         {
1371:FreeRTOS/tasks.c ****             mtCOVERAGE_TEST_MARKER();
1372:FreeRTOS/tasks.c ****         }
1373:FreeRTOS/tasks.c **** 
1374:FreeRTOS/tasks.c ****         /* Force a reschedule if xTaskResumeAll has not already done so, we may
1375:FreeRTOS/tasks.c ****          * have put ourselves to sleep. */
1376:FreeRTOS/tasks.c ****         if( xAlreadyYielded == pdFALSE )
1377:FreeRTOS/tasks.c ****         {
1378:FreeRTOS/tasks.c ****             portYIELD_WITHIN_API();
1379:FreeRTOS/tasks.c ****         }
1380:FreeRTOS/tasks.c ****         else
1381:FreeRTOS/tasks.c ****         {
1382:FreeRTOS/tasks.c ****             mtCOVERAGE_TEST_MARKER();
1383:FreeRTOS/tasks.c ****         }
1384:FreeRTOS/tasks.c ****     }
1385:FreeRTOS/tasks.c **** 
1386:FreeRTOS/tasks.c **** #endif /* INCLUDE_vTaskDelay */
1387:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1388:FreeRTOS/tasks.c **** 
1389:FreeRTOS/tasks.c **** #if ( ( INCLUDE_eTaskGetState == 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_xTaskAbortDe
1390:FreeRTOS/tasks.c **** 
1391:FreeRTOS/tasks.c ****     eTaskState eTaskGetState( TaskHandle_t xTask )
1392:FreeRTOS/tasks.c ****     {
1393:FreeRTOS/tasks.c ****         eTaskState eReturn;
1394:FreeRTOS/tasks.c ****         List_t const * pxStateList, * pxDelayedList, * pxOverflowedDelayedList;
1395:FreeRTOS/tasks.c ****         const TCB_t * const pxTCB = xTask;
1396:FreeRTOS/tasks.c **** 
1397:FreeRTOS/tasks.c ****         configASSERT( pxTCB );
1398:FreeRTOS/tasks.c **** 
1399:FreeRTOS/tasks.c ****         if( pxTCB == pxCurrentTCB )
1400:FreeRTOS/tasks.c ****         {
1401:FreeRTOS/tasks.c ****             /* The task calling this function is querying its own state. */
1402:FreeRTOS/tasks.c ****             eReturn = eRunning;
ARM GAS  /tmp/ccrgBt0i.s 			page 26


1403:FreeRTOS/tasks.c ****         }
1404:FreeRTOS/tasks.c ****         else
1405:FreeRTOS/tasks.c ****         {
1406:FreeRTOS/tasks.c ****             taskENTER_CRITICAL();
1407:FreeRTOS/tasks.c ****             {
1408:FreeRTOS/tasks.c ****                 pxStateList = listLIST_ITEM_CONTAINER( &( pxTCB->xStateListItem ) );
1409:FreeRTOS/tasks.c ****                 pxDelayedList = pxDelayedTaskList;
1410:FreeRTOS/tasks.c ****                 pxOverflowedDelayedList = pxOverflowDelayedTaskList;
1411:FreeRTOS/tasks.c ****             }
1412:FreeRTOS/tasks.c ****             taskEXIT_CRITICAL();
1413:FreeRTOS/tasks.c **** 
1414:FreeRTOS/tasks.c ****             if( ( pxStateList == pxDelayedList ) || ( pxStateList == pxOverflowedDelayedList ) )
1415:FreeRTOS/tasks.c ****             {
1416:FreeRTOS/tasks.c ****                 /* The task being queried is referenced from one of the Blocked
1417:FreeRTOS/tasks.c ****                  * lists. */
1418:FreeRTOS/tasks.c ****                 eReturn = eBlocked;
1419:FreeRTOS/tasks.c ****             }
1420:FreeRTOS/tasks.c **** 
1421:FreeRTOS/tasks.c ****             #if ( INCLUDE_vTaskSuspend == 1 )
1422:FreeRTOS/tasks.c ****                 else if( pxStateList == &xSuspendedTaskList )
1423:FreeRTOS/tasks.c ****                 {
1424:FreeRTOS/tasks.c ****                     /* The task being queried is referenced from the suspended
1425:FreeRTOS/tasks.c ****                      * list.  Is it genuinely suspended or is it blocked
1426:FreeRTOS/tasks.c ****                      * indefinitely? */
1427:FreeRTOS/tasks.c ****                     if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
1428:FreeRTOS/tasks.c ****                     {
1429:FreeRTOS/tasks.c ****                         #if ( configUSE_TASK_NOTIFICATIONS == 1 )
1430:FreeRTOS/tasks.c ****                             {
1431:FreeRTOS/tasks.c ****                                 BaseType_t x;
1432:FreeRTOS/tasks.c **** 
1433:FreeRTOS/tasks.c ****                                 /* The task does not appear on the event list item of
1434:FreeRTOS/tasks.c ****                                  * and of the RTOS objects, but could still be in the
1435:FreeRTOS/tasks.c ****                                  * blocked state if it is waiting on its notification
1436:FreeRTOS/tasks.c ****                                  * rather than waiting on an object.  If not, is
1437:FreeRTOS/tasks.c ****                                  * suspended. */
1438:FreeRTOS/tasks.c ****                                 eReturn = eSuspended;
1439:FreeRTOS/tasks.c **** 
1440:FreeRTOS/tasks.c ****                                 for( x = 0; x < configTASK_NOTIFICATION_ARRAY_ENTRIES; x++ )
1441:FreeRTOS/tasks.c ****                                 {
1442:FreeRTOS/tasks.c ****                                     if( pxTCB->ucNotifyState[ x ] == taskWAITING_NOTIFICATION )
1443:FreeRTOS/tasks.c ****                                     {
1444:FreeRTOS/tasks.c ****                                         eReturn = eBlocked;
1445:FreeRTOS/tasks.c ****                                         break;
1446:FreeRTOS/tasks.c ****                                     }
1447:FreeRTOS/tasks.c ****                                 }
1448:FreeRTOS/tasks.c ****                             }
1449:FreeRTOS/tasks.c ****                         #else /* if ( configUSE_TASK_NOTIFICATIONS == 1 ) */
1450:FreeRTOS/tasks.c ****                             {
1451:FreeRTOS/tasks.c ****                                 eReturn = eSuspended;
1452:FreeRTOS/tasks.c ****                             }
1453:FreeRTOS/tasks.c ****                         #endif /* if ( configUSE_TASK_NOTIFICATIONS == 1 ) */
1454:FreeRTOS/tasks.c ****                     }
1455:FreeRTOS/tasks.c ****                     else
1456:FreeRTOS/tasks.c ****                     {
1457:FreeRTOS/tasks.c ****                         eReturn = eBlocked;
1458:FreeRTOS/tasks.c ****                     }
1459:FreeRTOS/tasks.c ****                 }
ARM GAS  /tmp/ccrgBt0i.s 			page 27


1460:FreeRTOS/tasks.c ****             #endif /* if ( INCLUDE_vTaskSuspend == 1 ) */
1461:FreeRTOS/tasks.c **** 
1462:FreeRTOS/tasks.c ****             #if ( INCLUDE_vTaskDelete == 1 )
1463:FreeRTOS/tasks.c ****                 else if( ( pxStateList == &xTasksWaitingTermination ) || ( pxStateList == NULL ) )
1464:FreeRTOS/tasks.c ****                 {
1465:FreeRTOS/tasks.c ****                     /* The task being queried is referenced from the deleted
1466:FreeRTOS/tasks.c ****                      * tasks list, or it is not referenced from any lists at
1467:FreeRTOS/tasks.c ****                      * all. */
1468:FreeRTOS/tasks.c ****                     eReturn = eDeleted;
1469:FreeRTOS/tasks.c ****                 }
1470:FreeRTOS/tasks.c ****             #endif
1471:FreeRTOS/tasks.c **** 
1472:FreeRTOS/tasks.c ****             else /*lint !e525 Negative indentation is intended to make use of pre-processor clearer
1473:FreeRTOS/tasks.c ****             {
1474:FreeRTOS/tasks.c ****                 /* If the task is not in any other state, it must be in the
1475:FreeRTOS/tasks.c ****                  * Ready (including pending ready) state. */
1476:FreeRTOS/tasks.c ****                 eReturn = eReady;
1477:FreeRTOS/tasks.c ****             }
1478:FreeRTOS/tasks.c ****         }
1479:FreeRTOS/tasks.c **** 
1480:FreeRTOS/tasks.c ****         return eReturn;
1481:FreeRTOS/tasks.c ****     } /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
1482:FreeRTOS/tasks.c **** 
1483:FreeRTOS/tasks.c **** #endif /* INCLUDE_eTaskGetState */
1484:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1485:FreeRTOS/tasks.c **** 
1486:FreeRTOS/tasks.c **** #if ( INCLUDE_uxTaskPriorityGet == 1 )
1487:FreeRTOS/tasks.c **** 
1488:FreeRTOS/tasks.c ****     UBaseType_t uxTaskPriorityGet( const TaskHandle_t xTask )
1489:FreeRTOS/tasks.c ****     {
1490:FreeRTOS/tasks.c ****         TCB_t const * pxTCB;
1491:FreeRTOS/tasks.c ****         UBaseType_t uxReturn;
1492:FreeRTOS/tasks.c **** 
1493:FreeRTOS/tasks.c ****         taskENTER_CRITICAL();
1494:FreeRTOS/tasks.c ****         {
1495:FreeRTOS/tasks.c ****             /* If null is passed in here then it is the priority of the task
1496:FreeRTOS/tasks.c ****              * that called uxTaskPriorityGet() that is being queried. */
1497:FreeRTOS/tasks.c ****             pxTCB = prvGetTCBFromHandle( xTask );
1498:FreeRTOS/tasks.c ****             uxReturn = pxTCB->uxPriority;
1499:FreeRTOS/tasks.c ****         }
1500:FreeRTOS/tasks.c ****         taskEXIT_CRITICAL();
1501:FreeRTOS/tasks.c **** 
1502:FreeRTOS/tasks.c ****         return uxReturn;
1503:FreeRTOS/tasks.c ****     }
1504:FreeRTOS/tasks.c **** 
1505:FreeRTOS/tasks.c **** #endif /* INCLUDE_uxTaskPriorityGet */
1506:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1507:FreeRTOS/tasks.c **** 
1508:FreeRTOS/tasks.c **** #if ( INCLUDE_uxTaskPriorityGet == 1 )
1509:FreeRTOS/tasks.c **** 
1510:FreeRTOS/tasks.c ****     UBaseType_t uxTaskPriorityGetFromISR( const TaskHandle_t xTask )
1511:FreeRTOS/tasks.c ****     {
1512:FreeRTOS/tasks.c ****         TCB_t const * pxTCB;
1513:FreeRTOS/tasks.c ****         UBaseType_t uxReturn, uxSavedInterruptState;
1514:FreeRTOS/tasks.c **** 
1515:FreeRTOS/tasks.c ****         /* RTOS ports that support interrupt nesting have the concept of a
1516:FreeRTOS/tasks.c ****          * maximum  system call (or maximum API call) interrupt priority.
ARM GAS  /tmp/ccrgBt0i.s 			page 28


1517:FreeRTOS/tasks.c ****          * Interrupts that are  above the maximum system call priority are keep
1518:FreeRTOS/tasks.c ****          * permanently enabled, even when the RTOS kernel is in a critical section,
1519:FreeRTOS/tasks.c ****          * but cannot make any calls to FreeRTOS API functions.  If configASSERT()
1520:FreeRTOS/tasks.c ****          * is defined in FreeRTOSConfig.h then
1521:FreeRTOS/tasks.c ****          * portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1522:FreeRTOS/tasks.c ****          * failure if a FreeRTOS API function is called from an interrupt that has
1523:FreeRTOS/tasks.c ****          * been assigned a priority above the configured maximum system call
1524:FreeRTOS/tasks.c ****          * priority.  Only FreeRTOS functions that end in FromISR can be called
1525:FreeRTOS/tasks.c ****          * from interrupts  that have been assigned a priority at or (logically)
1526:FreeRTOS/tasks.c ****          * below the maximum system call interrupt priority.  FreeRTOS maintains a
1527:FreeRTOS/tasks.c ****          * separate interrupt safe API to ensure interrupt entry is as fast and as
1528:FreeRTOS/tasks.c ****          * simple as possible.  More information (albeit Cortex-M specific) is
1529:FreeRTOS/tasks.c ****          * provided on the following link:
1530:FreeRTOS/tasks.c ****          * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
1531:FreeRTOS/tasks.c ****         portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1532:FreeRTOS/tasks.c **** 
1533:FreeRTOS/tasks.c ****         uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
1534:FreeRTOS/tasks.c ****         {
1535:FreeRTOS/tasks.c ****             /* If null is passed in here then it is the priority of the calling
1536:FreeRTOS/tasks.c ****              * task that is being queried. */
1537:FreeRTOS/tasks.c ****             pxTCB = prvGetTCBFromHandle( xTask );
1538:FreeRTOS/tasks.c ****             uxReturn = pxTCB->uxPriority;
1539:FreeRTOS/tasks.c ****         }
1540:FreeRTOS/tasks.c ****         portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );
1541:FreeRTOS/tasks.c **** 
1542:FreeRTOS/tasks.c ****         return uxReturn;
1543:FreeRTOS/tasks.c ****     }
1544:FreeRTOS/tasks.c **** 
1545:FreeRTOS/tasks.c **** #endif /* INCLUDE_uxTaskPriorityGet */
1546:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1547:FreeRTOS/tasks.c **** 
1548:FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskPrioritySet == 1 )
1549:FreeRTOS/tasks.c **** 
1550:FreeRTOS/tasks.c ****     void vTaskPrioritySet( TaskHandle_t xTask,
1551:FreeRTOS/tasks.c ****                            UBaseType_t uxNewPriority )
1552:FreeRTOS/tasks.c ****     {
1553:FreeRTOS/tasks.c ****         TCB_t * pxTCB;
1554:FreeRTOS/tasks.c ****         UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
1555:FreeRTOS/tasks.c ****         BaseType_t xYieldRequired = pdFALSE;
1556:FreeRTOS/tasks.c **** 
1557:FreeRTOS/tasks.c ****         configASSERT( uxNewPriority < configMAX_PRIORITIES );
1558:FreeRTOS/tasks.c **** 
1559:FreeRTOS/tasks.c ****         /* Ensure the new priority is valid. */
1560:FreeRTOS/tasks.c ****         if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
1561:FreeRTOS/tasks.c ****         {
1562:FreeRTOS/tasks.c ****             uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
1563:FreeRTOS/tasks.c ****         }
1564:FreeRTOS/tasks.c ****         else
1565:FreeRTOS/tasks.c ****         {
1566:FreeRTOS/tasks.c ****             mtCOVERAGE_TEST_MARKER();
1567:FreeRTOS/tasks.c ****         }
1568:FreeRTOS/tasks.c **** 
1569:FreeRTOS/tasks.c ****         taskENTER_CRITICAL();
1570:FreeRTOS/tasks.c ****         {
1571:FreeRTOS/tasks.c ****             /* If null is passed in here then it is the priority of the calling
1572:FreeRTOS/tasks.c ****              * task that is being changed. */
1573:FreeRTOS/tasks.c ****             pxTCB = prvGetTCBFromHandle( xTask );
ARM GAS  /tmp/ccrgBt0i.s 			page 29


1574:FreeRTOS/tasks.c **** 
1575:FreeRTOS/tasks.c ****             traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
1576:FreeRTOS/tasks.c **** 
1577:FreeRTOS/tasks.c ****             #if ( configUSE_MUTEXES == 1 )
1578:FreeRTOS/tasks.c ****                 {
1579:FreeRTOS/tasks.c ****                     uxCurrentBasePriority = pxTCB->uxBasePriority;
1580:FreeRTOS/tasks.c ****                 }
1581:FreeRTOS/tasks.c ****             #else
1582:FreeRTOS/tasks.c ****                 {
1583:FreeRTOS/tasks.c ****                     uxCurrentBasePriority = pxTCB->uxPriority;
1584:FreeRTOS/tasks.c ****                 }
1585:FreeRTOS/tasks.c ****             #endif
1586:FreeRTOS/tasks.c **** 
1587:FreeRTOS/tasks.c ****             if( uxCurrentBasePriority != uxNewPriority )
1588:FreeRTOS/tasks.c ****             {
1589:FreeRTOS/tasks.c ****                 /* The priority change may have readied a task of higher
1590:FreeRTOS/tasks.c ****                  * priority than the calling task. */
1591:FreeRTOS/tasks.c ****                 if( uxNewPriority > uxCurrentBasePriority )
1592:FreeRTOS/tasks.c ****                 {
1593:FreeRTOS/tasks.c ****                     if( pxTCB != pxCurrentTCB )
1594:FreeRTOS/tasks.c ****                     {
1595:FreeRTOS/tasks.c ****                         /* The priority of a task other than the currently
1596:FreeRTOS/tasks.c ****                          * running task is being raised.  Is the priority being
1597:FreeRTOS/tasks.c ****                          * raised above that of the running task? */
1598:FreeRTOS/tasks.c ****                         if( uxNewPriority >= pxCurrentTCB->uxPriority )
1599:FreeRTOS/tasks.c ****                         {
1600:FreeRTOS/tasks.c ****                             xYieldRequired = pdTRUE;
1601:FreeRTOS/tasks.c ****                         }
1602:FreeRTOS/tasks.c ****                         else
1603:FreeRTOS/tasks.c ****                         {
1604:FreeRTOS/tasks.c ****                             mtCOVERAGE_TEST_MARKER();
1605:FreeRTOS/tasks.c ****                         }
1606:FreeRTOS/tasks.c ****                     }
1607:FreeRTOS/tasks.c ****                     else
1608:FreeRTOS/tasks.c ****                     {
1609:FreeRTOS/tasks.c ****                         /* The priority of the running task is being raised,
1610:FreeRTOS/tasks.c ****                          * but the running task must already be the highest
1611:FreeRTOS/tasks.c ****                          * priority task able to run so no yield is required. */
1612:FreeRTOS/tasks.c ****                     }
1613:FreeRTOS/tasks.c ****                 }
1614:FreeRTOS/tasks.c ****                 else if( pxTCB == pxCurrentTCB )
1615:FreeRTOS/tasks.c ****                 {
1616:FreeRTOS/tasks.c ****                     /* Setting the priority of the running task down means
1617:FreeRTOS/tasks.c ****                      * there may now be another task of higher priority that
1618:FreeRTOS/tasks.c ****                      * is ready to execute. */
1619:FreeRTOS/tasks.c ****                     xYieldRequired = pdTRUE;
1620:FreeRTOS/tasks.c ****                 }
1621:FreeRTOS/tasks.c ****                 else
1622:FreeRTOS/tasks.c ****                 {
1623:FreeRTOS/tasks.c ****                     /* Setting the priority of any other task down does not
1624:FreeRTOS/tasks.c ****                      * require a yield as the running task must be above the
1625:FreeRTOS/tasks.c ****                      * new priority of the task being modified. */
1626:FreeRTOS/tasks.c ****                 }
1627:FreeRTOS/tasks.c **** 
1628:FreeRTOS/tasks.c ****                 /* Remember the ready list the task might be referenced from
1629:FreeRTOS/tasks.c ****                  * before its uxPriority member is changed so the
1630:FreeRTOS/tasks.c ****                  * taskRESET_READY_PRIORITY() macro can function correctly. */
ARM GAS  /tmp/ccrgBt0i.s 			page 30


1631:FreeRTOS/tasks.c ****                 uxPriorityUsedOnEntry = pxTCB->uxPriority;
1632:FreeRTOS/tasks.c **** 
1633:FreeRTOS/tasks.c ****                 #if ( configUSE_MUTEXES == 1 )
1634:FreeRTOS/tasks.c ****                     {
1635:FreeRTOS/tasks.c ****                         /* Only change the priority being used if the task is not
1636:FreeRTOS/tasks.c ****                          * currently using an inherited priority. */
1637:FreeRTOS/tasks.c ****                         if( pxTCB->uxBasePriority == pxTCB->uxPriority )
1638:FreeRTOS/tasks.c ****                         {
1639:FreeRTOS/tasks.c ****                             pxTCB->uxPriority = uxNewPriority;
1640:FreeRTOS/tasks.c ****                         }
1641:FreeRTOS/tasks.c ****                         else
1642:FreeRTOS/tasks.c ****                         {
1643:FreeRTOS/tasks.c ****                             mtCOVERAGE_TEST_MARKER();
1644:FreeRTOS/tasks.c ****                         }
1645:FreeRTOS/tasks.c **** 
1646:FreeRTOS/tasks.c ****                         /* The base priority gets set whatever. */
1647:FreeRTOS/tasks.c ****                         pxTCB->uxBasePriority = uxNewPriority;
1648:FreeRTOS/tasks.c ****                     }
1649:FreeRTOS/tasks.c ****                 #else /* if ( configUSE_MUTEXES == 1 ) */
1650:FreeRTOS/tasks.c ****                     {
1651:FreeRTOS/tasks.c ****                         pxTCB->uxPriority = uxNewPriority;
1652:FreeRTOS/tasks.c ****                     }
1653:FreeRTOS/tasks.c ****                 #endif /* if ( configUSE_MUTEXES == 1 ) */
1654:FreeRTOS/tasks.c **** 
1655:FreeRTOS/tasks.c ****                 /* Only reset the event list item value if the value is not
1656:FreeRTOS/tasks.c ****                  * being used for anything else. */
1657:FreeRTOS/tasks.c ****                 if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_V
1658:FreeRTOS/tasks.c ****                 {
1659:FreeRTOS/tasks.c ****                     listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX
1660:FreeRTOS/tasks.c ****                 }
1661:FreeRTOS/tasks.c ****                 else
1662:FreeRTOS/tasks.c ****                 {
1663:FreeRTOS/tasks.c ****                     mtCOVERAGE_TEST_MARKER();
1664:FreeRTOS/tasks.c ****                 }
1665:FreeRTOS/tasks.c **** 
1666:FreeRTOS/tasks.c ****                 /* If the task is in the blocked or suspended list we need do
1667:FreeRTOS/tasks.c ****                  * nothing more than change its priority variable. However, if
1668:FreeRTOS/tasks.c ****                  * the task is in a ready list it needs to be removed and placed
1669:FreeRTOS/tasks.c ****                  * in the list appropriate to its new priority. */
1670:FreeRTOS/tasks.c ****                 if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( px
1671:FreeRTOS/tasks.c ****                 {
1672:FreeRTOS/tasks.c ****                     /* The task is currently in its ready list - remove before
1673:FreeRTOS/tasks.c ****                      * adding it to its new ready list.  As we are in a critical
1674:FreeRTOS/tasks.c ****                      * section we can do this even if the scheduler is suspended. */
1675:FreeRTOS/tasks.c ****                     if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
1676:FreeRTOS/tasks.c ****                     {
1677:FreeRTOS/tasks.c ****                         /* It is known that the task is in its ready list so
1678:FreeRTOS/tasks.c ****                          * there is no need to check again and the port level
1679:FreeRTOS/tasks.c ****                          * reset macro can be called directly. */
1680:FreeRTOS/tasks.c ****                         portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
1681:FreeRTOS/tasks.c ****                     }
1682:FreeRTOS/tasks.c ****                     else
1683:FreeRTOS/tasks.c ****                     {
1684:FreeRTOS/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
1685:FreeRTOS/tasks.c ****                     }
1686:FreeRTOS/tasks.c **** 
1687:FreeRTOS/tasks.c ****                     prvAddTaskToReadyList( pxTCB );
ARM GAS  /tmp/ccrgBt0i.s 			page 31


1688:FreeRTOS/tasks.c ****                 }
1689:FreeRTOS/tasks.c ****                 else
1690:FreeRTOS/tasks.c ****                 {
1691:FreeRTOS/tasks.c ****                     mtCOVERAGE_TEST_MARKER();
1692:FreeRTOS/tasks.c ****                 }
1693:FreeRTOS/tasks.c **** 
1694:FreeRTOS/tasks.c ****                 if( xYieldRequired != pdFALSE )
1695:FreeRTOS/tasks.c ****                 {
1696:FreeRTOS/tasks.c ****                     taskYIELD_IF_USING_PREEMPTION();
1697:FreeRTOS/tasks.c ****                 }
1698:FreeRTOS/tasks.c ****                 else
1699:FreeRTOS/tasks.c ****                 {
1700:FreeRTOS/tasks.c ****                     mtCOVERAGE_TEST_MARKER();
1701:FreeRTOS/tasks.c ****                 }
1702:FreeRTOS/tasks.c **** 
1703:FreeRTOS/tasks.c ****                 /* Remove compiler warning about unused variables when the port
1704:FreeRTOS/tasks.c ****                  * optimised task selection is not being used. */
1705:FreeRTOS/tasks.c ****                 ( void ) uxPriorityUsedOnEntry;
1706:FreeRTOS/tasks.c ****             }
1707:FreeRTOS/tasks.c ****         }
1708:FreeRTOS/tasks.c ****         taskEXIT_CRITICAL();
1709:FreeRTOS/tasks.c ****     }
1710:FreeRTOS/tasks.c **** 
1711:FreeRTOS/tasks.c **** #endif /* INCLUDE_vTaskPrioritySet */
1712:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1713:FreeRTOS/tasks.c **** 
1714:FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1715:FreeRTOS/tasks.c **** 
1716:FreeRTOS/tasks.c ****     void vTaskSuspend( TaskHandle_t xTaskToSuspend )
1717:FreeRTOS/tasks.c ****     {
1718:FreeRTOS/tasks.c ****         TCB_t * pxTCB;
1719:FreeRTOS/tasks.c **** 
1720:FreeRTOS/tasks.c ****         taskENTER_CRITICAL();
1721:FreeRTOS/tasks.c ****         {
1722:FreeRTOS/tasks.c ****             /* If null is passed in here then it is the running task that is
1723:FreeRTOS/tasks.c ****              * being suspended. */
1724:FreeRTOS/tasks.c ****             pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
1725:FreeRTOS/tasks.c **** 
1726:FreeRTOS/tasks.c ****             traceTASK_SUSPEND( pxTCB );
1727:FreeRTOS/tasks.c **** 
1728:FreeRTOS/tasks.c ****             /* Remove task from the ready/delayed list and place in the
1729:FreeRTOS/tasks.c ****              * suspended list. */
1730:FreeRTOS/tasks.c ****             if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
1731:FreeRTOS/tasks.c ****             {
1732:FreeRTOS/tasks.c ****                 taskRESET_READY_PRIORITY( pxTCB->uxPriority );
1733:FreeRTOS/tasks.c ****             }
1734:FreeRTOS/tasks.c ****             else
1735:FreeRTOS/tasks.c ****             {
1736:FreeRTOS/tasks.c ****                 mtCOVERAGE_TEST_MARKER();
1737:FreeRTOS/tasks.c ****             }
1738:FreeRTOS/tasks.c **** 
1739:FreeRTOS/tasks.c ****             /* Is the task waiting on an event also? */
1740:FreeRTOS/tasks.c ****             if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
1741:FreeRTOS/tasks.c ****             {
1742:FreeRTOS/tasks.c ****                 ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
1743:FreeRTOS/tasks.c ****             }
1744:FreeRTOS/tasks.c ****             else
ARM GAS  /tmp/ccrgBt0i.s 			page 32


1745:FreeRTOS/tasks.c ****             {
1746:FreeRTOS/tasks.c ****                 mtCOVERAGE_TEST_MARKER();
1747:FreeRTOS/tasks.c ****             }
1748:FreeRTOS/tasks.c **** 
1749:FreeRTOS/tasks.c ****             vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
1750:FreeRTOS/tasks.c **** 
1751:FreeRTOS/tasks.c ****             #if ( configUSE_TASK_NOTIFICATIONS == 1 )
1752:FreeRTOS/tasks.c ****                 {
1753:FreeRTOS/tasks.c ****                     BaseType_t x;
1754:FreeRTOS/tasks.c **** 
1755:FreeRTOS/tasks.c ****                     for( x = 0; x < configTASK_NOTIFICATION_ARRAY_ENTRIES; x++ )
1756:FreeRTOS/tasks.c ****                     {
1757:FreeRTOS/tasks.c ****                         if( pxTCB->ucNotifyState[ x ] == taskWAITING_NOTIFICATION )
1758:FreeRTOS/tasks.c ****                         {
1759:FreeRTOS/tasks.c ****                             /* The task was blocked to wait for a notification, but is
1760:FreeRTOS/tasks.c ****                              * now suspended, so no notification was received. */
1761:FreeRTOS/tasks.c ****                             pxTCB->ucNotifyState[ x ] = taskNOT_WAITING_NOTIFICATION;
1762:FreeRTOS/tasks.c ****                         }
1763:FreeRTOS/tasks.c ****                     }
1764:FreeRTOS/tasks.c ****                 }
1765:FreeRTOS/tasks.c ****             #endif /* if ( configUSE_TASK_NOTIFICATIONS == 1 ) */
1766:FreeRTOS/tasks.c ****         }
1767:FreeRTOS/tasks.c ****         taskEXIT_CRITICAL();
1768:FreeRTOS/tasks.c **** 
1769:FreeRTOS/tasks.c ****         if( xSchedulerRunning != pdFALSE )
1770:FreeRTOS/tasks.c ****         {
1771:FreeRTOS/tasks.c ****             /* Reset the next expected unblock time in case it referred to the
1772:FreeRTOS/tasks.c ****              * task that is now in the Suspended state. */
1773:FreeRTOS/tasks.c ****             taskENTER_CRITICAL();
1774:FreeRTOS/tasks.c ****             {
1775:FreeRTOS/tasks.c ****                 prvResetNextTaskUnblockTime();
1776:FreeRTOS/tasks.c ****             }
1777:FreeRTOS/tasks.c ****             taskEXIT_CRITICAL();
1778:FreeRTOS/tasks.c ****         }
1779:FreeRTOS/tasks.c ****         else
1780:FreeRTOS/tasks.c ****         {
1781:FreeRTOS/tasks.c ****             mtCOVERAGE_TEST_MARKER();
1782:FreeRTOS/tasks.c ****         }
1783:FreeRTOS/tasks.c **** 
1784:FreeRTOS/tasks.c ****         if( pxTCB == pxCurrentTCB )
1785:FreeRTOS/tasks.c ****         {
1786:FreeRTOS/tasks.c ****             if( xSchedulerRunning != pdFALSE )
1787:FreeRTOS/tasks.c ****             {
1788:FreeRTOS/tasks.c ****                 /* The current task has just been suspended. */
1789:FreeRTOS/tasks.c ****                 configASSERT( uxSchedulerSuspended == 0 );
1790:FreeRTOS/tasks.c ****                 portYIELD_WITHIN_API();
1791:FreeRTOS/tasks.c ****             }
1792:FreeRTOS/tasks.c ****             else
1793:FreeRTOS/tasks.c ****             {
1794:FreeRTOS/tasks.c ****                 /* The scheduler is not running, but the task that was pointed
1795:FreeRTOS/tasks.c ****                  * to by pxCurrentTCB has just been suspended and pxCurrentTCB
1796:FreeRTOS/tasks.c ****                  * must be adjusted to point to a different task. */
1797:FreeRTOS/tasks.c ****                 if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*li
1798:FreeRTOS/tasks.c ****                 {
1799:FreeRTOS/tasks.c ****                     /* No other tasks are ready, so set pxCurrentTCB back to
1800:FreeRTOS/tasks.c ****                      * NULL so when the next task is created pxCurrentTCB will
1801:FreeRTOS/tasks.c ****                      * be set to point to it no matter what its relative priority
ARM GAS  /tmp/ccrgBt0i.s 			page 33


1802:FreeRTOS/tasks.c ****                      * is. */
1803:FreeRTOS/tasks.c ****                     pxCurrentTCB = NULL;
1804:FreeRTOS/tasks.c ****                 }
1805:FreeRTOS/tasks.c ****                 else
1806:FreeRTOS/tasks.c ****                 {
1807:FreeRTOS/tasks.c ****                     vTaskSwitchContext();
1808:FreeRTOS/tasks.c ****                 }
1809:FreeRTOS/tasks.c ****             }
1810:FreeRTOS/tasks.c ****         }
1811:FreeRTOS/tasks.c ****         else
1812:FreeRTOS/tasks.c ****         {
1813:FreeRTOS/tasks.c ****             mtCOVERAGE_TEST_MARKER();
1814:FreeRTOS/tasks.c ****         }
1815:FreeRTOS/tasks.c ****     }
1816:FreeRTOS/tasks.c **** 
1817:FreeRTOS/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1818:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1819:FreeRTOS/tasks.c **** 
1820:FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1821:FreeRTOS/tasks.c **** 
1822:FreeRTOS/tasks.c ****     static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
1823:FreeRTOS/tasks.c ****     {
  25              		.loc 1 1823 0
  26              		.cfi_startproc
  27              		@ args = 0, pretend = 0, frame = 0
  28              		@ frame_needed = 0, uses_anonymous_args = 0
  29              		@ link register save eliminated.
  30              	.LVL0:
1824:FreeRTOS/tasks.c ****         BaseType_t xReturn = pdFALSE;
1825:FreeRTOS/tasks.c ****         const TCB_t * const pxTCB = xTask;
1826:FreeRTOS/tasks.c **** 
1827:FreeRTOS/tasks.c ****         /* Accesses xPendingReadyList so must be called from a critical
1828:FreeRTOS/tasks.c ****          * section. */
1829:FreeRTOS/tasks.c **** 
1830:FreeRTOS/tasks.c ****         /* It does not make sense to check if the calling task is suspended. */
1831:FreeRTOS/tasks.c ****         configASSERT( xTask );
  31              		.loc 1 1831 0
  32 0000 50B1     		cbz	r0, .L8
1832:FreeRTOS/tasks.c **** 
1833:FreeRTOS/tasks.c ****         /* Is the task being resumed actually in the suspended list? */
1834:FreeRTOS/tasks.c ****         if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
  33              		.loc 1 1834 0
  34 0002 4169     		ldr	r1, [r0, #20]
  35 0004 0C4A     		ldr	r2, .L9
  36 0006 9142     		cmp	r1, r2
  37 0008 0FD1     		bne	.L5
1835:FreeRTOS/tasks.c ****         {
1836:FreeRTOS/tasks.c ****             /* Has the task already been resumed from within an ISR? */
1837:FreeRTOS/tasks.c ****             if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALS
  38              		.loc 1 1837 0
  39 000a 836A     		ldr	r3, [r0, #40]
  40 000c 0B4A     		ldr	r2, .L9+4
  41 000e 9342     		cmp	r3, r2
  42 0010 0DD0     		beq	.L6
1838:FreeRTOS/tasks.c ****             {
1839:FreeRTOS/tasks.c ****                 /* Is it in the suspended list because it is in the Suspended
1840:FreeRTOS/tasks.c ****                  * state, or because is is blocked with no timeout? */
ARM GAS  /tmp/ccrgBt0i.s 			page 34


1841:FreeRTOS/tasks.c ****                 if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint
  43              		.loc 1 1841 0
  44 0012 73B1     		cbz	r3, .L7
1824:FreeRTOS/tasks.c ****         const TCB_t * const pxTCB = xTask;
  45              		.loc 1 1824 0
  46 0014 0020     		movs	r0, #0
  47              	.LVL1:
  48 0016 7047     		bx	lr
  49              	.LVL2:
  50              	.L8:
  51              	.LBB152:
  52              	.LBB153:
  53              		.file 2 "FreeRTOS/ARM_CM3/portmacro.h"
   1:FreeRTOS/ARM_CM3/portmacro.h **** /*
   2:FreeRTOS/ARM_CM3/portmacro.h ****  * FreeRTOS Kernel V10.4.6
   3:FreeRTOS/ARM_CM3/portmacro.h ****  * Copyright (C) 2021 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
   4:FreeRTOS/ARM_CM3/portmacro.h ****  *
   5:FreeRTOS/ARM_CM3/portmacro.h ****  * SPDX-License-Identifier: MIT
   6:FreeRTOS/ARM_CM3/portmacro.h ****  *
   7:FreeRTOS/ARM_CM3/portmacro.h ****  * Permission is hereby granted, free of charge, to any person obtaining a copy of
   8:FreeRTOS/ARM_CM3/portmacro.h ****  * this software and associated documentation files (the "Software"), to deal in
   9:FreeRTOS/ARM_CM3/portmacro.h ****  * the Software without restriction, including without limitation the rights to
  10:FreeRTOS/ARM_CM3/portmacro.h ****  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
  11:FreeRTOS/ARM_CM3/portmacro.h ****  * the Software, and to permit persons to whom the Software is furnished to do so,
  12:FreeRTOS/ARM_CM3/portmacro.h ****  * subject to the following conditions:
  13:FreeRTOS/ARM_CM3/portmacro.h ****  *
  14:FreeRTOS/ARM_CM3/portmacro.h ****  * The above copyright notice and this permission notice shall be included in all
  15:FreeRTOS/ARM_CM3/portmacro.h ****  * copies or substantial portions of the Software.
  16:FreeRTOS/ARM_CM3/portmacro.h ****  *
  17:FreeRTOS/ARM_CM3/portmacro.h ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  18:FreeRTOS/ARM_CM3/portmacro.h ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  19:FreeRTOS/ARM_CM3/portmacro.h ****  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  20:FreeRTOS/ARM_CM3/portmacro.h ****  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  21:FreeRTOS/ARM_CM3/portmacro.h ****  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  22:FreeRTOS/ARM_CM3/portmacro.h ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  23:FreeRTOS/ARM_CM3/portmacro.h ****  *
  24:FreeRTOS/ARM_CM3/portmacro.h ****  * https://www.FreeRTOS.org
  25:FreeRTOS/ARM_CM3/portmacro.h ****  * https://github.com/FreeRTOS
  26:FreeRTOS/ARM_CM3/portmacro.h ****  *
  27:FreeRTOS/ARM_CM3/portmacro.h ****  */
  28:FreeRTOS/ARM_CM3/portmacro.h **** 
  29:FreeRTOS/ARM_CM3/portmacro.h **** 
  30:FreeRTOS/ARM_CM3/portmacro.h **** #ifndef PORTMACRO_H
  31:FreeRTOS/ARM_CM3/portmacro.h ****     #define PORTMACRO_H
  32:FreeRTOS/ARM_CM3/portmacro.h **** 
  33:FreeRTOS/ARM_CM3/portmacro.h ****     #ifdef __cplusplus
  34:FreeRTOS/ARM_CM3/portmacro.h ****         extern "C" {
  35:FreeRTOS/ARM_CM3/portmacro.h ****     #endif
  36:FreeRTOS/ARM_CM3/portmacro.h **** 
  37:FreeRTOS/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------
  38:FreeRTOS/ARM_CM3/portmacro.h ****  * Port specific definitions.
  39:FreeRTOS/ARM_CM3/portmacro.h ****  *
  40:FreeRTOS/ARM_CM3/portmacro.h ****  * The settings in this file configure FreeRTOS correctly for the
  41:FreeRTOS/ARM_CM3/portmacro.h ****  * given hardware and compiler.
  42:FreeRTOS/ARM_CM3/portmacro.h ****  *
  43:FreeRTOS/ARM_CM3/portmacro.h ****  * These settings should not be altered.
  44:FreeRTOS/ARM_CM3/portmacro.h ****  *-----------------------------------------------------------
ARM GAS  /tmp/ccrgBt0i.s 			page 35


  45:FreeRTOS/ARM_CM3/portmacro.h ****  */
  46:FreeRTOS/ARM_CM3/portmacro.h **** 
  47:FreeRTOS/ARM_CM3/portmacro.h **** /* Type definitions. */
  48:FreeRTOS/ARM_CM3/portmacro.h ****     #define portCHAR          char
  49:FreeRTOS/ARM_CM3/portmacro.h ****     #define portFLOAT         float
  50:FreeRTOS/ARM_CM3/portmacro.h ****     #define portDOUBLE        double
  51:FreeRTOS/ARM_CM3/portmacro.h ****     #define portLONG          long
  52:FreeRTOS/ARM_CM3/portmacro.h ****     #define portSHORT         short
  53:FreeRTOS/ARM_CM3/portmacro.h ****     #define portSTACK_TYPE    uint32_t
  54:FreeRTOS/ARM_CM3/portmacro.h ****     #define portBASE_TYPE     long
  55:FreeRTOS/ARM_CM3/portmacro.h **** 
  56:FreeRTOS/ARM_CM3/portmacro.h ****     typedef portSTACK_TYPE   StackType_t;
  57:FreeRTOS/ARM_CM3/portmacro.h ****     typedef long             BaseType_t;
  58:FreeRTOS/ARM_CM3/portmacro.h ****     typedef unsigned long    UBaseType_t;
  59:FreeRTOS/ARM_CM3/portmacro.h **** 
  60:FreeRTOS/ARM_CM3/portmacro.h ****     #if ( configUSE_16_BIT_TICKS == 1 )
  61:FreeRTOS/ARM_CM3/portmacro.h ****         typedef uint16_t     TickType_t;
  62:FreeRTOS/ARM_CM3/portmacro.h ****         #define portMAX_DELAY              ( TickType_t ) 0xffff
  63:FreeRTOS/ARM_CM3/portmacro.h ****     #else
  64:FreeRTOS/ARM_CM3/portmacro.h ****         typedef uint32_t     TickType_t;
  65:FreeRTOS/ARM_CM3/portmacro.h ****         #define portMAX_DELAY              ( TickType_t ) 0xffffffffUL
  66:FreeRTOS/ARM_CM3/portmacro.h **** 
  67:FreeRTOS/ARM_CM3/portmacro.h **** /* 32-bit tick type on a 32-bit architecture, so reads of the tick count do
  68:FreeRTOS/ARM_CM3/portmacro.h ****  * not need to be guarded with a critical section. */
  69:FreeRTOS/ARM_CM3/portmacro.h ****         #define portTICK_TYPE_IS_ATOMIC    1
  70:FreeRTOS/ARM_CM3/portmacro.h ****     #endif
  71:FreeRTOS/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
  72:FreeRTOS/ARM_CM3/portmacro.h **** 
  73:FreeRTOS/ARM_CM3/portmacro.h **** /* Architecture specifics. */
  74:FreeRTOS/ARM_CM3/portmacro.h ****     #define portSTACK_GROWTH      ( -1 )
  75:FreeRTOS/ARM_CM3/portmacro.h ****     #define portTICK_PERIOD_MS    ( ( TickType_t ) 1000 / configTICK_RATE_HZ )
  76:FreeRTOS/ARM_CM3/portmacro.h ****     #define portBYTE_ALIGNMENT    8
  77:FreeRTOS/ARM_CM3/portmacro.h ****     #define portDONT_DISCARD      __attribute__( ( used ) )
  78:FreeRTOS/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
  79:FreeRTOS/ARM_CM3/portmacro.h **** 
  80:FreeRTOS/ARM_CM3/portmacro.h **** /* Scheduler utilities. */
  81:FreeRTOS/ARM_CM3/portmacro.h ****     #define portYIELD()                                 \
  82:FreeRTOS/ARM_CM3/portmacro.h ****     {                                                   \
  83:FreeRTOS/ARM_CM3/portmacro.h ****         /* Set a PendSV to request a context switch. */ \
  84:FreeRTOS/ARM_CM3/portmacro.h ****         portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT; \
  85:FreeRTOS/ARM_CM3/portmacro.h ****                                                         \
  86:FreeRTOS/ARM_CM3/portmacro.h ****         /* Barriers are normally not required but do ensure the code is completely \
  87:FreeRTOS/ARM_CM3/portmacro.h ****          * within the specified behaviour for the architecture. */ \
  88:FreeRTOS/ARM_CM3/portmacro.h ****         __asm volatile ( "dsb" ::: "memory" );                     \
  89:FreeRTOS/ARM_CM3/portmacro.h ****         __asm volatile ( "isb" );                                  \
  90:FreeRTOS/ARM_CM3/portmacro.h ****     }
  91:FreeRTOS/ARM_CM3/portmacro.h **** 
  92:FreeRTOS/ARM_CM3/portmacro.h ****     #define portNVIC_INT_CTRL_REG     ( *( ( volatile uint32_t * ) 0xe000ed04 ) )
  93:FreeRTOS/ARM_CM3/portmacro.h ****     #define portNVIC_PENDSVSET_BIT    ( 1UL << 28UL )
  94:FreeRTOS/ARM_CM3/portmacro.h ****     #define portEND_SWITCHING_ISR( xSwitchRequired )    do { if( xSwitchRequired != pdFALSE ) portY
  95:FreeRTOS/ARM_CM3/portmacro.h ****     #define portYIELD_FROM_ISR( x )                     portEND_SWITCHING_ISR( x )
  96:FreeRTOS/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
  97:FreeRTOS/ARM_CM3/portmacro.h **** 
  98:FreeRTOS/ARM_CM3/portmacro.h **** /* Critical section management. */
  99:FreeRTOS/ARM_CM3/portmacro.h ****     extern void vPortEnterCritical( void );
 100:FreeRTOS/ARM_CM3/portmacro.h ****     extern void vPortExitCritical( void );
 101:FreeRTOS/ARM_CM3/portmacro.h ****     #define portSET_INTERRUPT_MASK_FROM_ISR()         ulPortRaiseBASEPRI()
ARM GAS  /tmp/ccrgBt0i.s 			page 36


 102:FreeRTOS/ARM_CM3/portmacro.h ****     #define portCLEAR_INTERRUPT_MASK_FROM_ISR( x )    vPortSetBASEPRI( x )
 103:FreeRTOS/ARM_CM3/portmacro.h ****     #define portDISABLE_INTERRUPTS()                  vPortRaiseBASEPRI()
 104:FreeRTOS/ARM_CM3/portmacro.h ****     #define portENABLE_INTERRUPTS()                   vPortSetBASEPRI( 0 )
 105:FreeRTOS/ARM_CM3/portmacro.h ****     #define portENTER_CRITICAL()                      vPortEnterCritical()
 106:FreeRTOS/ARM_CM3/portmacro.h ****     #define portEXIT_CRITICAL()                       vPortExitCritical()
 107:FreeRTOS/ARM_CM3/portmacro.h **** 
 108:FreeRTOS/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 109:FreeRTOS/ARM_CM3/portmacro.h **** 
 110:FreeRTOS/ARM_CM3/portmacro.h **** /* Task function macros as described on the FreeRTOS.org WEB site.  These are
 111:FreeRTOS/ARM_CM3/portmacro.h ****  * not necessary for to use this port.  They are defined so the common demo files
 112:FreeRTOS/ARM_CM3/portmacro.h ****  * (which build with all the ports) will build. */
 113:FreeRTOS/ARM_CM3/portmacro.h ****     #define portTASK_FUNCTION_PROTO( vFunction, pvParameters )    void vFunction( void * pvParamete
 114:FreeRTOS/ARM_CM3/portmacro.h ****     #define portTASK_FUNCTION( vFunction, pvParameters )          void vFunction( void * pvParamete
 115:FreeRTOS/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 116:FreeRTOS/ARM_CM3/portmacro.h **** 
 117:FreeRTOS/ARM_CM3/portmacro.h **** /* Tickless idle/low power functionality. */
 118:FreeRTOS/ARM_CM3/portmacro.h ****     #ifndef portSUPPRESS_TICKS_AND_SLEEP
 119:FreeRTOS/ARM_CM3/portmacro.h ****         extern void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime );
 120:FreeRTOS/ARM_CM3/portmacro.h ****         #define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime )    vPortSuppressTicksAndSleep( xE
 121:FreeRTOS/ARM_CM3/portmacro.h ****     #endif
 122:FreeRTOS/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 123:FreeRTOS/ARM_CM3/portmacro.h **** 
 124:FreeRTOS/ARM_CM3/portmacro.h **** /* Architecture specific optimisations. */
 125:FreeRTOS/ARM_CM3/portmacro.h ****     #ifndef configUSE_PORT_OPTIMISED_TASK_SELECTION
 126:FreeRTOS/ARM_CM3/portmacro.h ****         #define configUSE_PORT_OPTIMISED_TASK_SELECTION    1
 127:FreeRTOS/ARM_CM3/portmacro.h ****     #endif
 128:FreeRTOS/ARM_CM3/portmacro.h **** 
 129:FreeRTOS/ARM_CM3/portmacro.h ****     #if configUSE_PORT_OPTIMISED_TASK_SELECTION == 1
 130:FreeRTOS/ARM_CM3/portmacro.h **** 
 131:FreeRTOS/ARM_CM3/portmacro.h **** /* Generic helper function. */
 132:FreeRTOS/ARM_CM3/portmacro.h ****         __attribute__( ( always_inline ) ) static inline uint8_t ucPortCountLeadingZeros( uint32_t 
 133:FreeRTOS/ARM_CM3/portmacro.h ****         {
 134:FreeRTOS/ARM_CM3/portmacro.h ****             uint8_t ucReturn;
 135:FreeRTOS/ARM_CM3/portmacro.h **** 
 136:FreeRTOS/ARM_CM3/portmacro.h ****             __asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) : "memory" );
 137:FreeRTOS/ARM_CM3/portmacro.h **** 
 138:FreeRTOS/ARM_CM3/portmacro.h ****             return ucReturn;
 139:FreeRTOS/ARM_CM3/portmacro.h ****         }
 140:FreeRTOS/ARM_CM3/portmacro.h **** 
 141:FreeRTOS/ARM_CM3/portmacro.h **** /* Check the configuration. */
 142:FreeRTOS/ARM_CM3/portmacro.h ****         #if ( configMAX_PRIORITIES > 32 )
 143:FreeRTOS/ARM_CM3/portmacro.h ****             #error configUSE_PORT_OPTIMISED_TASK_SELECTION can only be set to 1 when configMAX_PRIO
 144:FreeRTOS/ARM_CM3/portmacro.h ****         #endif
 145:FreeRTOS/ARM_CM3/portmacro.h **** 
 146:FreeRTOS/ARM_CM3/portmacro.h **** /* Store/clear the ready priorities in a bit map. */
 147:FreeRTOS/ARM_CM3/portmacro.h ****         #define portRECORD_READY_PRIORITY( uxPriority, uxReadyPriorities )    ( uxReadyPriorities )
 148:FreeRTOS/ARM_CM3/portmacro.h ****         #define portRESET_READY_PRIORITY( uxPriority, uxReadyPriorities )     ( uxReadyPriorities )
 149:FreeRTOS/ARM_CM3/portmacro.h **** 
 150:FreeRTOS/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 151:FreeRTOS/ARM_CM3/portmacro.h **** 
 152:FreeRTOS/ARM_CM3/portmacro.h ****         #define portGET_HIGHEST_PRIORITY( uxTopPriority, uxReadyPriorities )    uxTopPriority = ( 3
 153:FreeRTOS/ARM_CM3/portmacro.h **** 
 154:FreeRTOS/ARM_CM3/portmacro.h ****     #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 155:FreeRTOS/ARM_CM3/portmacro.h **** 
 156:FreeRTOS/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 157:FreeRTOS/ARM_CM3/portmacro.h **** 
 158:FreeRTOS/ARM_CM3/portmacro.h ****     #ifdef configASSERT
ARM GAS  /tmp/ccrgBt0i.s 			page 37


 159:FreeRTOS/ARM_CM3/portmacro.h ****         void vPortValidateInterruptPriority( void );
 160:FreeRTOS/ARM_CM3/portmacro.h ****         #define portASSERT_IF_INTERRUPT_PRIORITY_INVALID()    vPortValidateInterruptPriority()
 161:FreeRTOS/ARM_CM3/portmacro.h ****     #endif
 162:FreeRTOS/ARM_CM3/portmacro.h **** 
 163:FreeRTOS/ARM_CM3/portmacro.h **** /* portNOP() is not required by this port. */
 164:FreeRTOS/ARM_CM3/portmacro.h ****     #define portNOP()
 165:FreeRTOS/ARM_CM3/portmacro.h **** 
 166:FreeRTOS/ARM_CM3/portmacro.h ****     #define portINLINE              __inline
 167:FreeRTOS/ARM_CM3/portmacro.h **** 
 168:FreeRTOS/ARM_CM3/portmacro.h ****     #ifndef portFORCE_INLINE
 169:FreeRTOS/ARM_CM3/portmacro.h ****         #define portFORCE_INLINE    inline __attribute__( ( always_inline ) )
 170:FreeRTOS/ARM_CM3/portmacro.h ****     #endif
 171:FreeRTOS/ARM_CM3/portmacro.h **** 
 172:FreeRTOS/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 173:FreeRTOS/ARM_CM3/portmacro.h **** 
 174:FreeRTOS/ARM_CM3/portmacro.h ****     portFORCE_INLINE static BaseType_t xPortIsInsideInterrupt( void )
 175:FreeRTOS/ARM_CM3/portmacro.h ****     {
 176:FreeRTOS/ARM_CM3/portmacro.h ****         uint32_t ulCurrentInterrupt;
 177:FreeRTOS/ARM_CM3/portmacro.h ****         BaseType_t xReturn;
 178:FreeRTOS/ARM_CM3/portmacro.h **** 
 179:FreeRTOS/ARM_CM3/portmacro.h ****         /* Obtain the number of the currently executing interrupt. */
 180:FreeRTOS/ARM_CM3/portmacro.h ****         __asm volatile ( "mrs %0, ipsr" : "=r" ( ulCurrentInterrupt )::"memory" );
 181:FreeRTOS/ARM_CM3/portmacro.h **** 
 182:FreeRTOS/ARM_CM3/portmacro.h ****         if( ulCurrentInterrupt == 0 )
 183:FreeRTOS/ARM_CM3/portmacro.h ****         {
 184:FreeRTOS/ARM_CM3/portmacro.h ****             xReturn = pdFALSE;
 185:FreeRTOS/ARM_CM3/portmacro.h ****         }
 186:FreeRTOS/ARM_CM3/portmacro.h ****         else
 187:FreeRTOS/ARM_CM3/portmacro.h ****         {
 188:FreeRTOS/ARM_CM3/portmacro.h ****             xReturn = pdTRUE;
 189:FreeRTOS/ARM_CM3/portmacro.h ****         }
 190:FreeRTOS/ARM_CM3/portmacro.h **** 
 191:FreeRTOS/ARM_CM3/portmacro.h ****         return xReturn;
 192:FreeRTOS/ARM_CM3/portmacro.h ****     }
 193:FreeRTOS/ARM_CM3/portmacro.h **** 
 194:FreeRTOS/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 195:FreeRTOS/ARM_CM3/portmacro.h **** 
 196:FreeRTOS/ARM_CM3/portmacro.h ****     portFORCE_INLINE static void vPortRaiseBASEPRI( void )
 197:FreeRTOS/ARM_CM3/portmacro.h ****     {
 198:FreeRTOS/ARM_CM3/portmacro.h ****         uint32_t ulNewBASEPRI;
 199:FreeRTOS/ARM_CM3/portmacro.h **** 
 200:FreeRTOS/ARM_CM3/portmacro.h ****         __asm volatile
  54              		.loc 2 200 0
  55              		.syntax unified
  56              	@ 200 "FreeRTOS/ARM_CM3/portmacro.h" 1
  57 0018 4FF05003 			mov r3, #80												
  58 001c 83F31188 		msr basepri, r3											
  59 0020 BFF36F8F 		isb														
  60 0024 BFF34F8F 		dsb														
  61              	
  62              	@ 0 "" 2
  63              	.LVL3:
  64              		.thumb
  65              		.syntax unified
  66              	.L3:
  67 0028 FEE7     		b	.L3
  68              	.L5:
ARM GAS  /tmp/ccrgBt0i.s 			page 38


  69              	.LBE153:
  70              	.LBE152:
1824:FreeRTOS/tasks.c ****         const TCB_t * const pxTCB = xTask;
  71              		.loc 1 1824 0
  72 002a 0020     		movs	r0, #0
  73              	.LVL4:
  74 002c 7047     		bx	lr
  75              	.LVL5:
  76              	.L6:
  77 002e 0020     		movs	r0, #0
  78              	.LVL6:
  79 0030 7047     		bx	lr
  80              	.LVL7:
  81              	.L7:
1842:FreeRTOS/tasks.c ****                 {
1843:FreeRTOS/tasks.c ****                     xReturn = pdTRUE;
  82              		.loc 1 1843 0
  83 0032 0120     		movs	r0, #1
  84              	.LVL8:
1844:FreeRTOS/tasks.c ****                 }
1845:FreeRTOS/tasks.c ****                 else
1846:FreeRTOS/tasks.c ****                 {
1847:FreeRTOS/tasks.c ****                     mtCOVERAGE_TEST_MARKER();
1848:FreeRTOS/tasks.c ****                 }
1849:FreeRTOS/tasks.c ****             }
1850:FreeRTOS/tasks.c ****             else
1851:FreeRTOS/tasks.c ****             {
1852:FreeRTOS/tasks.c ****                 mtCOVERAGE_TEST_MARKER();
1853:FreeRTOS/tasks.c ****             }
1854:FreeRTOS/tasks.c ****         }
1855:FreeRTOS/tasks.c ****         else
1856:FreeRTOS/tasks.c ****         {
1857:FreeRTOS/tasks.c ****             mtCOVERAGE_TEST_MARKER();
1858:FreeRTOS/tasks.c ****         }
1859:FreeRTOS/tasks.c **** 
1860:FreeRTOS/tasks.c ****         return xReturn;
1861:FreeRTOS/tasks.c ****     } /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
  85              		.loc 1 1861 0
  86 0034 7047     		bx	lr
  87              	.L10:
  88 0036 00BF     		.align	2
  89              	.L9:
  90 0038 00000000 		.word	.LANCHOR0
  91 003c 00000000 		.word	.LANCHOR1
  92              		.cfi_endproc
  93              	.LFE15:
  95              		.section	.text.prvResetNextTaskUnblockTime,"ax",%progbits
  96              		.align	1
  97              		.syntax unified
  98              		.thumb
  99              		.thumb_func
 100              		.fpu softvfp
 102              	prvResetNextTaskUnblockTime:
 103              	.LFB42:
1862:FreeRTOS/tasks.c **** 
1863:FreeRTOS/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1864:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
ARM GAS  /tmp/ccrgBt0i.s 			page 39


1865:FreeRTOS/tasks.c **** 
1866:FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1867:FreeRTOS/tasks.c **** 
1868:FreeRTOS/tasks.c ****     void vTaskResume( TaskHandle_t xTaskToResume )
1869:FreeRTOS/tasks.c ****     {
1870:FreeRTOS/tasks.c ****         TCB_t * const pxTCB = xTaskToResume;
1871:FreeRTOS/tasks.c **** 
1872:FreeRTOS/tasks.c ****         /* It does not make sense to resume the calling task. */
1873:FreeRTOS/tasks.c ****         configASSERT( xTaskToResume );
1874:FreeRTOS/tasks.c **** 
1875:FreeRTOS/tasks.c ****         /* The parameter cannot be NULL as it is impossible to resume the
1876:FreeRTOS/tasks.c ****          * currently executing task. */
1877:FreeRTOS/tasks.c ****         if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
1878:FreeRTOS/tasks.c ****         {
1879:FreeRTOS/tasks.c ****             taskENTER_CRITICAL();
1880:FreeRTOS/tasks.c ****             {
1881:FreeRTOS/tasks.c ****                 if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
1882:FreeRTOS/tasks.c ****                 {
1883:FreeRTOS/tasks.c ****                     traceTASK_RESUME( pxTCB );
1884:FreeRTOS/tasks.c **** 
1885:FreeRTOS/tasks.c ****                     /* The ready list can be accessed even if the scheduler is
1886:FreeRTOS/tasks.c ****                      * suspended because this is inside a critical section. */
1887:FreeRTOS/tasks.c ****                     ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
1888:FreeRTOS/tasks.c ****                     prvAddTaskToReadyList( pxTCB );
1889:FreeRTOS/tasks.c **** 
1890:FreeRTOS/tasks.c ****                     /* A higher priority task may have just been resumed. */
1891:FreeRTOS/tasks.c ****                     if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
1892:FreeRTOS/tasks.c ****                     {
1893:FreeRTOS/tasks.c ****                         /* This yield may not cause the task just resumed to run,
1894:FreeRTOS/tasks.c ****                          * but will leave the lists in the correct state for the
1895:FreeRTOS/tasks.c ****                          * next yield. */
1896:FreeRTOS/tasks.c ****                         taskYIELD_IF_USING_PREEMPTION();
1897:FreeRTOS/tasks.c ****                     }
1898:FreeRTOS/tasks.c ****                     else
1899:FreeRTOS/tasks.c ****                     {
1900:FreeRTOS/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
1901:FreeRTOS/tasks.c ****                     }
1902:FreeRTOS/tasks.c ****                 }
1903:FreeRTOS/tasks.c ****                 else
1904:FreeRTOS/tasks.c ****                 {
1905:FreeRTOS/tasks.c ****                     mtCOVERAGE_TEST_MARKER();
1906:FreeRTOS/tasks.c ****                 }
1907:FreeRTOS/tasks.c ****             }
1908:FreeRTOS/tasks.c ****             taskEXIT_CRITICAL();
1909:FreeRTOS/tasks.c ****         }
1910:FreeRTOS/tasks.c ****         else
1911:FreeRTOS/tasks.c ****         {
1912:FreeRTOS/tasks.c ****             mtCOVERAGE_TEST_MARKER();
1913:FreeRTOS/tasks.c ****         }
1914:FreeRTOS/tasks.c ****     }
1915:FreeRTOS/tasks.c **** 
1916:FreeRTOS/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1917:FreeRTOS/tasks.c **** 
1918:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1919:FreeRTOS/tasks.c **** 
1920:FreeRTOS/tasks.c **** #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
1921:FreeRTOS/tasks.c **** 
ARM GAS  /tmp/ccrgBt0i.s 			page 40


1922:FreeRTOS/tasks.c ****     BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
1923:FreeRTOS/tasks.c ****     {
1924:FreeRTOS/tasks.c ****         BaseType_t xYieldRequired = pdFALSE;
1925:FreeRTOS/tasks.c ****         TCB_t * const pxTCB = xTaskToResume;
1926:FreeRTOS/tasks.c ****         UBaseType_t uxSavedInterruptStatus;
1927:FreeRTOS/tasks.c **** 
1928:FreeRTOS/tasks.c ****         configASSERT( xTaskToResume );
1929:FreeRTOS/tasks.c **** 
1930:FreeRTOS/tasks.c ****         /* RTOS ports that support interrupt nesting have the concept of a
1931:FreeRTOS/tasks.c ****          * maximum  system call (or maximum API call) interrupt priority.
1932:FreeRTOS/tasks.c ****          * Interrupts that are  above the maximum system call priority are keep
1933:FreeRTOS/tasks.c ****          * permanently enabled, even when the RTOS kernel is in a critical section,
1934:FreeRTOS/tasks.c ****          * but cannot make any calls to FreeRTOS API functions.  If configASSERT()
1935:FreeRTOS/tasks.c ****          * is defined in FreeRTOSConfig.h then
1936:FreeRTOS/tasks.c ****          * portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1937:FreeRTOS/tasks.c ****          * failure if a FreeRTOS API function is called from an interrupt that has
1938:FreeRTOS/tasks.c ****          * been assigned a priority above the configured maximum system call
1939:FreeRTOS/tasks.c ****          * priority.  Only FreeRTOS functions that end in FromISR can be called
1940:FreeRTOS/tasks.c ****          * from interrupts  that have been assigned a priority at or (logically)
1941:FreeRTOS/tasks.c ****          * below the maximum system call interrupt priority.  FreeRTOS maintains a
1942:FreeRTOS/tasks.c ****          * separate interrupt safe API to ensure interrupt entry is as fast and as
1943:FreeRTOS/tasks.c ****          * simple as possible.  More information (albeit Cortex-M specific) is
1944:FreeRTOS/tasks.c ****          * provided on the following link:
1945:FreeRTOS/tasks.c ****          * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
1946:FreeRTOS/tasks.c ****         portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1947:FreeRTOS/tasks.c **** 
1948:FreeRTOS/tasks.c ****         uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1949:FreeRTOS/tasks.c ****         {
1950:FreeRTOS/tasks.c ****             if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
1951:FreeRTOS/tasks.c ****             {
1952:FreeRTOS/tasks.c ****                 traceTASK_RESUME_FROM_ISR( pxTCB );
1953:FreeRTOS/tasks.c **** 
1954:FreeRTOS/tasks.c ****                 /* Check the ready lists can be accessed. */
1955:FreeRTOS/tasks.c ****                 if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
1956:FreeRTOS/tasks.c ****                 {
1957:FreeRTOS/tasks.c ****                     /* Ready lists can be accessed so move the task from the
1958:FreeRTOS/tasks.c ****                      * suspended list to the ready list directly. */
1959:FreeRTOS/tasks.c ****                     if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
1960:FreeRTOS/tasks.c ****                     {
1961:FreeRTOS/tasks.c ****                         xYieldRequired = pdTRUE;
1962:FreeRTOS/tasks.c **** 
1963:FreeRTOS/tasks.c ****                         /* Mark that a yield is pending in case the user is not
1964:FreeRTOS/tasks.c ****                          * using the return value to initiate a context switch
1965:FreeRTOS/tasks.c ****                          * from the ISR using portYIELD_FROM_ISR. */
1966:FreeRTOS/tasks.c ****                         xYieldPending = pdTRUE;
1967:FreeRTOS/tasks.c ****                     }
1968:FreeRTOS/tasks.c ****                     else
1969:FreeRTOS/tasks.c ****                     {
1970:FreeRTOS/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
1971:FreeRTOS/tasks.c ****                     }
1972:FreeRTOS/tasks.c **** 
1973:FreeRTOS/tasks.c ****                     ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
1974:FreeRTOS/tasks.c ****                     prvAddTaskToReadyList( pxTCB );
1975:FreeRTOS/tasks.c ****                 }
1976:FreeRTOS/tasks.c ****                 else
1977:FreeRTOS/tasks.c ****                 {
1978:FreeRTOS/tasks.c ****                     /* The delayed or ready lists cannot be accessed so the task
ARM GAS  /tmp/ccrgBt0i.s 			page 41


1979:FreeRTOS/tasks.c ****                      * is held in the pending ready list until the scheduler is
1980:FreeRTOS/tasks.c ****                      * unsuspended. */
1981:FreeRTOS/tasks.c ****                     vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
1982:FreeRTOS/tasks.c ****                 }
1983:FreeRTOS/tasks.c ****             }
1984:FreeRTOS/tasks.c ****             else
1985:FreeRTOS/tasks.c ****             {
1986:FreeRTOS/tasks.c ****                 mtCOVERAGE_TEST_MARKER();
1987:FreeRTOS/tasks.c ****             }
1988:FreeRTOS/tasks.c ****         }
1989:FreeRTOS/tasks.c ****         portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1990:FreeRTOS/tasks.c **** 
1991:FreeRTOS/tasks.c ****         return xYieldRequired;
1992:FreeRTOS/tasks.c ****     }
1993:FreeRTOS/tasks.c **** 
1994:FreeRTOS/tasks.c **** #endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
1995:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1996:FreeRTOS/tasks.c **** 
1997:FreeRTOS/tasks.c **** void vTaskStartScheduler( void )
1998:FreeRTOS/tasks.c **** {
1999:FreeRTOS/tasks.c ****     BaseType_t xReturn;
2000:FreeRTOS/tasks.c **** 
2001:FreeRTOS/tasks.c ****     /* Add the idle task at the lowest priority. */
2002:FreeRTOS/tasks.c ****     #if ( configSUPPORT_STATIC_ALLOCATION == 1 )
2003:FreeRTOS/tasks.c ****         {
2004:FreeRTOS/tasks.c ****             StaticTask_t * pxIdleTaskTCBBuffer = NULL;
2005:FreeRTOS/tasks.c ****             StackType_t * pxIdleTaskStackBuffer = NULL;
2006:FreeRTOS/tasks.c ****             uint32_t ulIdleTaskStackSize;
2007:FreeRTOS/tasks.c **** 
2008:FreeRTOS/tasks.c ****             /* The Idle task is created using user provided RAM - obtain the
2009:FreeRTOS/tasks.c ****              * address of the RAM then create the idle task. */
2010:FreeRTOS/tasks.c ****             vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTas
2011:FreeRTOS/tasks.c ****             xIdleTaskHandle = xTaskCreateStatic( prvIdleTask,
2012:FreeRTOS/tasks.c ****                                                  configIDLE_TASK_NAME,
2013:FreeRTOS/tasks.c ****                                                  ulIdleTaskStackSize,
2014:FreeRTOS/tasks.c ****                                                  ( void * ) NULL,       /*lint !e961.  The cast is 
2015:FreeRTOS/tasks.c ****                                                  portPRIVILEGE_BIT,     /* In effect ( tskIDLE_PRIO
2016:FreeRTOS/tasks.c ****                                                  pxIdleTaskStackBuffer,
2017:FreeRTOS/tasks.c ****                                                  pxIdleTaskTCBBuffer ); /*lint !e961 MISRA exceptio
2018:FreeRTOS/tasks.c **** 
2019:FreeRTOS/tasks.c ****             if( xIdleTaskHandle != NULL )
2020:FreeRTOS/tasks.c ****             {
2021:FreeRTOS/tasks.c ****                 xReturn = pdPASS;
2022:FreeRTOS/tasks.c ****             }
2023:FreeRTOS/tasks.c ****             else
2024:FreeRTOS/tasks.c ****             {
2025:FreeRTOS/tasks.c ****                 xReturn = pdFAIL;
2026:FreeRTOS/tasks.c ****             }
2027:FreeRTOS/tasks.c ****         }
2028:FreeRTOS/tasks.c ****     #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
2029:FreeRTOS/tasks.c ****         {
2030:FreeRTOS/tasks.c ****             /* The Idle task is being created using dynamically allocated RAM. */
2031:FreeRTOS/tasks.c ****             xReturn = xTaskCreate( prvIdleTask,
2032:FreeRTOS/tasks.c ****                                    configIDLE_TASK_NAME,
2033:FreeRTOS/tasks.c ****                                    configMINIMAL_STACK_SIZE,
2034:FreeRTOS/tasks.c ****                                    ( void * ) NULL,
2035:FreeRTOS/tasks.c ****                                    portPRIVILEGE_BIT,  /* In effect ( tskIDLE_PRIORITY | portPRIVIL
ARM GAS  /tmp/ccrgBt0i.s 			page 42


2036:FreeRTOS/tasks.c ****                                    &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as i
2037:FreeRTOS/tasks.c ****         }
2038:FreeRTOS/tasks.c ****     #endif /* configSUPPORT_STATIC_ALLOCATION */
2039:FreeRTOS/tasks.c **** 
2040:FreeRTOS/tasks.c ****     #if ( configUSE_TIMERS == 1 )
2041:FreeRTOS/tasks.c ****         {
2042:FreeRTOS/tasks.c ****             if( xReturn == pdPASS )
2043:FreeRTOS/tasks.c ****             {
2044:FreeRTOS/tasks.c ****                 xReturn = xTimerCreateTimerTask();
2045:FreeRTOS/tasks.c ****             }
2046:FreeRTOS/tasks.c ****             else
2047:FreeRTOS/tasks.c ****             {
2048:FreeRTOS/tasks.c ****                 mtCOVERAGE_TEST_MARKER();
2049:FreeRTOS/tasks.c ****             }
2050:FreeRTOS/tasks.c ****         }
2051:FreeRTOS/tasks.c ****     #endif /* configUSE_TIMERS */
2052:FreeRTOS/tasks.c **** 
2053:FreeRTOS/tasks.c ****     if( xReturn == pdPASS )
2054:FreeRTOS/tasks.c ****     {
2055:FreeRTOS/tasks.c ****         /* freertos_tasks_c_additions_init() should only be called if the user
2056:FreeRTOS/tasks.c ****          * definable macro FREERTOS_TASKS_C_ADDITIONS_INIT() is defined, as that is
2057:FreeRTOS/tasks.c ****          * the only macro called by the function. */
2058:FreeRTOS/tasks.c ****         #ifdef FREERTOS_TASKS_C_ADDITIONS_INIT
2059:FreeRTOS/tasks.c ****             {
2060:FreeRTOS/tasks.c ****                 freertos_tasks_c_additions_init();
2061:FreeRTOS/tasks.c ****             }
2062:FreeRTOS/tasks.c ****         #endif
2063:FreeRTOS/tasks.c **** 
2064:FreeRTOS/tasks.c ****         /* Interrupts are turned off here, to ensure a tick does not occur
2065:FreeRTOS/tasks.c ****          * before or during the call to xPortStartScheduler().  The stacks of
2066:FreeRTOS/tasks.c ****          * the created tasks contain a status word with interrupts switched on
2067:FreeRTOS/tasks.c ****          * so interrupts will automatically get re-enabled when the first task
2068:FreeRTOS/tasks.c ****          * starts to run. */
2069:FreeRTOS/tasks.c ****         portDISABLE_INTERRUPTS();
2070:FreeRTOS/tasks.c **** 
2071:FreeRTOS/tasks.c ****         #if ( configUSE_NEWLIB_REENTRANT == 1 )
2072:FreeRTOS/tasks.c ****             {
2073:FreeRTOS/tasks.c ****                 /* Switch Newlib's _impure_ptr variable to point to the _reent
2074:FreeRTOS/tasks.c ****                  * structure specific to the task that will run first.
2075:FreeRTOS/tasks.c ****                  * See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html
2076:FreeRTOS/tasks.c ****                  * for additional information. */
2077:FreeRTOS/tasks.c ****                 _impure_ptr = &( pxCurrentTCB->xNewLib_reent );
2078:FreeRTOS/tasks.c ****             }
2079:FreeRTOS/tasks.c ****         #endif /* configUSE_NEWLIB_REENTRANT */
2080:FreeRTOS/tasks.c **** 
2081:FreeRTOS/tasks.c ****         xNextTaskUnblockTime = portMAX_DELAY;
2082:FreeRTOS/tasks.c ****         xSchedulerRunning = pdTRUE;
2083:FreeRTOS/tasks.c ****         xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
2084:FreeRTOS/tasks.c **** 
2085:FreeRTOS/tasks.c ****         /* If configGENERATE_RUN_TIME_STATS is defined then the following
2086:FreeRTOS/tasks.c ****          * macro must be defined to configure the timer/counter used to generate
2087:FreeRTOS/tasks.c ****          * the run time counter time base.   NOTE:  If configGENERATE_RUN_TIME_STATS
2088:FreeRTOS/tasks.c ****          * is set to 0 and the following line fails to build then ensure you do not
2089:FreeRTOS/tasks.c ****          * have portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() defined in your
2090:FreeRTOS/tasks.c ****          * FreeRTOSConfig.h file. */
2091:FreeRTOS/tasks.c ****         portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
2092:FreeRTOS/tasks.c **** 
ARM GAS  /tmp/ccrgBt0i.s 			page 43


2093:FreeRTOS/tasks.c ****         traceTASK_SWITCHED_IN();
2094:FreeRTOS/tasks.c **** 
2095:FreeRTOS/tasks.c ****         /* Setting up the timer tick is hardware specific and thus in the
2096:FreeRTOS/tasks.c ****          * portable interface. */
2097:FreeRTOS/tasks.c ****         if( xPortStartScheduler() != pdFALSE )
2098:FreeRTOS/tasks.c ****         {
2099:FreeRTOS/tasks.c ****             /* Should not reach here as if the scheduler is running the
2100:FreeRTOS/tasks.c ****              * function will not return. */
2101:FreeRTOS/tasks.c ****         }
2102:FreeRTOS/tasks.c ****         else
2103:FreeRTOS/tasks.c ****         {
2104:FreeRTOS/tasks.c ****             /* Should only reach here if a task calls xTaskEndScheduler(). */
2105:FreeRTOS/tasks.c ****         }
2106:FreeRTOS/tasks.c ****     }
2107:FreeRTOS/tasks.c ****     else
2108:FreeRTOS/tasks.c ****     {
2109:FreeRTOS/tasks.c ****         /* This line will only be reached if the kernel could not be started,
2110:FreeRTOS/tasks.c ****          * because there was not enough FreeRTOS heap to create the idle task
2111:FreeRTOS/tasks.c ****          * or the timer task. */
2112:FreeRTOS/tasks.c ****         configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
2113:FreeRTOS/tasks.c ****     }
2114:FreeRTOS/tasks.c **** 
2115:FreeRTOS/tasks.c ****     /* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
2116:FreeRTOS/tasks.c ****      * meaning xIdleTaskHandle is not used anywhere else. */
2117:FreeRTOS/tasks.c ****     ( void ) xIdleTaskHandle;
2118:FreeRTOS/tasks.c **** 
2119:FreeRTOS/tasks.c ****     /* OpenOCD makes use of uxTopUsedPriority for thread debugging. Prevent uxTopUsedPriority
2120:FreeRTOS/tasks.c ****      * from getting optimized out as it is no longer used by the kernel. */
2121:FreeRTOS/tasks.c ****     ( void ) uxTopUsedPriority;
2122:FreeRTOS/tasks.c **** }
2123:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2124:FreeRTOS/tasks.c **** 
2125:FreeRTOS/tasks.c **** void vTaskEndScheduler( void )
2126:FreeRTOS/tasks.c **** {
2127:FreeRTOS/tasks.c ****     /* Stop the scheduler interrupts and call the portable scheduler end
2128:FreeRTOS/tasks.c ****      * routine so the original ISRs can be restored if necessary.  The port
2129:FreeRTOS/tasks.c ****      * layer must ensure interrupts enable  bit is left in the correct state. */
2130:FreeRTOS/tasks.c ****     portDISABLE_INTERRUPTS();
2131:FreeRTOS/tasks.c ****     xSchedulerRunning = pdFALSE;
2132:FreeRTOS/tasks.c ****     vPortEndScheduler();
2133:FreeRTOS/tasks.c **** }
2134:FreeRTOS/tasks.c **** /*----------------------------------------------------------*/
2135:FreeRTOS/tasks.c **** 
2136:FreeRTOS/tasks.c **** void vTaskSuspendAll( void )
2137:FreeRTOS/tasks.c **** {
2138:FreeRTOS/tasks.c ****     /* A critical section is not required as the variable is of type
2139:FreeRTOS/tasks.c ****      * BaseType_t.  Please read Richard Barry's reply in the following link to a
2140:FreeRTOS/tasks.c ****      * post in the FreeRTOS support forum before reporting this as a bug! -
2141:FreeRTOS/tasks.c ****      * https://goo.gl/wu4acr */
2142:FreeRTOS/tasks.c **** 
2143:FreeRTOS/tasks.c ****     /* portSOFTWARE_BARRIER() is only implemented for emulated/simulated ports that
2144:FreeRTOS/tasks.c ****      * do not otherwise exhibit real time behaviour. */
2145:FreeRTOS/tasks.c ****     portSOFTWARE_BARRIER();
2146:FreeRTOS/tasks.c **** 
2147:FreeRTOS/tasks.c ****     /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
2148:FreeRTOS/tasks.c ****      * is used to allow calls to vTaskSuspendAll() to nest. */
2149:FreeRTOS/tasks.c ****     ++uxSchedulerSuspended;
ARM GAS  /tmp/ccrgBt0i.s 			page 44


2150:FreeRTOS/tasks.c **** 
2151:FreeRTOS/tasks.c ****     /* Enforces ordering for ports and optimised compilers that may otherwise place
2152:FreeRTOS/tasks.c ****      * the above increment elsewhere. */
2153:FreeRTOS/tasks.c ****     portMEMORY_BARRIER();
2154:FreeRTOS/tasks.c **** }
2155:FreeRTOS/tasks.c **** /*----------------------------------------------------------*/
2156:FreeRTOS/tasks.c **** 
2157:FreeRTOS/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
2158:FreeRTOS/tasks.c **** 
2159:FreeRTOS/tasks.c ****     static TickType_t prvGetExpectedIdleTime( void )
2160:FreeRTOS/tasks.c ****     {
2161:FreeRTOS/tasks.c ****         TickType_t xReturn;
2162:FreeRTOS/tasks.c ****         UBaseType_t uxHigherPriorityReadyTasks = pdFALSE;
2163:FreeRTOS/tasks.c **** 
2164:FreeRTOS/tasks.c ****         /* uxHigherPriorityReadyTasks takes care of the case where
2165:FreeRTOS/tasks.c ****          * configUSE_PREEMPTION is 0, so there may be tasks above the idle priority
2166:FreeRTOS/tasks.c ****          * task that are in the Ready state, even though the idle task is
2167:FreeRTOS/tasks.c ****          * running. */
2168:FreeRTOS/tasks.c ****         #if ( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
2169:FreeRTOS/tasks.c ****             {
2170:FreeRTOS/tasks.c ****                 if( uxTopReadyPriority > tskIDLE_PRIORITY )
2171:FreeRTOS/tasks.c ****                 {
2172:FreeRTOS/tasks.c ****                     uxHigherPriorityReadyTasks = pdTRUE;
2173:FreeRTOS/tasks.c ****                 }
2174:FreeRTOS/tasks.c ****             }
2175:FreeRTOS/tasks.c ****         #else
2176:FreeRTOS/tasks.c ****             {
2177:FreeRTOS/tasks.c ****                 const UBaseType_t uxLeastSignificantBit = ( UBaseType_t ) 0x01;
2178:FreeRTOS/tasks.c **** 
2179:FreeRTOS/tasks.c ****                 /* When port optimised task selection is used the uxTopReadyPriority
2180:FreeRTOS/tasks.c ****                  * variable is used as a bit map.  If bits other than the least
2181:FreeRTOS/tasks.c ****                  * significant bit are set then there are tasks that have a priority
2182:FreeRTOS/tasks.c ****                  * above the idle priority that are in the Ready state.  This takes
2183:FreeRTOS/tasks.c ****                  * care of the case where the co-operative scheduler is in use. */
2184:FreeRTOS/tasks.c ****                 if( uxTopReadyPriority > uxLeastSignificantBit )
2185:FreeRTOS/tasks.c ****                 {
2186:FreeRTOS/tasks.c ****                     uxHigherPriorityReadyTasks = pdTRUE;
2187:FreeRTOS/tasks.c ****                 }
2188:FreeRTOS/tasks.c ****             }
2189:FreeRTOS/tasks.c ****         #endif /* if ( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 ) */
2190:FreeRTOS/tasks.c **** 
2191:FreeRTOS/tasks.c ****         if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
2192:FreeRTOS/tasks.c ****         {
2193:FreeRTOS/tasks.c ****             xReturn = 0;
2194:FreeRTOS/tasks.c ****         }
2195:FreeRTOS/tasks.c ****         else if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > 1 )
2196:FreeRTOS/tasks.c ****         {
2197:FreeRTOS/tasks.c ****             /* There are other idle priority tasks in the ready state.  If
2198:FreeRTOS/tasks.c ****              * time slicing is used then the very next tick interrupt must be
2199:FreeRTOS/tasks.c ****              * processed. */
2200:FreeRTOS/tasks.c ****             xReturn = 0;
2201:FreeRTOS/tasks.c ****         }
2202:FreeRTOS/tasks.c ****         else if( uxHigherPriorityReadyTasks != pdFALSE )
2203:FreeRTOS/tasks.c ****         {
2204:FreeRTOS/tasks.c ****             /* There are tasks in the Ready state that have a priority above the
2205:FreeRTOS/tasks.c ****              * idle priority.  This path can only be reached if
2206:FreeRTOS/tasks.c ****              * configUSE_PREEMPTION is 0. */
ARM GAS  /tmp/ccrgBt0i.s 			page 45


2207:FreeRTOS/tasks.c ****             xReturn = 0;
2208:FreeRTOS/tasks.c ****         }
2209:FreeRTOS/tasks.c ****         else
2210:FreeRTOS/tasks.c ****         {
2211:FreeRTOS/tasks.c ****             xReturn = xNextTaskUnblockTime - xTickCount;
2212:FreeRTOS/tasks.c ****         }
2213:FreeRTOS/tasks.c **** 
2214:FreeRTOS/tasks.c ****         return xReturn;
2215:FreeRTOS/tasks.c ****     }
2216:FreeRTOS/tasks.c **** 
2217:FreeRTOS/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
2218:FreeRTOS/tasks.c **** /*----------------------------------------------------------*/
2219:FreeRTOS/tasks.c **** 
2220:FreeRTOS/tasks.c **** BaseType_t xTaskResumeAll( void )
2221:FreeRTOS/tasks.c **** {
2222:FreeRTOS/tasks.c ****     TCB_t * pxTCB = NULL;
2223:FreeRTOS/tasks.c ****     BaseType_t xAlreadyYielded = pdFALSE;
2224:FreeRTOS/tasks.c **** 
2225:FreeRTOS/tasks.c ****     /* If uxSchedulerSuspended is zero then this function does not match a
2226:FreeRTOS/tasks.c ****      * previous call to vTaskSuspendAll(). */
2227:FreeRTOS/tasks.c ****     configASSERT( uxSchedulerSuspended );
2228:FreeRTOS/tasks.c **** 
2229:FreeRTOS/tasks.c ****     /* It is possible that an ISR caused a task to be removed from an event
2230:FreeRTOS/tasks.c ****      * list while the scheduler was suspended.  If this was the case then the
2231:FreeRTOS/tasks.c ****      * removed task will have been added to the xPendingReadyList.  Once the
2232:FreeRTOS/tasks.c ****      * scheduler has been resumed it is safe to move all the pending ready
2233:FreeRTOS/tasks.c ****      * tasks from this list into their appropriate ready list. */
2234:FreeRTOS/tasks.c ****     taskENTER_CRITICAL();
2235:FreeRTOS/tasks.c ****     {
2236:FreeRTOS/tasks.c ****         --uxSchedulerSuspended;
2237:FreeRTOS/tasks.c **** 
2238:FreeRTOS/tasks.c ****         if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
2239:FreeRTOS/tasks.c ****         {
2240:FreeRTOS/tasks.c ****             if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
2241:FreeRTOS/tasks.c ****             {
2242:FreeRTOS/tasks.c ****                 /* Move any readied tasks from the pending list into the
2243:FreeRTOS/tasks.c ****                  * appropriate ready list. */
2244:FreeRTOS/tasks.c ****                 while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
2245:FreeRTOS/tasks.c ****                 {
2246:FreeRTOS/tasks.c ****                     pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 vo
2247:FreeRTOS/tasks.c ****                     listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
2248:FreeRTOS/tasks.c ****                     portMEMORY_BARRIER();
2249:FreeRTOS/tasks.c ****                     listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
2250:FreeRTOS/tasks.c ****                     prvAddTaskToReadyList( pxTCB );
2251:FreeRTOS/tasks.c **** 
2252:FreeRTOS/tasks.c ****                     /* If the moved task has a priority higher than or equal to
2253:FreeRTOS/tasks.c ****                      * the current task then a yield must be performed. */
2254:FreeRTOS/tasks.c ****                     if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
2255:FreeRTOS/tasks.c ****                     {
2256:FreeRTOS/tasks.c ****                         xYieldPending = pdTRUE;
2257:FreeRTOS/tasks.c ****                     }
2258:FreeRTOS/tasks.c ****                     else
2259:FreeRTOS/tasks.c ****                     {
2260:FreeRTOS/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
2261:FreeRTOS/tasks.c ****                     }
2262:FreeRTOS/tasks.c ****                 }
2263:FreeRTOS/tasks.c **** 
ARM GAS  /tmp/ccrgBt0i.s 			page 46


2264:FreeRTOS/tasks.c ****                 if( pxTCB != NULL )
2265:FreeRTOS/tasks.c ****                 {
2266:FreeRTOS/tasks.c ****                     /* A task was unblocked while the scheduler was suspended,
2267:FreeRTOS/tasks.c ****                      * which may have prevented the next unblock time from being
2268:FreeRTOS/tasks.c ****                      * re-calculated, in which case re-calculate it now.  Mainly
2269:FreeRTOS/tasks.c ****                      * important for low power tickless implementations, where
2270:FreeRTOS/tasks.c ****                      * this can prevent an unnecessary exit from low power
2271:FreeRTOS/tasks.c ****                      * state. */
2272:FreeRTOS/tasks.c ****                     prvResetNextTaskUnblockTime();
2273:FreeRTOS/tasks.c ****                 }
2274:FreeRTOS/tasks.c **** 
2275:FreeRTOS/tasks.c ****                 /* If any ticks occurred while the scheduler was suspended then
2276:FreeRTOS/tasks.c ****                  * they should be processed now.  This ensures the tick count does
2277:FreeRTOS/tasks.c ****                  * not  slip, and that any delayed tasks are resumed at the correct
2278:FreeRTOS/tasks.c ****                  * time. */
2279:FreeRTOS/tasks.c ****                 {
2280:FreeRTOS/tasks.c ****                     TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
2281:FreeRTOS/tasks.c **** 
2282:FreeRTOS/tasks.c ****                     if( xPendedCounts > ( TickType_t ) 0U )
2283:FreeRTOS/tasks.c ****                     {
2284:FreeRTOS/tasks.c ****                         do
2285:FreeRTOS/tasks.c ****                         {
2286:FreeRTOS/tasks.c ****                             if( xTaskIncrementTick() != pdFALSE )
2287:FreeRTOS/tasks.c ****                             {
2288:FreeRTOS/tasks.c ****                                 xYieldPending = pdTRUE;
2289:FreeRTOS/tasks.c ****                             }
2290:FreeRTOS/tasks.c ****                             else
2291:FreeRTOS/tasks.c ****                             {
2292:FreeRTOS/tasks.c ****                                 mtCOVERAGE_TEST_MARKER();
2293:FreeRTOS/tasks.c ****                             }
2294:FreeRTOS/tasks.c **** 
2295:FreeRTOS/tasks.c ****                             --xPendedCounts;
2296:FreeRTOS/tasks.c ****                         } while( xPendedCounts > ( TickType_t ) 0U );
2297:FreeRTOS/tasks.c **** 
2298:FreeRTOS/tasks.c ****                         xPendedTicks = 0;
2299:FreeRTOS/tasks.c ****                     }
2300:FreeRTOS/tasks.c ****                     else
2301:FreeRTOS/tasks.c ****                     {
2302:FreeRTOS/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
2303:FreeRTOS/tasks.c ****                     }
2304:FreeRTOS/tasks.c ****                 }
2305:FreeRTOS/tasks.c **** 
2306:FreeRTOS/tasks.c ****                 if( xYieldPending != pdFALSE )
2307:FreeRTOS/tasks.c ****                 {
2308:FreeRTOS/tasks.c ****                     #if ( configUSE_PREEMPTION != 0 )
2309:FreeRTOS/tasks.c ****                         {
2310:FreeRTOS/tasks.c ****                             xAlreadyYielded = pdTRUE;
2311:FreeRTOS/tasks.c ****                         }
2312:FreeRTOS/tasks.c ****                     #endif
2313:FreeRTOS/tasks.c ****                     taskYIELD_IF_USING_PREEMPTION();
2314:FreeRTOS/tasks.c ****                 }
2315:FreeRTOS/tasks.c ****                 else
2316:FreeRTOS/tasks.c ****                 {
2317:FreeRTOS/tasks.c ****                     mtCOVERAGE_TEST_MARKER();
2318:FreeRTOS/tasks.c ****                 }
2319:FreeRTOS/tasks.c ****             }
2320:FreeRTOS/tasks.c ****         }
ARM GAS  /tmp/ccrgBt0i.s 			page 47


2321:FreeRTOS/tasks.c ****         else
2322:FreeRTOS/tasks.c ****         {
2323:FreeRTOS/tasks.c ****             mtCOVERAGE_TEST_MARKER();
2324:FreeRTOS/tasks.c ****         }
2325:FreeRTOS/tasks.c ****     }
2326:FreeRTOS/tasks.c ****     taskEXIT_CRITICAL();
2327:FreeRTOS/tasks.c **** 
2328:FreeRTOS/tasks.c ****     return xAlreadyYielded;
2329:FreeRTOS/tasks.c **** }
2330:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2331:FreeRTOS/tasks.c **** 
2332:FreeRTOS/tasks.c **** TickType_t xTaskGetTickCount( void )
2333:FreeRTOS/tasks.c **** {
2334:FreeRTOS/tasks.c ****     TickType_t xTicks;
2335:FreeRTOS/tasks.c **** 
2336:FreeRTOS/tasks.c ****     /* Critical section required if running on a 16 bit processor. */
2337:FreeRTOS/tasks.c ****     portTICK_TYPE_ENTER_CRITICAL();
2338:FreeRTOS/tasks.c ****     {
2339:FreeRTOS/tasks.c ****         xTicks = xTickCount;
2340:FreeRTOS/tasks.c ****     }
2341:FreeRTOS/tasks.c ****     portTICK_TYPE_EXIT_CRITICAL();
2342:FreeRTOS/tasks.c **** 
2343:FreeRTOS/tasks.c ****     return xTicks;
2344:FreeRTOS/tasks.c **** }
2345:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2346:FreeRTOS/tasks.c **** 
2347:FreeRTOS/tasks.c **** TickType_t xTaskGetTickCountFromISR( void )
2348:FreeRTOS/tasks.c **** {
2349:FreeRTOS/tasks.c ****     TickType_t xReturn;
2350:FreeRTOS/tasks.c ****     UBaseType_t uxSavedInterruptStatus;
2351:FreeRTOS/tasks.c **** 
2352:FreeRTOS/tasks.c ****     /* RTOS ports that support interrupt nesting have the concept of a maximum
2353:FreeRTOS/tasks.c ****      * system call (or maximum API call) interrupt priority.  Interrupts that are
2354:FreeRTOS/tasks.c ****      * above the maximum system call priority are kept permanently enabled, even
2355:FreeRTOS/tasks.c ****      * when the RTOS kernel is in a critical section, but cannot make any calls to
2356:FreeRTOS/tasks.c ****      * FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
2357:FreeRTOS/tasks.c ****      * then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
2358:FreeRTOS/tasks.c ****      * failure if a FreeRTOS API function is called from an interrupt that has been
2359:FreeRTOS/tasks.c ****      * assigned a priority above the configured maximum system call priority.
2360:FreeRTOS/tasks.c ****      * Only FreeRTOS functions that end in FromISR can be called from interrupts
2361:FreeRTOS/tasks.c ****      * that have been assigned a priority at or (logically) below the maximum
2362:FreeRTOS/tasks.c ****      * system call  interrupt priority.  FreeRTOS maintains a separate interrupt
2363:FreeRTOS/tasks.c ****      * safe API to ensure interrupt entry is as fast and as simple as possible.
2364:FreeRTOS/tasks.c ****      * More information (albeit Cortex-M specific) is provided on the following
2365:FreeRTOS/tasks.c ****      * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
2366:FreeRTOS/tasks.c ****     portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
2367:FreeRTOS/tasks.c **** 
2368:FreeRTOS/tasks.c ****     uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
2369:FreeRTOS/tasks.c ****     {
2370:FreeRTOS/tasks.c ****         xReturn = xTickCount;
2371:FreeRTOS/tasks.c ****     }
2372:FreeRTOS/tasks.c ****     portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
2373:FreeRTOS/tasks.c **** 
2374:FreeRTOS/tasks.c ****     return xReturn;
2375:FreeRTOS/tasks.c **** }
2376:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2377:FreeRTOS/tasks.c **** 
ARM GAS  /tmp/ccrgBt0i.s 			page 48


2378:FreeRTOS/tasks.c **** UBaseType_t uxTaskGetNumberOfTasks( void )
2379:FreeRTOS/tasks.c **** {
2380:FreeRTOS/tasks.c ****     /* A critical section is not required because the variables are of type
2381:FreeRTOS/tasks.c ****      * BaseType_t. */
2382:FreeRTOS/tasks.c ****     return uxCurrentNumberOfTasks;
2383:FreeRTOS/tasks.c **** }
2384:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2385:FreeRTOS/tasks.c **** 
2386:FreeRTOS/tasks.c **** char * pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed f
2387:FreeRTOS/tasks.c **** {
2388:FreeRTOS/tasks.c ****     TCB_t * pxTCB;
2389:FreeRTOS/tasks.c **** 
2390:FreeRTOS/tasks.c ****     /* If null is passed in here then the name of the calling task is being
2391:FreeRTOS/tasks.c ****      * queried. */
2392:FreeRTOS/tasks.c ****     pxTCB = prvGetTCBFromHandle( xTaskToQuery );
2393:FreeRTOS/tasks.c ****     configASSERT( pxTCB );
2394:FreeRTOS/tasks.c ****     return &( pxTCB->pcTaskName[ 0 ] );
2395:FreeRTOS/tasks.c **** }
2396:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2397:FreeRTOS/tasks.c **** 
2398:FreeRTOS/tasks.c **** #if ( INCLUDE_xTaskGetHandle == 1 )
2399:FreeRTOS/tasks.c **** 
2400:FreeRTOS/tasks.c ****     static TCB_t * prvSearchForNameWithinSingleList( List_t * pxList,
2401:FreeRTOS/tasks.c ****                                                      const char pcNameToQuery[] )
2402:FreeRTOS/tasks.c ****     {
2403:FreeRTOS/tasks.c ****         TCB_t * pxNextTCB, * pxFirstTCB, * pxReturn = NULL;
2404:FreeRTOS/tasks.c ****         UBaseType_t x;
2405:FreeRTOS/tasks.c ****         char cNextChar;
2406:FreeRTOS/tasks.c ****         BaseType_t xBreakLoop;
2407:FreeRTOS/tasks.c **** 
2408:FreeRTOS/tasks.c ****         /* This function is called with the scheduler suspended. */
2409:FreeRTOS/tasks.c **** 
2410:FreeRTOS/tasks.c ****         if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
2411:FreeRTOS/tasks.c ****         {
2412:FreeRTOS/tasks.c ****             listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList ); /*lint !e9079 void * is used as this
2413:FreeRTOS/tasks.c **** 
2414:FreeRTOS/tasks.c ****             do
2415:FreeRTOS/tasks.c ****             {
2416:FreeRTOS/tasks.c ****                 listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList ); /*lint !e9079 void * is used as t
2417:FreeRTOS/tasks.c **** 
2418:FreeRTOS/tasks.c ****                 /* Check each character in the name looking for a match or
2419:FreeRTOS/tasks.c ****                  * mismatch. */
2420:FreeRTOS/tasks.c ****                 xBreakLoop = pdFALSE;
2421:FreeRTOS/tasks.c **** 
2422:FreeRTOS/tasks.c ****                 for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
2423:FreeRTOS/tasks.c ****                 {
2424:FreeRTOS/tasks.c ****                     cNextChar = pxNextTCB->pcTaskName[ x ];
2425:FreeRTOS/tasks.c **** 
2426:FreeRTOS/tasks.c ****                     if( cNextChar != pcNameToQuery[ x ] )
2427:FreeRTOS/tasks.c ****                     {
2428:FreeRTOS/tasks.c ****                         /* Characters didn't match. */
2429:FreeRTOS/tasks.c ****                         xBreakLoop = pdTRUE;
2430:FreeRTOS/tasks.c ****                     }
2431:FreeRTOS/tasks.c ****                     else if( cNextChar == ( char ) 0x00 )
2432:FreeRTOS/tasks.c ****                     {
2433:FreeRTOS/tasks.c ****                         /* Both strings terminated, a match must have been
2434:FreeRTOS/tasks.c ****                          * found. */
ARM GAS  /tmp/ccrgBt0i.s 			page 49


2435:FreeRTOS/tasks.c ****                         pxReturn = pxNextTCB;
2436:FreeRTOS/tasks.c ****                         xBreakLoop = pdTRUE;
2437:FreeRTOS/tasks.c ****                     }
2438:FreeRTOS/tasks.c ****                     else
2439:FreeRTOS/tasks.c ****                     {
2440:FreeRTOS/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
2441:FreeRTOS/tasks.c ****                     }
2442:FreeRTOS/tasks.c **** 
2443:FreeRTOS/tasks.c ****                     if( xBreakLoop != pdFALSE )
2444:FreeRTOS/tasks.c ****                     {
2445:FreeRTOS/tasks.c ****                         break;
2446:FreeRTOS/tasks.c ****                     }
2447:FreeRTOS/tasks.c ****                 }
2448:FreeRTOS/tasks.c **** 
2449:FreeRTOS/tasks.c ****                 if( pxReturn != NULL )
2450:FreeRTOS/tasks.c ****                 {
2451:FreeRTOS/tasks.c ****                     /* The handle has been found. */
2452:FreeRTOS/tasks.c ****                     break;
2453:FreeRTOS/tasks.c ****                 }
2454:FreeRTOS/tasks.c ****             } while( pxNextTCB != pxFirstTCB );
2455:FreeRTOS/tasks.c ****         }
2456:FreeRTOS/tasks.c ****         else
2457:FreeRTOS/tasks.c ****         {
2458:FreeRTOS/tasks.c ****             mtCOVERAGE_TEST_MARKER();
2459:FreeRTOS/tasks.c ****         }
2460:FreeRTOS/tasks.c **** 
2461:FreeRTOS/tasks.c ****         return pxReturn;
2462:FreeRTOS/tasks.c ****     }
2463:FreeRTOS/tasks.c **** 
2464:FreeRTOS/tasks.c **** #endif /* INCLUDE_xTaskGetHandle */
2465:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2466:FreeRTOS/tasks.c **** 
2467:FreeRTOS/tasks.c **** #if ( INCLUDE_xTaskGetHandle == 1 )
2468:FreeRTOS/tasks.c **** 
2469:FreeRTOS/tasks.c ****     TaskHandle_t xTaskGetHandle( const char * pcNameToQuery ) /*lint !e971 Unqualified char types a
2470:FreeRTOS/tasks.c ****     {
2471:FreeRTOS/tasks.c ****         UBaseType_t uxQueue = configMAX_PRIORITIES;
2472:FreeRTOS/tasks.c ****         TCB_t * pxTCB;
2473:FreeRTOS/tasks.c **** 
2474:FreeRTOS/tasks.c ****         /* Task names will be truncated to configMAX_TASK_NAME_LEN - 1 bytes. */
2475:FreeRTOS/tasks.c ****         configASSERT( strlen( pcNameToQuery ) < configMAX_TASK_NAME_LEN );
2476:FreeRTOS/tasks.c **** 
2477:FreeRTOS/tasks.c ****         vTaskSuspendAll();
2478:FreeRTOS/tasks.c ****         {
2479:FreeRTOS/tasks.c ****             /* Search the ready lists. */
2480:FreeRTOS/tasks.c ****             do
2481:FreeRTOS/tasks.c ****             {
2482:FreeRTOS/tasks.c ****                 uxQueue--;
2483:FreeRTOS/tasks.c ****                 pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) &( pxReadyTasksLists[ uxQueu
2484:FreeRTOS/tasks.c **** 
2485:FreeRTOS/tasks.c ****                 if( pxTCB != NULL )
2486:FreeRTOS/tasks.c ****                 {
2487:FreeRTOS/tasks.c ****                     /* Found the handle. */
2488:FreeRTOS/tasks.c ****                     break;
2489:FreeRTOS/tasks.c ****                 }
2490:FreeRTOS/tasks.c ****             } while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as 
2491:FreeRTOS/tasks.c **** 
ARM GAS  /tmp/ccrgBt0i.s 			page 50


2492:FreeRTOS/tasks.c ****             /* Search the delayed lists. */
2493:FreeRTOS/tasks.c ****             if( pxTCB == NULL )
2494:FreeRTOS/tasks.c ****             {
2495:FreeRTOS/tasks.c ****                 pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) pxDelayedTaskList, pcNameToQ
2496:FreeRTOS/tasks.c ****             }
2497:FreeRTOS/tasks.c **** 
2498:FreeRTOS/tasks.c ****             if( pxTCB == NULL )
2499:FreeRTOS/tasks.c ****             {
2500:FreeRTOS/tasks.c ****                 pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) pxOverflowDelayedTaskList, p
2501:FreeRTOS/tasks.c ****             }
2502:FreeRTOS/tasks.c **** 
2503:FreeRTOS/tasks.c ****             #if ( INCLUDE_vTaskSuspend == 1 )
2504:FreeRTOS/tasks.c ****                 {
2505:FreeRTOS/tasks.c ****                     if( pxTCB == NULL )
2506:FreeRTOS/tasks.c ****                     {
2507:FreeRTOS/tasks.c ****                         /* Search the suspended list. */
2508:FreeRTOS/tasks.c ****                         pxTCB = prvSearchForNameWithinSingleList( &xSuspendedTaskList, pcNameToQuer
2509:FreeRTOS/tasks.c ****                     }
2510:FreeRTOS/tasks.c ****                 }
2511:FreeRTOS/tasks.c ****             #endif
2512:FreeRTOS/tasks.c **** 
2513:FreeRTOS/tasks.c ****             #if ( INCLUDE_vTaskDelete == 1 )
2514:FreeRTOS/tasks.c ****                 {
2515:FreeRTOS/tasks.c ****                     if( pxTCB == NULL )
2516:FreeRTOS/tasks.c ****                     {
2517:FreeRTOS/tasks.c ****                         /* Search the deleted list. */
2518:FreeRTOS/tasks.c ****                         pxTCB = prvSearchForNameWithinSingleList( &xTasksWaitingTermination, pcName
2519:FreeRTOS/tasks.c ****                     }
2520:FreeRTOS/tasks.c ****                 }
2521:FreeRTOS/tasks.c ****             #endif
2522:FreeRTOS/tasks.c ****         }
2523:FreeRTOS/tasks.c ****         ( void ) xTaskResumeAll();
2524:FreeRTOS/tasks.c **** 
2525:FreeRTOS/tasks.c ****         return pxTCB;
2526:FreeRTOS/tasks.c ****     }
2527:FreeRTOS/tasks.c **** 
2528:FreeRTOS/tasks.c **** #endif /* INCLUDE_xTaskGetHandle */
2529:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2530:FreeRTOS/tasks.c **** 
2531:FreeRTOS/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2532:FreeRTOS/tasks.c **** 
2533:FreeRTOS/tasks.c ****     UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray,
2534:FreeRTOS/tasks.c ****                                       const UBaseType_t uxArraySize,
2535:FreeRTOS/tasks.c ****                                       configRUN_TIME_COUNTER_TYPE * const pulTotalRunTime )
2536:FreeRTOS/tasks.c ****     {
2537:FreeRTOS/tasks.c ****         UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
2538:FreeRTOS/tasks.c **** 
2539:FreeRTOS/tasks.c ****         vTaskSuspendAll();
2540:FreeRTOS/tasks.c ****         {
2541:FreeRTOS/tasks.c ****             /* Is there a space in the array for each task in the system? */
2542:FreeRTOS/tasks.c ****             if( uxArraySize >= uxCurrentNumberOfTasks )
2543:FreeRTOS/tasks.c ****             {
2544:FreeRTOS/tasks.c ****                 /* Fill in an TaskStatus_t structure with information on each
2545:FreeRTOS/tasks.c ****                  * task in the Ready state. */
2546:FreeRTOS/tasks.c ****                 do
2547:FreeRTOS/tasks.c ****                 {
2548:FreeRTOS/tasks.c ****                     uxQueue--;
ARM GAS  /tmp/ccrgBt0i.s 			page 51


2549:FreeRTOS/tasks.c ****                     uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( px
2550:FreeRTOS/tasks.c ****                 } while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception
2551:FreeRTOS/tasks.c **** 
2552:FreeRTOS/tasks.c ****                 /* Fill in an TaskStatus_t structure with information on each
2553:FreeRTOS/tasks.c ****                  * task in the Blocked state. */
2554:FreeRTOS/tasks.c ****                 uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t 
2555:FreeRTOS/tasks.c ****                 uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t 
2556:FreeRTOS/tasks.c **** 
2557:FreeRTOS/tasks.c ****                 #if ( INCLUDE_vTaskDelete == 1 )
2558:FreeRTOS/tasks.c ****                     {
2559:FreeRTOS/tasks.c ****                         /* Fill in an TaskStatus_t structure with information on
2560:FreeRTOS/tasks.c ****                          * each task that has been deleted but not yet cleaned up. */
2561:FreeRTOS/tasks.c ****                         uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &
2562:FreeRTOS/tasks.c ****                     }
2563:FreeRTOS/tasks.c ****                 #endif
2564:FreeRTOS/tasks.c **** 
2565:FreeRTOS/tasks.c ****                 #if ( INCLUDE_vTaskSuspend == 1 )
2566:FreeRTOS/tasks.c ****                     {
2567:FreeRTOS/tasks.c ****                         /* Fill in an TaskStatus_t structure with information on
2568:FreeRTOS/tasks.c ****                          * each task in the Suspended state. */
2569:FreeRTOS/tasks.c ****                         uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &
2570:FreeRTOS/tasks.c ****                     }
2571:FreeRTOS/tasks.c ****                 #endif
2572:FreeRTOS/tasks.c **** 
2573:FreeRTOS/tasks.c ****                 #if ( configGENERATE_RUN_TIME_STATS == 1 )
2574:FreeRTOS/tasks.c ****                     {
2575:FreeRTOS/tasks.c ****                         if( pulTotalRunTime != NULL )
2576:FreeRTOS/tasks.c ****                         {
2577:FreeRTOS/tasks.c ****                             #ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
2578:FreeRTOS/tasks.c ****                                 portALT_GET_RUN_TIME_COUNTER_VALUE( ( *pulTotalRunTime ) );
2579:FreeRTOS/tasks.c ****                             #else
2580:FreeRTOS/tasks.c ****                                 *pulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
2581:FreeRTOS/tasks.c ****                             #endif
2582:FreeRTOS/tasks.c ****                         }
2583:FreeRTOS/tasks.c ****                     }
2584:FreeRTOS/tasks.c ****                 #else /* if ( configGENERATE_RUN_TIME_STATS == 1 ) */
2585:FreeRTOS/tasks.c ****                     {
2586:FreeRTOS/tasks.c ****                         if( pulTotalRunTime != NULL )
2587:FreeRTOS/tasks.c ****                         {
2588:FreeRTOS/tasks.c ****                             *pulTotalRunTime = 0;
2589:FreeRTOS/tasks.c ****                         }
2590:FreeRTOS/tasks.c ****                     }
2591:FreeRTOS/tasks.c ****                 #endif /* if ( configGENERATE_RUN_TIME_STATS == 1 ) */
2592:FreeRTOS/tasks.c ****             }
2593:FreeRTOS/tasks.c ****             else
2594:FreeRTOS/tasks.c ****             {
2595:FreeRTOS/tasks.c ****                 mtCOVERAGE_TEST_MARKER();
2596:FreeRTOS/tasks.c ****             }
2597:FreeRTOS/tasks.c ****         }
2598:FreeRTOS/tasks.c ****         ( void ) xTaskResumeAll();
2599:FreeRTOS/tasks.c **** 
2600:FreeRTOS/tasks.c ****         return uxTask;
2601:FreeRTOS/tasks.c ****     }
2602:FreeRTOS/tasks.c **** 
2603:FreeRTOS/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
2604:FreeRTOS/tasks.c **** /*----------------------------------------------------------*/
2605:FreeRTOS/tasks.c **** 
ARM GAS  /tmp/ccrgBt0i.s 			page 52


2606:FreeRTOS/tasks.c **** #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
2607:FreeRTOS/tasks.c **** 
2608:FreeRTOS/tasks.c ****     TaskHandle_t xTaskGetIdleTaskHandle( void )
2609:FreeRTOS/tasks.c ****     {
2610:FreeRTOS/tasks.c ****         /* If xTaskGetIdleTaskHandle() is called before the scheduler has been
2611:FreeRTOS/tasks.c ****          * started, then xIdleTaskHandle will be NULL. */
2612:FreeRTOS/tasks.c ****         configASSERT( ( xIdleTaskHandle != NULL ) );
2613:FreeRTOS/tasks.c ****         return xIdleTaskHandle;
2614:FreeRTOS/tasks.c ****     }
2615:FreeRTOS/tasks.c **** 
2616:FreeRTOS/tasks.c **** #endif /* INCLUDE_xTaskGetIdleTaskHandle */
2617:FreeRTOS/tasks.c **** /*----------------------------------------------------------*/
2618:FreeRTOS/tasks.c **** 
2619:FreeRTOS/tasks.c **** /* This conditional compilation should use inequality to 0, not equality to 1.
2620:FreeRTOS/tasks.c ****  * This is to ensure vTaskStepTick() is available when user defined low power mode
2621:FreeRTOS/tasks.c ****  * implementations require configUSE_TICKLESS_IDLE to be set to a value other than
2622:FreeRTOS/tasks.c ****  * 1. */
2623:FreeRTOS/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
2624:FreeRTOS/tasks.c **** 
2625:FreeRTOS/tasks.c ****     void vTaskStepTick( const TickType_t xTicksToJump )
2626:FreeRTOS/tasks.c ****     {
2627:FreeRTOS/tasks.c ****         /* Correct the tick count value after a period during which the tick
2628:FreeRTOS/tasks.c ****          * was suppressed.  Note this does *not* call the tick hook function for
2629:FreeRTOS/tasks.c ****          * each stepped tick. */
2630:FreeRTOS/tasks.c ****         configASSERT( ( xTickCount + xTicksToJump ) <= xNextTaskUnblockTime );
2631:FreeRTOS/tasks.c ****         xTickCount += xTicksToJump;
2632:FreeRTOS/tasks.c ****         traceINCREASE_TICK_COUNT( xTicksToJump );
2633:FreeRTOS/tasks.c ****     }
2634:FreeRTOS/tasks.c **** 
2635:FreeRTOS/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
2636:FreeRTOS/tasks.c **** /*----------------------------------------------------------*/
2637:FreeRTOS/tasks.c **** 
2638:FreeRTOS/tasks.c **** BaseType_t xTaskCatchUpTicks( TickType_t xTicksToCatchUp )
2639:FreeRTOS/tasks.c **** {
2640:FreeRTOS/tasks.c ****     BaseType_t xYieldOccurred;
2641:FreeRTOS/tasks.c **** 
2642:FreeRTOS/tasks.c ****     /* Must not be called with the scheduler suspended as the implementation
2643:FreeRTOS/tasks.c ****      * relies on xPendedTicks being wound down to 0 in xTaskResumeAll(). */
2644:FreeRTOS/tasks.c ****     configASSERT( uxSchedulerSuspended == 0 );
2645:FreeRTOS/tasks.c **** 
2646:FreeRTOS/tasks.c ****     /* Use xPendedTicks to mimic xTicksToCatchUp number of ticks occurring when
2647:FreeRTOS/tasks.c ****      * the scheduler is suspended so the ticks are executed in xTaskResumeAll(). */
2648:FreeRTOS/tasks.c ****     vTaskSuspendAll();
2649:FreeRTOS/tasks.c ****     xPendedTicks += xTicksToCatchUp;
2650:FreeRTOS/tasks.c ****     xYieldOccurred = xTaskResumeAll();
2651:FreeRTOS/tasks.c **** 
2652:FreeRTOS/tasks.c ****     return xYieldOccurred;
2653:FreeRTOS/tasks.c **** }
2654:FreeRTOS/tasks.c **** /*----------------------------------------------------------*/
2655:FreeRTOS/tasks.c **** 
2656:FreeRTOS/tasks.c **** #if ( INCLUDE_xTaskAbortDelay == 1 )
2657:FreeRTOS/tasks.c **** 
2658:FreeRTOS/tasks.c ****     BaseType_t xTaskAbortDelay( TaskHandle_t xTask )
2659:FreeRTOS/tasks.c ****     {
2660:FreeRTOS/tasks.c ****         TCB_t * pxTCB = xTask;
2661:FreeRTOS/tasks.c ****         BaseType_t xReturn;
2662:FreeRTOS/tasks.c **** 
ARM GAS  /tmp/ccrgBt0i.s 			page 53


2663:FreeRTOS/tasks.c ****         configASSERT( pxTCB );
2664:FreeRTOS/tasks.c **** 
2665:FreeRTOS/tasks.c ****         vTaskSuspendAll();
2666:FreeRTOS/tasks.c ****         {
2667:FreeRTOS/tasks.c ****             /* A task can only be prematurely removed from the Blocked state if
2668:FreeRTOS/tasks.c ****              * it is actually in the Blocked state. */
2669:FreeRTOS/tasks.c ****             if( eTaskGetState( xTask ) == eBlocked )
2670:FreeRTOS/tasks.c ****             {
2671:FreeRTOS/tasks.c ****                 xReturn = pdPASS;
2672:FreeRTOS/tasks.c **** 
2673:FreeRTOS/tasks.c ****                 /* Remove the reference to the task from the blocked list.  An
2674:FreeRTOS/tasks.c ****                  * interrupt won't touch the xStateListItem because the
2675:FreeRTOS/tasks.c ****                  * scheduler is suspended. */
2676:FreeRTOS/tasks.c ****                 ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
2677:FreeRTOS/tasks.c **** 
2678:FreeRTOS/tasks.c ****                 /* Is the task waiting on an event also?  If so remove it from
2679:FreeRTOS/tasks.c ****                  * the event list too.  Interrupts can touch the event list item,
2680:FreeRTOS/tasks.c ****                  * even though the scheduler is suspended, so a critical section
2681:FreeRTOS/tasks.c ****                  * is used. */
2682:FreeRTOS/tasks.c ****                 taskENTER_CRITICAL();
2683:FreeRTOS/tasks.c ****                 {
2684:FreeRTOS/tasks.c ****                     if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
2685:FreeRTOS/tasks.c ****                     {
2686:FreeRTOS/tasks.c ****                         ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
2687:FreeRTOS/tasks.c **** 
2688:FreeRTOS/tasks.c ****                         /* This lets the task know it was forcibly removed from the
2689:FreeRTOS/tasks.c ****                          * blocked state so it should not re-evaluate its block time and
2690:FreeRTOS/tasks.c ****                          * then block again. */
2691:FreeRTOS/tasks.c ****                         pxTCB->ucDelayAborted = pdTRUE;
2692:FreeRTOS/tasks.c ****                     }
2693:FreeRTOS/tasks.c ****                     else
2694:FreeRTOS/tasks.c ****                     {
2695:FreeRTOS/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
2696:FreeRTOS/tasks.c ****                     }
2697:FreeRTOS/tasks.c ****                 }
2698:FreeRTOS/tasks.c ****                 taskEXIT_CRITICAL();
2699:FreeRTOS/tasks.c **** 
2700:FreeRTOS/tasks.c ****                 /* Place the unblocked task into the appropriate ready list. */
2701:FreeRTOS/tasks.c ****                 prvAddTaskToReadyList( pxTCB );
2702:FreeRTOS/tasks.c **** 
2703:FreeRTOS/tasks.c ****                 /* A task being unblocked cannot cause an immediate context
2704:FreeRTOS/tasks.c ****                  * switch if preemption is turned off. */
2705:FreeRTOS/tasks.c ****                 #if ( configUSE_PREEMPTION == 1 )
2706:FreeRTOS/tasks.c ****                     {
2707:FreeRTOS/tasks.c ****                         /* Preemption is on, but a context switch should only be
2708:FreeRTOS/tasks.c ****                          * performed if the unblocked task has a priority that is
2709:FreeRTOS/tasks.c ****                          * higher than the currently executing task. */
2710:FreeRTOS/tasks.c ****                         if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
2711:FreeRTOS/tasks.c ****                         {
2712:FreeRTOS/tasks.c ****                             /* Pend the yield to be performed when the scheduler
2713:FreeRTOS/tasks.c ****                              * is unsuspended. */
2714:FreeRTOS/tasks.c ****                             xYieldPending = pdTRUE;
2715:FreeRTOS/tasks.c ****                         }
2716:FreeRTOS/tasks.c ****                         else
2717:FreeRTOS/tasks.c ****                         {
2718:FreeRTOS/tasks.c ****                             mtCOVERAGE_TEST_MARKER();
2719:FreeRTOS/tasks.c ****                         }
ARM GAS  /tmp/ccrgBt0i.s 			page 54


2720:FreeRTOS/tasks.c ****                     }
2721:FreeRTOS/tasks.c ****                 #endif /* configUSE_PREEMPTION */
2722:FreeRTOS/tasks.c ****             }
2723:FreeRTOS/tasks.c ****             else
2724:FreeRTOS/tasks.c ****             {
2725:FreeRTOS/tasks.c ****                 xReturn = pdFAIL;
2726:FreeRTOS/tasks.c ****             }
2727:FreeRTOS/tasks.c ****         }
2728:FreeRTOS/tasks.c ****         ( void ) xTaskResumeAll();
2729:FreeRTOS/tasks.c **** 
2730:FreeRTOS/tasks.c ****         return xReturn;
2731:FreeRTOS/tasks.c ****     }
2732:FreeRTOS/tasks.c **** 
2733:FreeRTOS/tasks.c **** #endif /* INCLUDE_xTaskAbortDelay */
2734:FreeRTOS/tasks.c **** /*----------------------------------------------------------*/
2735:FreeRTOS/tasks.c **** 
2736:FreeRTOS/tasks.c **** BaseType_t xTaskIncrementTick( void )
2737:FreeRTOS/tasks.c **** {
2738:FreeRTOS/tasks.c ****     TCB_t * pxTCB;
2739:FreeRTOS/tasks.c ****     TickType_t xItemValue;
2740:FreeRTOS/tasks.c ****     BaseType_t xSwitchRequired = pdFALSE;
2741:FreeRTOS/tasks.c **** 
2742:FreeRTOS/tasks.c ****     /* Called by the portable layer each time a tick interrupt occurs.
2743:FreeRTOS/tasks.c ****      * Increments the tick then checks to see if the new tick value will cause any
2744:FreeRTOS/tasks.c ****      * tasks to be unblocked. */
2745:FreeRTOS/tasks.c ****     traceTASK_INCREMENT_TICK( xTickCount );
2746:FreeRTOS/tasks.c **** 
2747:FreeRTOS/tasks.c ****     if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
2748:FreeRTOS/tasks.c ****     {
2749:FreeRTOS/tasks.c ****         /* Minor optimisation.  The tick count cannot change in this
2750:FreeRTOS/tasks.c ****          * block. */
2751:FreeRTOS/tasks.c ****         const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
2752:FreeRTOS/tasks.c **** 
2753:FreeRTOS/tasks.c ****         /* Increment the RTOS tick, switching the delayed and overflowed
2754:FreeRTOS/tasks.c ****          * delayed lists if it wraps to 0. */
2755:FreeRTOS/tasks.c ****         xTickCount = xConstTickCount;
2756:FreeRTOS/tasks.c **** 
2757:FreeRTOS/tasks.c ****         if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to fa
2758:FreeRTOS/tasks.c ****         {
2759:FreeRTOS/tasks.c ****             taskSWITCH_DELAYED_LISTS();
2760:FreeRTOS/tasks.c ****         }
2761:FreeRTOS/tasks.c ****         else
2762:FreeRTOS/tasks.c ****         {
2763:FreeRTOS/tasks.c ****             mtCOVERAGE_TEST_MARKER();
2764:FreeRTOS/tasks.c ****         }
2765:FreeRTOS/tasks.c **** 
2766:FreeRTOS/tasks.c ****         /* See if this tick has made a timeout expire.  Tasks are stored in
2767:FreeRTOS/tasks.c ****          * the  queue in the order of their wake time - meaning once one task
2768:FreeRTOS/tasks.c ****          * has been found whose block time has not expired there is no need to
2769:FreeRTOS/tasks.c ****          * look any further down the list. */
2770:FreeRTOS/tasks.c ****         if( xConstTickCount >= xNextTaskUnblockTime )
2771:FreeRTOS/tasks.c ****         {
2772:FreeRTOS/tasks.c ****             for( ; ; )
2773:FreeRTOS/tasks.c ****             {
2774:FreeRTOS/tasks.c ****                 if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
2775:FreeRTOS/tasks.c ****                 {
2776:FreeRTOS/tasks.c ****                     /* The delayed list is empty.  Set xNextTaskUnblockTime
ARM GAS  /tmp/ccrgBt0i.s 			page 55


2777:FreeRTOS/tasks.c ****                      * to the maximum possible value so it is extremely
2778:FreeRTOS/tasks.c ****                      * unlikely that the
2779:FreeRTOS/tasks.c ****                      * if( xTickCount >= xNextTaskUnblockTime ) test will pass
2780:FreeRTOS/tasks.c ****                      * next time through. */
2781:FreeRTOS/tasks.c ****                     xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts
2782:FreeRTOS/tasks.c ****                     break;
2783:FreeRTOS/tasks.c ****                 }
2784:FreeRTOS/tasks.c ****                 else
2785:FreeRTOS/tasks.c ****                 {
2786:FreeRTOS/tasks.c ****                     /* The delayed list is not empty, get the value of the
2787:FreeRTOS/tasks.c ****                      * item at the head of the delayed list.  This is the time
2788:FreeRTOS/tasks.c ****                      * at which the task at the head of the delayed list must
2789:FreeRTOS/tasks.c ****                      * be removed from the Blocked state. */
2790:FreeRTOS/tasks.c ****                     pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * 
2791:FreeRTOS/tasks.c ****                     xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
2792:FreeRTOS/tasks.c **** 
2793:FreeRTOS/tasks.c ****                     if( xConstTickCount < xItemValue )
2794:FreeRTOS/tasks.c ****                     {
2795:FreeRTOS/tasks.c ****                         /* It is not time to unblock this item yet, but the
2796:FreeRTOS/tasks.c ****                          * item value is the time at which the task at the head
2797:FreeRTOS/tasks.c ****                          * of the blocked list must be removed from the Blocked
2798:FreeRTOS/tasks.c ****                          * state -  so record the item value in
2799:FreeRTOS/tasks.c ****                          * xNextTaskUnblockTime. */
2800:FreeRTOS/tasks.c ****                         xNextTaskUnblockTime = xItemValue;
2801:FreeRTOS/tasks.c ****                         break; /*lint !e9011 Code structure here is deemed easier to understand wit
2802:FreeRTOS/tasks.c ****                     }
2803:FreeRTOS/tasks.c ****                     else
2804:FreeRTOS/tasks.c ****                     {
2805:FreeRTOS/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
2806:FreeRTOS/tasks.c ****                     }
2807:FreeRTOS/tasks.c **** 
2808:FreeRTOS/tasks.c ****                     /* It is time to remove the item from the Blocked state. */
2809:FreeRTOS/tasks.c ****                     listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
2810:FreeRTOS/tasks.c **** 
2811:FreeRTOS/tasks.c ****                     /* Is the task waiting on an event also?  If so remove
2812:FreeRTOS/tasks.c ****                      * it from the event list. */
2813:FreeRTOS/tasks.c ****                     if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
2814:FreeRTOS/tasks.c ****                     {
2815:FreeRTOS/tasks.c ****                         listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
2816:FreeRTOS/tasks.c ****                     }
2817:FreeRTOS/tasks.c ****                     else
2818:FreeRTOS/tasks.c ****                     {
2819:FreeRTOS/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
2820:FreeRTOS/tasks.c ****                     }
2821:FreeRTOS/tasks.c **** 
2822:FreeRTOS/tasks.c ****                     /* Place the unblocked task into the appropriate ready
2823:FreeRTOS/tasks.c ****                      * list. */
2824:FreeRTOS/tasks.c ****                     prvAddTaskToReadyList( pxTCB );
2825:FreeRTOS/tasks.c **** 
2826:FreeRTOS/tasks.c ****                     /* A task being unblocked cannot cause an immediate
2827:FreeRTOS/tasks.c ****                      * context switch if preemption is turned off. */
2828:FreeRTOS/tasks.c ****                     #if ( configUSE_PREEMPTION == 1 )
2829:FreeRTOS/tasks.c ****                         {
2830:FreeRTOS/tasks.c ****                             /* Preemption is on, but a context switch should
2831:FreeRTOS/tasks.c ****                              * only be performed if the unblocked task has a
2832:FreeRTOS/tasks.c ****                              * priority that is equal to or higher than the
2833:FreeRTOS/tasks.c ****                              * currently executing task. */
ARM GAS  /tmp/ccrgBt0i.s 			page 56


2834:FreeRTOS/tasks.c ****                             if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
2835:FreeRTOS/tasks.c ****                             {
2836:FreeRTOS/tasks.c ****                                 xSwitchRequired = pdTRUE;
2837:FreeRTOS/tasks.c ****                             }
2838:FreeRTOS/tasks.c ****                             else
2839:FreeRTOS/tasks.c ****                             {
2840:FreeRTOS/tasks.c ****                                 mtCOVERAGE_TEST_MARKER();
2841:FreeRTOS/tasks.c ****                             }
2842:FreeRTOS/tasks.c ****                         }
2843:FreeRTOS/tasks.c ****                     #endif /* configUSE_PREEMPTION */
2844:FreeRTOS/tasks.c ****                 }
2845:FreeRTOS/tasks.c ****             }
2846:FreeRTOS/tasks.c ****         }
2847:FreeRTOS/tasks.c **** 
2848:FreeRTOS/tasks.c ****         /* Tasks of equal priority to the currently running task will share
2849:FreeRTOS/tasks.c ****          * processing time (time slice) if preemption is on, and the application
2850:FreeRTOS/tasks.c ****          * writer has not explicitly turned time slicing off. */
2851:FreeRTOS/tasks.c ****         #if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
2852:FreeRTOS/tasks.c ****             {
2853:FreeRTOS/tasks.c ****                 if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) >
2854:FreeRTOS/tasks.c ****                 {
2855:FreeRTOS/tasks.c ****                     xSwitchRequired = pdTRUE;
2856:FreeRTOS/tasks.c ****                 }
2857:FreeRTOS/tasks.c ****                 else
2858:FreeRTOS/tasks.c ****                 {
2859:FreeRTOS/tasks.c ****                     mtCOVERAGE_TEST_MARKER();
2860:FreeRTOS/tasks.c ****                 }
2861:FreeRTOS/tasks.c ****             }
2862:FreeRTOS/tasks.c ****         #endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */
2863:FreeRTOS/tasks.c **** 
2864:FreeRTOS/tasks.c ****         #if ( configUSE_TICK_HOOK == 1 )
2865:FreeRTOS/tasks.c ****             {
2866:FreeRTOS/tasks.c ****                 /* Guard against the tick hook being called when the pended tick
2867:FreeRTOS/tasks.c ****                  * count is being unwound (when the scheduler is being unlocked). */
2868:FreeRTOS/tasks.c ****                 if( xPendedTicks == ( TickType_t ) 0 )
2869:FreeRTOS/tasks.c ****                 {
2870:FreeRTOS/tasks.c ****                     vApplicationTickHook();
2871:FreeRTOS/tasks.c ****                 }
2872:FreeRTOS/tasks.c ****                 else
2873:FreeRTOS/tasks.c ****                 {
2874:FreeRTOS/tasks.c ****                     mtCOVERAGE_TEST_MARKER();
2875:FreeRTOS/tasks.c ****                 }
2876:FreeRTOS/tasks.c ****             }
2877:FreeRTOS/tasks.c ****         #endif /* configUSE_TICK_HOOK */
2878:FreeRTOS/tasks.c **** 
2879:FreeRTOS/tasks.c ****         #if ( configUSE_PREEMPTION == 1 )
2880:FreeRTOS/tasks.c ****             {
2881:FreeRTOS/tasks.c ****                 if( xYieldPending != pdFALSE )
2882:FreeRTOS/tasks.c ****                 {
2883:FreeRTOS/tasks.c ****                     xSwitchRequired = pdTRUE;
2884:FreeRTOS/tasks.c ****                 }
2885:FreeRTOS/tasks.c ****                 else
2886:FreeRTOS/tasks.c ****                 {
2887:FreeRTOS/tasks.c ****                     mtCOVERAGE_TEST_MARKER();
2888:FreeRTOS/tasks.c ****                 }
2889:FreeRTOS/tasks.c ****             }
2890:FreeRTOS/tasks.c ****         #endif /* configUSE_PREEMPTION */
ARM GAS  /tmp/ccrgBt0i.s 			page 57


2891:FreeRTOS/tasks.c ****     }
2892:FreeRTOS/tasks.c ****     else
2893:FreeRTOS/tasks.c ****     {
2894:FreeRTOS/tasks.c ****         ++xPendedTicks;
2895:FreeRTOS/tasks.c **** 
2896:FreeRTOS/tasks.c ****         /* The tick hook gets called at regular intervals, even if the
2897:FreeRTOS/tasks.c ****          * scheduler is locked. */
2898:FreeRTOS/tasks.c ****         #if ( configUSE_TICK_HOOK == 1 )
2899:FreeRTOS/tasks.c ****             {
2900:FreeRTOS/tasks.c ****                 vApplicationTickHook();
2901:FreeRTOS/tasks.c ****             }
2902:FreeRTOS/tasks.c ****         #endif
2903:FreeRTOS/tasks.c ****     }
2904:FreeRTOS/tasks.c **** 
2905:FreeRTOS/tasks.c ****     return xSwitchRequired;
2906:FreeRTOS/tasks.c **** }
2907:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2908:FreeRTOS/tasks.c **** 
2909:FreeRTOS/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2910:FreeRTOS/tasks.c **** 
2911:FreeRTOS/tasks.c ****     void vTaskSetApplicationTaskTag( TaskHandle_t xTask,
2912:FreeRTOS/tasks.c ****                                      TaskHookFunction_t pxHookFunction )
2913:FreeRTOS/tasks.c ****     {
2914:FreeRTOS/tasks.c ****         TCB_t * xTCB;
2915:FreeRTOS/tasks.c **** 
2916:FreeRTOS/tasks.c ****         /* If xTask is NULL then it is the task hook of the calling task that is
2917:FreeRTOS/tasks.c ****          * getting set. */
2918:FreeRTOS/tasks.c ****         if( xTask == NULL )
2919:FreeRTOS/tasks.c ****         {
2920:FreeRTOS/tasks.c ****             xTCB = ( TCB_t * ) pxCurrentTCB;
2921:FreeRTOS/tasks.c ****         }
2922:FreeRTOS/tasks.c ****         else
2923:FreeRTOS/tasks.c ****         {
2924:FreeRTOS/tasks.c ****             xTCB = xTask;
2925:FreeRTOS/tasks.c ****         }
2926:FreeRTOS/tasks.c **** 
2927:FreeRTOS/tasks.c ****         /* Save the hook function in the TCB.  A critical section is required as
2928:FreeRTOS/tasks.c ****          * the value can be accessed from an interrupt. */
2929:FreeRTOS/tasks.c ****         taskENTER_CRITICAL();
2930:FreeRTOS/tasks.c ****         {
2931:FreeRTOS/tasks.c ****             xTCB->pxTaskTag = pxHookFunction;
2932:FreeRTOS/tasks.c ****         }
2933:FreeRTOS/tasks.c ****         taskEXIT_CRITICAL();
2934:FreeRTOS/tasks.c ****     }
2935:FreeRTOS/tasks.c **** 
2936:FreeRTOS/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
2937:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2938:FreeRTOS/tasks.c **** 
2939:FreeRTOS/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2940:FreeRTOS/tasks.c **** 
2941:FreeRTOS/tasks.c ****     TaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask )
2942:FreeRTOS/tasks.c ****     {
2943:FreeRTOS/tasks.c ****         TCB_t * pxTCB;
2944:FreeRTOS/tasks.c ****         TaskHookFunction_t xReturn;
2945:FreeRTOS/tasks.c **** 
2946:FreeRTOS/tasks.c ****         /* If xTask is NULL then set the calling task's hook. */
2947:FreeRTOS/tasks.c ****         pxTCB = prvGetTCBFromHandle( xTask );
ARM GAS  /tmp/ccrgBt0i.s 			page 58


2948:FreeRTOS/tasks.c **** 
2949:FreeRTOS/tasks.c ****         /* Save the hook function in the TCB.  A critical section is required as
2950:FreeRTOS/tasks.c ****          * the value can be accessed from an interrupt. */
2951:FreeRTOS/tasks.c ****         taskENTER_CRITICAL();
2952:FreeRTOS/tasks.c ****         {
2953:FreeRTOS/tasks.c ****             xReturn = pxTCB->pxTaskTag;
2954:FreeRTOS/tasks.c ****         }
2955:FreeRTOS/tasks.c ****         taskEXIT_CRITICAL();
2956:FreeRTOS/tasks.c **** 
2957:FreeRTOS/tasks.c ****         return xReturn;
2958:FreeRTOS/tasks.c ****     }
2959:FreeRTOS/tasks.c **** 
2960:FreeRTOS/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
2961:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2962:FreeRTOS/tasks.c **** 
2963:FreeRTOS/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2964:FreeRTOS/tasks.c **** 
2965:FreeRTOS/tasks.c ****     TaskHookFunction_t xTaskGetApplicationTaskTagFromISR( TaskHandle_t xTask )
2966:FreeRTOS/tasks.c ****     {
2967:FreeRTOS/tasks.c ****         TCB_t * pxTCB;
2968:FreeRTOS/tasks.c ****         TaskHookFunction_t xReturn;
2969:FreeRTOS/tasks.c ****         UBaseType_t uxSavedInterruptStatus;
2970:FreeRTOS/tasks.c **** 
2971:FreeRTOS/tasks.c ****         /* If xTask is NULL then set the calling task's hook. */
2972:FreeRTOS/tasks.c ****         pxTCB = prvGetTCBFromHandle( xTask );
2973:FreeRTOS/tasks.c **** 
2974:FreeRTOS/tasks.c ****         /* Save the hook function in the TCB.  A critical section is required as
2975:FreeRTOS/tasks.c ****          * the value can be accessed from an interrupt. */
2976:FreeRTOS/tasks.c ****         uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
2977:FreeRTOS/tasks.c ****         {
2978:FreeRTOS/tasks.c ****             xReturn = pxTCB->pxTaskTag;
2979:FreeRTOS/tasks.c ****         }
2980:FreeRTOS/tasks.c ****         portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
2981:FreeRTOS/tasks.c **** 
2982:FreeRTOS/tasks.c ****         return xReturn;
2983:FreeRTOS/tasks.c ****     }
2984:FreeRTOS/tasks.c **** 
2985:FreeRTOS/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
2986:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2987:FreeRTOS/tasks.c **** 
2988:FreeRTOS/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2989:FreeRTOS/tasks.c **** 
2990:FreeRTOS/tasks.c ****     BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask,
2991:FreeRTOS/tasks.c ****                                              void * pvParameter )
2992:FreeRTOS/tasks.c ****     {
2993:FreeRTOS/tasks.c ****         TCB_t * xTCB;
2994:FreeRTOS/tasks.c ****         BaseType_t xReturn;
2995:FreeRTOS/tasks.c **** 
2996:FreeRTOS/tasks.c ****         /* If xTask is NULL then we are calling our own task hook. */
2997:FreeRTOS/tasks.c ****         if( xTask == NULL )
2998:FreeRTOS/tasks.c ****         {
2999:FreeRTOS/tasks.c ****             xTCB = pxCurrentTCB;
3000:FreeRTOS/tasks.c ****         }
3001:FreeRTOS/tasks.c ****         else
3002:FreeRTOS/tasks.c ****         {
3003:FreeRTOS/tasks.c ****             xTCB = xTask;
3004:FreeRTOS/tasks.c ****         }
ARM GAS  /tmp/ccrgBt0i.s 			page 59


3005:FreeRTOS/tasks.c **** 
3006:FreeRTOS/tasks.c ****         if( xTCB->pxTaskTag != NULL )
3007:FreeRTOS/tasks.c ****         {
3008:FreeRTOS/tasks.c ****             xReturn = xTCB->pxTaskTag( pvParameter );
3009:FreeRTOS/tasks.c ****         }
3010:FreeRTOS/tasks.c ****         else
3011:FreeRTOS/tasks.c ****         {
3012:FreeRTOS/tasks.c ****             xReturn = pdFAIL;
3013:FreeRTOS/tasks.c ****         }
3014:FreeRTOS/tasks.c **** 
3015:FreeRTOS/tasks.c ****         return xReturn;
3016:FreeRTOS/tasks.c ****     }
3017:FreeRTOS/tasks.c **** 
3018:FreeRTOS/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
3019:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3020:FreeRTOS/tasks.c **** 
3021:FreeRTOS/tasks.c **** void vTaskSwitchContext( void )
3022:FreeRTOS/tasks.c **** {
3023:FreeRTOS/tasks.c ****     if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
3024:FreeRTOS/tasks.c ****     {
3025:FreeRTOS/tasks.c ****         /* The scheduler is currently suspended - do not allow a context
3026:FreeRTOS/tasks.c ****          * switch. */
3027:FreeRTOS/tasks.c ****         xYieldPending = pdTRUE;
3028:FreeRTOS/tasks.c ****     }
3029:FreeRTOS/tasks.c ****     else
3030:FreeRTOS/tasks.c ****     {
3031:FreeRTOS/tasks.c ****         xYieldPending = pdFALSE;
3032:FreeRTOS/tasks.c ****         traceTASK_SWITCHED_OUT();
3033:FreeRTOS/tasks.c **** 
3034:FreeRTOS/tasks.c ****         #if ( configGENERATE_RUN_TIME_STATS == 1 )
3035:FreeRTOS/tasks.c ****             {
3036:FreeRTOS/tasks.c ****                 #ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
3037:FreeRTOS/tasks.c ****                     portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
3038:FreeRTOS/tasks.c ****                 #else
3039:FreeRTOS/tasks.c ****                     ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
3040:FreeRTOS/tasks.c ****                 #endif
3041:FreeRTOS/tasks.c **** 
3042:FreeRTOS/tasks.c ****                 /* Add the amount of time the task has been running to the
3043:FreeRTOS/tasks.c ****                  * accumulated time so far.  The time the task started running was
3044:FreeRTOS/tasks.c ****                  * stored in ulTaskSwitchedInTime.  Note that there is no overflow
3045:FreeRTOS/tasks.c ****                  * protection here so count values are only valid until the timer
3046:FreeRTOS/tasks.c ****                  * overflows.  The guard against negative values is to protect
3047:FreeRTOS/tasks.c ****                  * against suspect run time stat counter implementations - which
3048:FreeRTOS/tasks.c ****                  * are provided by the application, not the kernel. */
3049:FreeRTOS/tasks.c ****                 if( ulTotalRunTime > ulTaskSwitchedInTime )
3050:FreeRTOS/tasks.c ****                 {
3051:FreeRTOS/tasks.c ****                     pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
3052:FreeRTOS/tasks.c ****                 }
3053:FreeRTOS/tasks.c ****                 else
3054:FreeRTOS/tasks.c ****                 {
3055:FreeRTOS/tasks.c ****                     mtCOVERAGE_TEST_MARKER();
3056:FreeRTOS/tasks.c ****                 }
3057:FreeRTOS/tasks.c **** 
3058:FreeRTOS/tasks.c ****                 ulTaskSwitchedInTime = ulTotalRunTime;
3059:FreeRTOS/tasks.c ****             }
3060:FreeRTOS/tasks.c ****         #endif /* configGENERATE_RUN_TIME_STATS */
3061:FreeRTOS/tasks.c **** 
ARM GAS  /tmp/ccrgBt0i.s 			page 60


3062:FreeRTOS/tasks.c ****         /* Check for stack overflow, if configured. */
3063:FreeRTOS/tasks.c ****         taskCHECK_FOR_STACK_OVERFLOW();
3064:FreeRTOS/tasks.c **** 
3065:FreeRTOS/tasks.c ****         /* Before the currently running task is switched out, save its errno. */
3066:FreeRTOS/tasks.c ****         #if ( configUSE_POSIX_ERRNO == 1 )
3067:FreeRTOS/tasks.c ****             {
3068:FreeRTOS/tasks.c ****                 pxCurrentTCB->iTaskErrno = FreeRTOS_errno;
3069:FreeRTOS/tasks.c ****             }
3070:FreeRTOS/tasks.c ****         #endif
3071:FreeRTOS/tasks.c **** 
3072:FreeRTOS/tasks.c ****         /* Select a new task to run using either the generic C or port
3073:FreeRTOS/tasks.c ****          * optimised asm code. */
3074:FreeRTOS/tasks.c ****         taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with
3075:FreeRTOS/tasks.c ****         traceTASK_SWITCHED_IN();
3076:FreeRTOS/tasks.c **** 
3077:FreeRTOS/tasks.c ****         /* After the new task is switched in, update the global errno. */
3078:FreeRTOS/tasks.c ****         #if ( configUSE_POSIX_ERRNO == 1 )
3079:FreeRTOS/tasks.c ****             {
3080:FreeRTOS/tasks.c ****                 FreeRTOS_errno = pxCurrentTCB->iTaskErrno;
3081:FreeRTOS/tasks.c ****             }
3082:FreeRTOS/tasks.c ****         #endif
3083:FreeRTOS/tasks.c **** 
3084:FreeRTOS/tasks.c ****         #if ( configUSE_NEWLIB_REENTRANT == 1 )
3085:FreeRTOS/tasks.c ****             {
3086:FreeRTOS/tasks.c ****                 /* Switch Newlib's _impure_ptr variable to point to the _reent
3087:FreeRTOS/tasks.c ****                  * structure specific to this task.
3088:FreeRTOS/tasks.c ****                  * See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html
3089:FreeRTOS/tasks.c ****                  * for additional information. */
3090:FreeRTOS/tasks.c ****                 _impure_ptr = &( pxCurrentTCB->xNewLib_reent );
3091:FreeRTOS/tasks.c ****             }
3092:FreeRTOS/tasks.c ****         #endif /* configUSE_NEWLIB_REENTRANT */
3093:FreeRTOS/tasks.c ****     }
3094:FreeRTOS/tasks.c **** }
3095:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3096:FreeRTOS/tasks.c **** 
3097:FreeRTOS/tasks.c **** void vTaskPlaceOnEventList( List_t * const pxEventList,
3098:FreeRTOS/tasks.c ****                             const TickType_t xTicksToWait )
3099:FreeRTOS/tasks.c **** {
3100:FreeRTOS/tasks.c ****     configASSERT( pxEventList );
3101:FreeRTOS/tasks.c **** 
3102:FreeRTOS/tasks.c ****     /* THIS FUNCTION MUST BE CALLED WITH EITHER INTERRUPTS DISABLED OR THE
3103:FreeRTOS/tasks.c ****      * SCHEDULER SUSPENDED AND THE QUEUE BEING ACCESSED LOCKED. */
3104:FreeRTOS/tasks.c **** 
3105:FreeRTOS/tasks.c ****     /* Place the event list item of the TCB in the appropriate event list.
3106:FreeRTOS/tasks.c ****      * This is placed in the list in priority order so the highest priority task
3107:FreeRTOS/tasks.c ****      * is the first to be woken by the event.
3108:FreeRTOS/tasks.c ****      *
3109:FreeRTOS/tasks.c ****      * Note: Lists are sorted in ascending order by ListItem_t.xItemValue.
3110:FreeRTOS/tasks.c ****      * Normally, the xItemValue of a TCB's ListItem_t members is:
3111:FreeRTOS/tasks.c ****      *      xItemValue = ( configMAX_PRIORITIES - uxPriority )
3112:FreeRTOS/tasks.c ****      * Therefore, the event list is sorted in descending priority order.
3113:FreeRTOS/tasks.c ****      *
3114:FreeRTOS/tasks.c ****      * The queue that contains the event list is locked, preventing
3115:FreeRTOS/tasks.c ****      * simultaneous access from interrupts. */
3116:FreeRTOS/tasks.c ****     vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
3117:FreeRTOS/tasks.c **** 
3118:FreeRTOS/tasks.c ****     prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
ARM GAS  /tmp/ccrgBt0i.s 			page 61


3119:FreeRTOS/tasks.c **** }
3120:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3121:FreeRTOS/tasks.c **** 
3122:FreeRTOS/tasks.c **** void vTaskPlaceOnUnorderedEventList( List_t * pxEventList,
3123:FreeRTOS/tasks.c ****                                      const TickType_t xItemValue,
3124:FreeRTOS/tasks.c ****                                      const TickType_t xTicksToWait )
3125:FreeRTOS/tasks.c **** {
3126:FreeRTOS/tasks.c ****     configASSERT( pxEventList );
3127:FreeRTOS/tasks.c **** 
3128:FreeRTOS/tasks.c ****     /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
3129:FreeRTOS/tasks.c ****      * the event groups implementation. */
3130:FreeRTOS/tasks.c ****     configASSERT( uxSchedulerSuspended != 0 );
3131:FreeRTOS/tasks.c **** 
3132:FreeRTOS/tasks.c ****     /* Store the item value in the event list item.  It is safe to access the
3133:FreeRTOS/tasks.c ****      * event list item here as interrupts won't access the event list item of a
3134:FreeRTOS/tasks.c ****      * task that is not in the Blocked state. */
3135:FreeRTOS/tasks.c ****     listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VA
3136:FreeRTOS/tasks.c **** 
3137:FreeRTOS/tasks.c ****     /* Place the event list item of the TCB at the end of the appropriate event
3138:FreeRTOS/tasks.c ****      * list.  It is safe to access the event list here because it is part of an
3139:FreeRTOS/tasks.c ****      * event group implementation - and interrupts don't access event groups
3140:FreeRTOS/tasks.c ****      * directly (instead they access them indirectly by pending function calls to
3141:FreeRTOS/tasks.c ****      * the task level). */
3142:FreeRTOS/tasks.c ****     listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
3143:FreeRTOS/tasks.c **** 
3144:FreeRTOS/tasks.c ****     prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
3145:FreeRTOS/tasks.c **** }
3146:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3147:FreeRTOS/tasks.c **** 
3148:FreeRTOS/tasks.c **** #if ( configUSE_TIMERS == 1 )
3149:FreeRTOS/tasks.c **** 
3150:FreeRTOS/tasks.c ****     void vTaskPlaceOnEventListRestricted( List_t * const pxEventList,
3151:FreeRTOS/tasks.c ****                                           TickType_t xTicksToWait,
3152:FreeRTOS/tasks.c ****                                           const BaseType_t xWaitIndefinitely )
3153:FreeRTOS/tasks.c ****     {
3154:FreeRTOS/tasks.c ****         configASSERT( pxEventList );
3155:FreeRTOS/tasks.c **** 
3156:FreeRTOS/tasks.c ****         /* This function should not be called by application code hence the
3157:FreeRTOS/tasks.c ****          * 'Restricted' in its name.  It is not part of the public API.  It is
3158:FreeRTOS/tasks.c ****          * designed for use by kernel code, and has special calling requirements -
3159:FreeRTOS/tasks.c ****          * it should be called with the scheduler suspended. */
3160:FreeRTOS/tasks.c **** 
3161:FreeRTOS/tasks.c **** 
3162:FreeRTOS/tasks.c ****         /* Place the event list item of the TCB in the appropriate event list.
3163:FreeRTOS/tasks.c ****          * In this case it is assume that this is the only task that is going to
3164:FreeRTOS/tasks.c ****          * be waiting on this event list, so the faster vListInsertEnd() function
3165:FreeRTOS/tasks.c ****          * can be used in place of vListInsert. */
3166:FreeRTOS/tasks.c ****         listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
3167:FreeRTOS/tasks.c **** 
3168:FreeRTOS/tasks.c ****         /* If the task should block indefinitely then set the block time to a
3169:FreeRTOS/tasks.c ****          * value that will be recognised as an indefinite delay inside the
3170:FreeRTOS/tasks.c ****          * prvAddCurrentTaskToDelayedList() function. */
3171:FreeRTOS/tasks.c ****         if( xWaitIndefinitely != pdFALSE )
3172:FreeRTOS/tasks.c ****         {
3173:FreeRTOS/tasks.c ****             xTicksToWait = portMAX_DELAY;
3174:FreeRTOS/tasks.c ****         }
3175:FreeRTOS/tasks.c **** 
ARM GAS  /tmp/ccrgBt0i.s 			page 62


3176:FreeRTOS/tasks.c ****         traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
3177:FreeRTOS/tasks.c ****         prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
3178:FreeRTOS/tasks.c ****     }
3179:FreeRTOS/tasks.c **** 
3180:FreeRTOS/tasks.c **** #endif /* configUSE_TIMERS */
3181:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3182:FreeRTOS/tasks.c **** 
3183:FreeRTOS/tasks.c **** BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
3184:FreeRTOS/tasks.c **** {
3185:FreeRTOS/tasks.c ****     TCB_t * pxUnblockedTCB;
3186:FreeRTOS/tasks.c ****     BaseType_t xReturn;
3187:FreeRTOS/tasks.c **** 
3188:FreeRTOS/tasks.c ****     /* THIS FUNCTION MUST BE CALLED FROM A CRITICAL SECTION.  It can also be
3189:FreeRTOS/tasks.c ****      * called from a critical section within an ISR. */
3190:FreeRTOS/tasks.c **** 
3191:FreeRTOS/tasks.c ****     /* The event list is sorted in priority order, so the first in the list can
3192:FreeRTOS/tasks.c ****      * be removed as it is known to be the highest priority.  Remove the TCB from
3193:FreeRTOS/tasks.c ****      * the delayed list, and add it to the ready list.
3194:FreeRTOS/tasks.c ****      *
3195:FreeRTOS/tasks.c ****      * If an event is for a queue that is locked then this function will never
3196:FreeRTOS/tasks.c ****      * get called - the lock count on the queue will get modified instead.  This
3197:FreeRTOS/tasks.c ****      * means exclusive access to the event list is guaranteed here.
3198:FreeRTOS/tasks.c ****      *
3199:FreeRTOS/tasks.c ****      * This function assumes that a check has already been made to ensure that
3200:FreeRTOS/tasks.c ****      * pxEventList is not empty. */
3201:FreeRTOS/tasks.c ****     pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as th
3202:FreeRTOS/tasks.c ****     configASSERT( pxUnblockedTCB );
3203:FreeRTOS/tasks.c ****     listREMOVE_ITEM( &( pxUnblockedTCB->xEventListItem ) );
3204:FreeRTOS/tasks.c **** 
3205:FreeRTOS/tasks.c ****     if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
3206:FreeRTOS/tasks.c ****     {
3207:FreeRTOS/tasks.c ****         listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
3208:FreeRTOS/tasks.c ****         prvAddTaskToReadyList( pxUnblockedTCB );
3209:FreeRTOS/tasks.c **** 
3210:FreeRTOS/tasks.c ****         #if ( configUSE_TICKLESS_IDLE != 0 )
3211:FreeRTOS/tasks.c ****             {
3212:FreeRTOS/tasks.c ****                 /* If a task is blocked on a kernel object then xNextTaskUnblockTime
3213:FreeRTOS/tasks.c ****                  * might be set to the blocked task's time out time.  If the task is
3214:FreeRTOS/tasks.c ****                  * unblocked for a reason other than a timeout xNextTaskUnblockTime is
3215:FreeRTOS/tasks.c ****                  * normally left unchanged, because it is automatically reset to a new
3216:FreeRTOS/tasks.c ****                  * value when the tick count equals xNextTaskUnblockTime.  However if
3217:FreeRTOS/tasks.c ****                  * tickless idling is used it might be more important to enter sleep mode
3218:FreeRTOS/tasks.c ****                  * at the earliest possible time - so reset xNextTaskUnblockTime here to
3219:FreeRTOS/tasks.c ****                  * ensure it is updated at the earliest possible time. */
3220:FreeRTOS/tasks.c ****                 prvResetNextTaskUnblockTime();
3221:FreeRTOS/tasks.c ****             }
3222:FreeRTOS/tasks.c ****         #endif
3223:FreeRTOS/tasks.c ****     }
3224:FreeRTOS/tasks.c ****     else
3225:FreeRTOS/tasks.c ****     {
3226:FreeRTOS/tasks.c ****         /* The delayed and ready lists cannot be accessed, so hold this task
3227:FreeRTOS/tasks.c ****          * pending until the scheduler is resumed. */
3228:FreeRTOS/tasks.c ****         listINSERT_END( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
3229:FreeRTOS/tasks.c ****     }
3230:FreeRTOS/tasks.c **** 
3231:FreeRTOS/tasks.c ****     if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
3232:FreeRTOS/tasks.c ****     {
ARM GAS  /tmp/ccrgBt0i.s 			page 63


3233:FreeRTOS/tasks.c ****         /* Return true if the task removed from the event list has a higher
3234:FreeRTOS/tasks.c ****          * priority than the calling task.  This allows the calling task to know if
3235:FreeRTOS/tasks.c ****          * it should force a context switch now. */
3236:FreeRTOS/tasks.c ****         xReturn = pdTRUE;
3237:FreeRTOS/tasks.c **** 
3238:FreeRTOS/tasks.c ****         /* Mark that a yield is pending in case the user is not using the
3239:FreeRTOS/tasks.c ****          * "xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
3240:FreeRTOS/tasks.c ****         xYieldPending = pdTRUE;
3241:FreeRTOS/tasks.c ****     }
3242:FreeRTOS/tasks.c ****     else
3243:FreeRTOS/tasks.c ****     {
3244:FreeRTOS/tasks.c ****         xReturn = pdFALSE;
3245:FreeRTOS/tasks.c ****     }
3246:FreeRTOS/tasks.c **** 
3247:FreeRTOS/tasks.c ****     return xReturn;
3248:FreeRTOS/tasks.c **** }
3249:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3250:FreeRTOS/tasks.c **** 
3251:FreeRTOS/tasks.c **** void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem,
3252:FreeRTOS/tasks.c ****                                         const TickType_t xItemValue )
3253:FreeRTOS/tasks.c **** {
3254:FreeRTOS/tasks.c ****     TCB_t * pxUnblockedTCB;
3255:FreeRTOS/tasks.c **** 
3256:FreeRTOS/tasks.c ****     /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
3257:FreeRTOS/tasks.c ****      * the event flags implementation. */
3258:FreeRTOS/tasks.c ****     configASSERT( uxSchedulerSuspended != pdFALSE );
3259:FreeRTOS/tasks.c **** 
3260:FreeRTOS/tasks.c ****     /* Store the new item value in the event list. */
3261:FreeRTOS/tasks.c ****     listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
3262:FreeRTOS/tasks.c **** 
3263:FreeRTOS/tasks.c ****     /* Remove the event list form the event flag.  Interrupts do not access
3264:FreeRTOS/tasks.c ****      * event flags. */
3265:FreeRTOS/tasks.c ****     pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as th
3266:FreeRTOS/tasks.c ****     configASSERT( pxUnblockedTCB );
3267:FreeRTOS/tasks.c ****     listREMOVE_ITEM( pxEventListItem );
3268:FreeRTOS/tasks.c **** 
3269:FreeRTOS/tasks.c ****     #if ( configUSE_TICKLESS_IDLE != 0 )
3270:FreeRTOS/tasks.c ****         {
3271:FreeRTOS/tasks.c ****             /* If a task is blocked on a kernel object then xNextTaskUnblockTime
3272:FreeRTOS/tasks.c ****              * might be set to the blocked task's time out time.  If the task is
3273:FreeRTOS/tasks.c ****              * unblocked for a reason other than a timeout xNextTaskUnblockTime is
3274:FreeRTOS/tasks.c ****              * normally left unchanged, because it is automatically reset to a new
3275:FreeRTOS/tasks.c ****              * value when the tick count equals xNextTaskUnblockTime.  However if
3276:FreeRTOS/tasks.c ****              * tickless idling is used it might be more important to enter sleep mode
3277:FreeRTOS/tasks.c ****              * at the earliest possible time - so reset xNextTaskUnblockTime here to
3278:FreeRTOS/tasks.c ****              * ensure it is updated at the earliest possible time. */
3279:FreeRTOS/tasks.c ****             prvResetNextTaskUnblockTime();
3280:FreeRTOS/tasks.c ****         }
3281:FreeRTOS/tasks.c ****     #endif
3282:FreeRTOS/tasks.c **** 
3283:FreeRTOS/tasks.c ****     /* Remove the task from the delayed list and add it to the ready list.  The
3284:FreeRTOS/tasks.c ****      * scheduler is suspended so interrupts will not be accessing the ready
3285:FreeRTOS/tasks.c ****      * lists. */
3286:FreeRTOS/tasks.c ****     listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
3287:FreeRTOS/tasks.c ****     prvAddTaskToReadyList( pxUnblockedTCB );
3288:FreeRTOS/tasks.c **** 
3289:FreeRTOS/tasks.c ****     if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
ARM GAS  /tmp/ccrgBt0i.s 			page 64


3290:FreeRTOS/tasks.c ****     {
3291:FreeRTOS/tasks.c ****         /* The unblocked task has a priority above that of the calling task, so
3292:FreeRTOS/tasks.c ****          * a context switch is required.  This function is called with the
3293:FreeRTOS/tasks.c ****          * scheduler suspended so xYieldPending is set so the context switch
3294:FreeRTOS/tasks.c ****          * occurs immediately that the scheduler is resumed (unsuspended). */
3295:FreeRTOS/tasks.c ****         xYieldPending = pdTRUE;
3296:FreeRTOS/tasks.c ****     }
3297:FreeRTOS/tasks.c **** }
3298:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3299:FreeRTOS/tasks.c **** 
3300:FreeRTOS/tasks.c **** void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
3301:FreeRTOS/tasks.c **** {
3302:FreeRTOS/tasks.c ****     configASSERT( pxTimeOut );
3303:FreeRTOS/tasks.c ****     taskENTER_CRITICAL();
3304:FreeRTOS/tasks.c ****     {
3305:FreeRTOS/tasks.c ****         pxTimeOut->xOverflowCount = xNumOfOverflows;
3306:FreeRTOS/tasks.c ****         pxTimeOut->xTimeOnEntering = xTickCount;
3307:FreeRTOS/tasks.c ****     }
3308:FreeRTOS/tasks.c ****     taskEXIT_CRITICAL();
3309:FreeRTOS/tasks.c **** }
3310:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3311:FreeRTOS/tasks.c **** 
3312:FreeRTOS/tasks.c **** void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
3313:FreeRTOS/tasks.c **** {
3314:FreeRTOS/tasks.c ****     /* For internal use only as it does not use a critical section. */
3315:FreeRTOS/tasks.c ****     pxTimeOut->xOverflowCount = xNumOfOverflows;
3316:FreeRTOS/tasks.c ****     pxTimeOut->xTimeOnEntering = xTickCount;
3317:FreeRTOS/tasks.c **** }
3318:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3319:FreeRTOS/tasks.c **** 
3320:FreeRTOS/tasks.c **** BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut,
3321:FreeRTOS/tasks.c ****                                  TickType_t * const pxTicksToWait )
3322:FreeRTOS/tasks.c **** {
3323:FreeRTOS/tasks.c ****     BaseType_t xReturn;
3324:FreeRTOS/tasks.c **** 
3325:FreeRTOS/tasks.c ****     configASSERT( pxTimeOut );
3326:FreeRTOS/tasks.c ****     configASSERT( pxTicksToWait );
3327:FreeRTOS/tasks.c **** 
3328:FreeRTOS/tasks.c ****     taskENTER_CRITICAL();
3329:FreeRTOS/tasks.c ****     {
3330:FreeRTOS/tasks.c ****         /* Minor optimisation.  The tick count cannot change in this block. */
3331:FreeRTOS/tasks.c ****         const TickType_t xConstTickCount = xTickCount;
3332:FreeRTOS/tasks.c ****         const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
3333:FreeRTOS/tasks.c **** 
3334:FreeRTOS/tasks.c ****         #if ( INCLUDE_xTaskAbortDelay == 1 )
3335:FreeRTOS/tasks.c ****             if( pxCurrentTCB->ucDelayAborted != ( uint8_t ) pdFALSE )
3336:FreeRTOS/tasks.c ****             {
3337:FreeRTOS/tasks.c ****                 /* The delay was aborted, which is not the same as a time out,
3338:FreeRTOS/tasks.c ****                  * but has the same result. */
3339:FreeRTOS/tasks.c ****                 pxCurrentTCB->ucDelayAborted = pdFALSE;
3340:FreeRTOS/tasks.c ****                 xReturn = pdTRUE;
3341:FreeRTOS/tasks.c ****             }
3342:FreeRTOS/tasks.c ****             else
3343:FreeRTOS/tasks.c ****         #endif
3344:FreeRTOS/tasks.c **** 
3345:FreeRTOS/tasks.c ****         #if ( INCLUDE_vTaskSuspend == 1 )
3346:FreeRTOS/tasks.c ****             if( *pxTicksToWait == portMAX_DELAY )
ARM GAS  /tmp/ccrgBt0i.s 			page 65


3347:FreeRTOS/tasks.c ****             {
3348:FreeRTOS/tasks.c ****                 /* If INCLUDE_vTaskSuspend is set to 1 and the block time
3349:FreeRTOS/tasks.c ****                  * specified is the maximum block time then the task should block
3350:FreeRTOS/tasks.c ****                  * indefinitely, and therefore never time out. */
3351:FreeRTOS/tasks.c ****                 xReturn = pdFALSE;
3352:FreeRTOS/tasks.c ****             }
3353:FreeRTOS/tasks.c ****             else
3354:FreeRTOS/tasks.c ****         #endif
3355:FreeRTOS/tasks.c **** 
3356:FreeRTOS/tasks.c ****         if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTi
3357:FreeRTOS/tasks.c ****         {
3358:FreeRTOS/tasks.c ****             /* The tick count is greater than the time at which
3359:FreeRTOS/tasks.c ****              * vTaskSetTimeout() was called, but has also overflowed since
3360:FreeRTOS/tasks.c ****              * vTaskSetTimeOut() was called.  It must have wrapped all the way
3361:FreeRTOS/tasks.c ****              * around and gone past again. This passed since vTaskSetTimeout()
3362:FreeRTOS/tasks.c ****              * was called. */
3363:FreeRTOS/tasks.c ****             xReturn = pdTRUE;
3364:FreeRTOS/tasks.c ****             *pxTicksToWait = ( TickType_t ) 0;
3365:FreeRTOS/tasks.c ****         }
3366:FreeRTOS/tasks.c ****         else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant wi
3367:FreeRTOS/tasks.c ****         {
3368:FreeRTOS/tasks.c ****             /* Not a genuine timeout. Adjust parameters for time remaining. */
3369:FreeRTOS/tasks.c ****             *pxTicksToWait -= xElapsedTime;
3370:FreeRTOS/tasks.c ****             vTaskInternalSetTimeOutState( pxTimeOut );
3371:FreeRTOS/tasks.c ****             xReturn = pdFALSE;
3372:FreeRTOS/tasks.c ****         }
3373:FreeRTOS/tasks.c ****         else
3374:FreeRTOS/tasks.c ****         {
3375:FreeRTOS/tasks.c ****             *pxTicksToWait = ( TickType_t ) 0;
3376:FreeRTOS/tasks.c ****             xReturn = pdTRUE;
3377:FreeRTOS/tasks.c ****         }
3378:FreeRTOS/tasks.c ****     }
3379:FreeRTOS/tasks.c ****     taskEXIT_CRITICAL();
3380:FreeRTOS/tasks.c **** 
3381:FreeRTOS/tasks.c ****     return xReturn;
3382:FreeRTOS/tasks.c **** }
3383:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3384:FreeRTOS/tasks.c **** 
3385:FreeRTOS/tasks.c **** void vTaskMissedYield( void )
3386:FreeRTOS/tasks.c **** {
3387:FreeRTOS/tasks.c ****     xYieldPending = pdTRUE;
3388:FreeRTOS/tasks.c **** }
3389:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3390:FreeRTOS/tasks.c **** 
3391:FreeRTOS/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
3392:FreeRTOS/tasks.c **** 
3393:FreeRTOS/tasks.c ****     UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask )
3394:FreeRTOS/tasks.c ****     {
3395:FreeRTOS/tasks.c ****         UBaseType_t uxReturn;
3396:FreeRTOS/tasks.c ****         TCB_t const * pxTCB;
3397:FreeRTOS/tasks.c **** 
3398:FreeRTOS/tasks.c ****         if( xTask != NULL )
3399:FreeRTOS/tasks.c ****         {
3400:FreeRTOS/tasks.c ****             pxTCB = xTask;
3401:FreeRTOS/tasks.c ****             uxReturn = pxTCB->uxTaskNumber;
3402:FreeRTOS/tasks.c ****         }
3403:FreeRTOS/tasks.c ****         else
ARM GAS  /tmp/ccrgBt0i.s 			page 66


3404:FreeRTOS/tasks.c ****         {
3405:FreeRTOS/tasks.c ****             uxReturn = 0U;
3406:FreeRTOS/tasks.c ****         }
3407:FreeRTOS/tasks.c **** 
3408:FreeRTOS/tasks.c ****         return uxReturn;
3409:FreeRTOS/tasks.c ****     }
3410:FreeRTOS/tasks.c **** 
3411:FreeRTOS/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
3412:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3413:FreeRTOS/tasks.c **** 
3414:FreeRTOS/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
3415:FreeRTOS/tasks.c **** 
3416:FreeRTOS/tasks.c ****     void vTaskSetTaskNumber( TaskHandle_t xTask,
3417:FreeRTOS/tasks.c ****                              const UBaseType_t uxHandle )
3418:FreeRTOS/tasks.c ****     {
3419:FreeRTOS/tasks.c ****         TCB_t * pxTCB;
3420:FreeRTOS/tasks.c **** 
3421:FreeRTOS/tasks.c ****         if( xTask != NULL )
3422:FreeRTOS/tasks.c ****         {
3423:FreeRTOS/tasks.c ****             pxTCB = xTask;
3424:FreeRTOS/tasks.c ****             pxTCB->uxTaskNumber = uxHandle;
3425:FreeRTOS/tasks.c ****         }
3426:FreeRTOS/tasks.c ****     }
3427:FreeRTOS/tasks.c **** 
3428:FreeRTOS/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
3429:FreeRTOS/tasks.c **** 
3430:FreeRTOS/tasks.c **** /*
3431:FreeRTOS/tasks.c ****  * -----------------------------------------------------------
3432:FreeRTOS/tasks.c ****  * The Idle task.
3433:FreeRTOS/tasks.c ****  * ----------------------------------------------------------
3434:FreeRTOS/tasks.c ****  *
3435:FreeRTOS/tasks.c ****  * The portTASK_FUNCTION() macro is used to allow port/compiler specific
3436:FreeRTOS/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
3437:FreeRTOS/tasks.c ****  *
3438:FreeRTOS/tasks.c ****  * void prvIdleTask( void *pvParameters );
3439:FreeRTOS/tasks.c ****  *
3440:FreeRTOS/tasks.c ****  */
3441:FreeRTOS/tasks.c **** static portTASK_FUNCTION( prvIdleTask, pvParameters )
3442:FreeRTOS/tasks.c **** {
3443:FreeRTOS/tasks.c ****     /* Stop warnings. */
3444:FreeRTOS/tasks.c ****     ( void ) pvParameters;
3445:FreeRTOS/tasks.c **** 
3446:FreeRTOS/tasks.c ****     /** THIS IS THE RTOS IDLE TASK - WHICH IS CREATED AUTOMATICALLY WHEN THE
3447:FreeRTOS/tasks.c ****      * SCHEDULER IS STARTED. **/
3448:FreeRTOS/tasks.c **** 
3449:FreeRTOS/tasks.c ****     /* In case a task that has a secure context deletes itself, in which case
3450:FreeRTOS/tasks.c ****      * the idle task is responsible for deleting the task's secure context, if
3451:FreeRTOS/tasks.c ****      * any. */
3452:FreeRTOS/tasks.c ****     portALLOCATE_SECURE_CONTEXT( configMINIMAL_SECURE_STACK_SIZE );
3453:FreeRTOS/tasks.c **** 
3454:FreeRTOS/tasks.c ****     for( ; ; )
3455:FreeRTOS/tasks.c ****     {
3456:FreeRTOS/tasks.c ****         /* See if any tasks have deleted themselves - if so then the idle task
3457:FreeRTOS/tasks.c ****          * is responsible for freeing the deleted task's TCB and stack. */
3458:FreeRTOS/tasks.c ****         prvCheckTasksWaitingTermination();
3459:FreeRTOS/tasks.c **** 
3460:FreeRTOS/tasks.c ****         #if ( configUSE_PREEMPTION == 0 )
ARM GAS  /tmp/ccrgBt0i.s 			page 67


3461:FreeRTOS/tasks.c ****             {
3462:FreeRTOS/tasks.c ****                 /* If we are not using preemption we keep forcing a task switch to
3463:FreeRTOS/tasks.c ****                  * see if any other task has become available.  If we are using
3464:FreeRTOS/tasks.c ****                  * preemption we don't need to do this as any task becoming available
3465:FreeRTOS/tasks.c ****                  * will automatically get the processor anyway. */
3466:FreeRTOS/tasks.c ****                 taskYIELD();
3467:FreeRTOS/tasks.c ****             }
3468:FreeRTOS/tasks.c ****         #endif /* configUSE_PREEMPTION */
3469:FreeRTOS/tasks.c **** 
3470:FreeRTOS/tasks.c ****         #if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
3471:FreeRTOS/tasks.c ****             {
3472:FreeRTOS/tasks.c ****                 /* When using preemption tasks of equal priority will be
3473:FreeRTOS/tasks.c ****                  * timesliced.  If a task that is sharing the idle priority is ready
3474:FreeRTOS/tasks.c ****                  * to run then the idle task should yield before the end of the
3475:FreeRTOS/tasks.c ****                  * timeslice.
3476:FreeRTOS/tasks.c ****                  *
3477:FreeRTOS/tasks.c ****                  * A critical region is not required here as we are just reading from
3478:FreeRTOS/tasks.c ****                  * the list, and an occasional incorrect value will not matter.  If
3479:FreeRTOS/tasks.c ****                  * the ready list at the idle priority contains more than one task
3480:FreeRTOS/tasks.c ****                  * then a task other than the idle task is ready to execute. */
3481:FreeRTOS/tasks.c ****                 if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBase
3482:FreeRTOS/tasks.c ****                 {
3483:FreeRTOS/tasks.c ****                     taskYIELD();
3484:FreeRTOS/tasks.c ****                 }
3485:FreeRTOS/tasks.c ****                 else
3486:FreeRTOS/tasks.c ****                 {
3487:FreeRTOS/tasks.c ****                     mtCOVERAGE_TEST_MARKER();
3488:FreeRTOS/tasks.c ****                 }
3489:FreeRTOS/tasks.c ****             }
3490:FreeRTOS/tasks.c ****         #endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */
3491:FreeRTOS/tasks.c **** 
3492:FreeRTOS/tasks.c ****         #if ( configUSE_IDLE_HOOK == 1 )
3493:FreeRTOS/tasks.c ****             {
3494:FreeRTOS/tasks.c ****                 extern void vApplicationIdleHook( void );
3495:FreeRTOS/tasks.c **** 
3496:FreeRTOS/tasks.c ****                 /* Call the user defined function from within the idle task.  This
3497:FreeRTOS/tasks.c ****                  * allows the application designer to add background functionality
3498:FreeRTOS/tasks.c ****                  * without the overhead of a separate task.
3499:FreeRTOS/tasks.c ****                  * NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
3500:FreeRTOS/tasks.c ****                  * CALL A FUNCTION THAT MIGHT BLOCK. */
3501:FreeRTOS/tasks.c ****                 vApplicationIdleHook();
3502:FreeRTOS/tasks.c ****             }
3503:FreeRTOS/tasks.c ****         #endif /* configUSE_IDLE_HOOK */
3504:FreeRTOS/tasks.c **** 
3505:FreeRTOS/tasks.c ****         /* This conditional compilation should use inequality to 0, not equality
3506:FreeRTOS/tasks.c ****          * to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
3507:FreeRTOS/tasks.c ****          * user defined low power mode  implementations require
3508:FreeRTOS/tasks.c ****          * configUSE_TICKLESS_IDLE to be set to a value other than 1. */
3509:FreeRTOS/tasks.c ****         #if ( configUSE_TICKLESS_IDLE != 0 )
3510:FreeRTOS/tasks.c ****             {
3511:FreeRTOS/tasks.c ****                 TickType_t xExpectedIdleTime;
3512:FreeRTOS/tasks.c **** 
3513:FreeRTOS/tasks.c ****                 /* It is not desirable to suspend then resume the scheduler on
3514:FreeRTOS/tasks.c ****                  * each iteration of the idle task.  Therefore, a preliminary
3515:FreeRTOS/tasks.c ****                  * test of the expected idle time is performed without the
3516:FreeRTOS/tasks.c ****                  * scheduler suspended.  The result here is not necessarily
3517:FreeRTOS/tasks.c ****                  * valid. */
ARM GAS  /tmp/ccrgBt0i.s 			page 68


3518:FreeRTOS/tasks.c ****                 xExpectedIdleTime = prvGetExpectedIdleTime();
3519:FreeRTOS/tasks.c **** 
3520:FreeRTOS/tasks.c ****                 if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
3521:FreeRTOS/tasks.c ****                 {
3522:FreeRTOS/tasks.c ****                     vTaskSuspendAll();
3523:FreeRTOS/tasks.c ****                     {
3524:FreeRTOS/tasks.c ****                         /* Now the scheduler is suspended, the expected idle
3525:FreeRTOS/tasks.c ****                          * time can be sampled again, and this time its value can
3526:FreeRTOS/tasks.c ****                          * be used. */
3527:FreeRTOS/tasks.c ****                         configASSERT( xNextTaskUnblockTime >= xTickCount );
3528:FreeRTOS/tasks.c ****                         xExpectedIdleTime = prvGetExpectedIdleTime();
3529:FreeRTOS/tasks.c **** 
3530:FreeRTOS/tasks.c ****                         /* Define the following macro to set xExpectedIdleTime to 0
3531:FreeRTOS/tasks.c ****                          * if the application does not want
3532:FreeRTOS/tasks.c ****                          * portSUPPRESS_TICKS_AND_SLEEP() to be called. */
3533:FreeRTOS/tasks.c ****                         configPRE_SUPPRESS_TICKS_AND_SLEEP_PROCESSING( xExpectedIdleTime );
3534:FreeRTOS/tasks.c **** 
3535:FreeRTOS/tasks.c ****                         if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
3536:FreeRTOS/tasks.c ****                         {
3537:FreeRTOS/tasks.c ****                             traceLOW_POWER_IDLE_BEGIN();
3538:FreeRTOS/tasks.c ****                             portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
3539:FreeRTOS/tasks.c ****                             traceLOW_POWER_IDLE_END();
3540:FreeRTOS/tasks.c ****                         }
3541:FreeRTOS/tasks.c ****                         else
3542:FreeRTOS/tasks.c ****                         {
3543:FreeRTOS/tasks.c ****                             mtCOVERAGE_TEST_MARKER();
3544:FreeRTOS/tasks.c ****                         }
3545:FreeRTOS/tasks.c ****                     }
3546:FreeRTOS/tasks.c ****                     ( void ) xTaskResumeAll();
3547:FreeRTOS/tasks.c ****                 }
3548:FreeRTOS/tasks.c ****                 else
3549:FreeRTOS/tasks.c ****                 {
3550:FreeRTOS/tasks.c ****                     mtCOVERAGE_TEST_MARKER();
3551:FreeRTOS/tasks.c ****                 }
3552:FreeRTOS/tasks.c ****             }
3553:FreeRTOS/tasks.c ****         #endif /* configUSE_TICKLESS_IDLE */
3554:FreeRTOS/tasks.c ****     }
3555:FreeRTOS/tasks.c **** }
3556:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3557:FreeRTOS/tasks.c **** 
3558:FreeRTOS/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
3559:FreeRTOS/tasks.c **** 
3560:FreeRTOS/tasks.c ****     eSleepModeStatus eTaskConfirmSleepModeStatus( void )
3561:FreeRTOS/tasks.c ****     {
3562:FreeRTOS/tasks.c ****         /* The idle task exists in addition to the application tasks. */
3563:FreeRTOS/tasks.c ****         const UBaseType_t uxNonApplicationTasks = 1;
3564:FreeRTOS/tasks.c ****         eSleepModeStatus eReturn = eStandardSleep;
3565:FreeRTOS/tasks.c **** 
3566:FreeRTOS/tasks.c ****         /* This function must be called from a critical section. */
3567:FreeRTOS/tasks.c **** 
3568:FreeRTOS/tasks.c ****         if( listCURRENT_LIST_LENGTH( &xPendingReadyList ) != 0 )
3569:FreeRTOS/tasks.c ****         {
3570:FreeRTOS/tasks.c ****             /* A task was made ready while the scheduler was suspended. */
3571:FreeRTOS/tasks.c ****             eReturn = eAbortSleep;
3572:FreeRTOS/tasks.c ****         }
3573:FreeRTOS/tasks.c ****         else if( xYieldPending != pdFALSE )
3574:FreeRTOS/tasks.c ****         {
ARM GAS  /tmp/ccrgBt0i.s 			page 69


3575:FreeRTOS/tasks.c ****             /* A yield was pended while the scheduler was suspended. */
3576:FreeRTOS/tasks.c ****             eReturn = eAbortSleep;
3577:FreeRTOS/tasks.c ****         }
3578:FreeRTOS/tasks.c ****         else if( xPendedTicks != 0 )
3579:FreeRTOS/tasks.c ****         {
3580:FreeRTOS/tasks.c ****             /* A tick interrupt has already occurred but was held pending
3581:FreeRTOS/tasks.c ****              * because the scheduler is suspended. */
3582:FreeRTOS/tasks.c ****             eReturn = eAbortSleep;
3583:FreeRTOS/tasks.c ****         }
3584:FreeRTOS/tasks.c ****         else
3585:FreeRTOS/tasks.c ****         {
3586:FreeRTOS/tasks.c ****             /* If all the tasks are in the suspended list (which might mean they
3587:FreeRTOS/tasks.c ****              * have an infinite block time rather than actually being suspended)
3588:FreeRTOS/tasks.c ****              * then it is safe to turn all clocks off and just wait for external
3589:FreeRTOS/tasks.c ****              * interrupts. */
3590:FreeRTOS/tasks.c ****             if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == ( uxCurrentNumberOfTasks - uxNonA
3591:FreeRTOS/tasks.c ****             {
3592:FreeRTOS/tasks.c ****                 eReturn = eNoTasksWaitingTimeout;
3593:FreeRTOS/tasks.c ****             }
3594:FreeRTOS/tasks.c ****             else
3595:FreeRTOS/tasks.c ****             {
3596:FreeRTOS/tasks.c ****                 mtCOVERAGE_TEST_MARKER();
3597:FreeRTOS/tasks.c ****             }
3598:FreeRTOS/tasks.c ****         }
3599:FreeRTOS/tasks.c **** 
3600:FreeRTOS/tasks.c ****         return eReturn;
3601:FreeRTOS/tasks.c ****     }
3602:FreeRTOS/tasks.c **** 
3603:FreeRTOS/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
3604:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3605:FreeRTOS/tasks.c **** 
3606:FreeRTOS/tasks.c **** #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
3607:FreeRTOS/tasks.c **** 
3608:FreeRTOS/tasks.c ****     void vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet,
3609:FreeRTOS/tasks.c ****                                             BaseType_t xIndex,
3610:FreeRTOS/tasks.c ****                                             void * pvValue )
3611:FreeRTOS/tasks.c ****     {
3612:FreeRTOS/tasks.c ****         TCB_t * pxTCB;
3613:FreeRTOS/tasks.c **** 
3614:FreeRTOS/tasks.c ****         if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
3615:FreeRTOS/tasks.c ****         {
3616:FreeRTOS/tasks.c ****             pxTCB = prvGetTCBFromHandle( xTaskToSet );
3617:FreeRTOS/tasks.c ****             configASSERT( pxTCB != NULL );
3618:FreeRTOS/tasks.c ****             pxTCB->pvThreadLocalStoragePointers[ xIndex ] = pvValue;
3619:FreeRTOS/tasks.c ****         }
3620:FreeRTOS/tasks.c ****     }
3621:FreeRTOS/tasks.c **** 
3622:FreeRTOS/tasks.c **** #endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
3623:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3624:FreeRTOS/tasks.c **** 
3625:FreeRTOS/tasks.c **** #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
3626:FreeRTOS/tasks.c **** 
3627:FreeRTOS/tasks.c ****     void * pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery,
3628:FreeRTOS/tasks.c ****                                                BaseType_t xIndex )
3629:FreeRTOS/tasks.c ****     {
3630:FreeRTOS/tasks.c ****         void * pvReturn = NULL;
3631:FreeRTOS/tasks.c ****         TCB_t * pxTCB;
ARM GAS  /tmp/ccrgBt0i.s 			page 70


3632:FreeRTOS/tasks.c **** 
3633:FreeRTOS/tasks.c ****         if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
3634:FreeRTOS/tasks.c ****         {
3635:FreeRTOS/tasks.c ****             pxTCB = prvGetTCBFromHandle( xTaskToQuery );
3636:FreeRTOS/tasks.c ****             pvReturn = pxTCB->pvThreadLocalStoragePointers[ xIndex ];
3637:FreeRTOS/tasks.c ****         }
3638:FreeRTOS/tasks.c ****         else
3639:FreeRTOS/tasks.c ****         {
3640:FreeRTOS/tasks.c ****             pvReturn = NULL;
3641:FreeRTOS/tasks.c ****         }
3642:FreeRTOS/tasks.c **** 
3643:FreeRTOS/tasks.c ****         return pvReturn;
3644:FreeRTOS/tasks.c ****     }
3645:FreeRTOS/tasks.c **** 
3646:FreeRTOS/tasks.c **** #endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
3647:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3648:FreeRTOS/tasks.c **** 
3649:FreeRTOS/tasks.c **** #if ( portUSING_MPU_WRAPPERS == 1 )
3650:FreeRTOS/tasks.c **** 
3651:FreeRTOS/tasks.c ****     void vTaskAllocateMPURegions( TaskHandle_t xTaskToModify,
3652:FreeRTOS/tasks.c ****                                   const MemoryRegion_t * const xRegions )
3653:FreeRTOS/tasks.c ****     {
3654:FreeRTOS/tasks.c ****         TCB_t * pxTCB;
3655:FreeRTOS/tasks.c **** 
3656:FreeRTOS/tasks.c ****         /* If null is passed in here then we are modifying the MPU settings of
3657:FreeRTOS/tasks.c ****          * the calling task. */
3658:FreeRTOS/tasks.c ****         pxTCB = prvGetTCBFromHandle( xTaskToModify );
3659:FreeRTOS/tasks.c **** 
3660:FreeRTOS/tasks.c ****         vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
3661:FreeRTOS/tasks.c ****     }
3662:FreeRTOS/tasks.c **** 
3663:FreeRTOS/tasks.c **** #endif /* portUSING_MPU_WRAPPERS */
3664:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3665:FreeRTOS/tasks.c **** 
3666:FreeRTOS/tasks.c **** static void prvInitialiseTaskLists( void )
3667:FreeRTOS/tasks.c **** {
3668:FreeRTOS/tasks.c ****     UBaseType_t uxPriority;
3669:FreeRTOS/tasks.c **** 
3670:FreeRTOS/tasks.c ****     for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPrio
3671:FreeRTOS/tasks.c ****     {
3672:FreeRTOS/tasks.c ****         vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
3673:FreeRTOS/tasks.c ****     }
3674:FreeRTOS/tasks.c **** 
3675:FreeRTOS/tasks.c ****     vListInitialise( &xDelayedTaskList1 );
3676:FreeRTOS/tasks.c ****     vListInitialise( &xDelayedTaskList2 );
3677:FreeRTOS/tasks.c ****     vListInitialise( &xPendingReadyList );
3678:FreeRTOS/tasks.c **** 
3679:FreeRTOS/tasks.c ****     #if ( INCLUDE_vTaskDelete == 1 )
3680:FreeRTOS/tasks.c ****         {
3681:FreeRTOS/tasks.c ****             vListInitialise( &xTasksWaitingTermination );
3682:FreeRTOS/tasks.c ****         }
3683:FreeRTOS/tasks.c ****     #endif /* INCLUDE_vTaskDelete */
3684:FreeRTOS/tasks.c **** 
3685:FreeRTOS/tasks.c ****     #if ( INCLUDE_vTaskSuspend == 1 )
3686:FreeRTOS/tasks.c ****         {
3687:FreeRTOS/tasks.c ****             vListInitialise( &xSuspendedTaskList );
3688:FreeRTOS/tasks.c ****         }
ARM GAS  /tmp/ccrgBt0i.s 			page 71


3689:FreeRTOS/tasks.c ****     #endif /* INCLUDE_vTaskSuspend */
3690:FreeRTOS/tasks.c **** 
3691:FreeRTOS/tasks.c ****     /* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
3692:FreeRTOS/tasks.c ****      * using list2. */
3693:FreeRTOS/tasks.c ****     pxDelayedTaskList = &xDelayedTaskList1;
3694:FreeRTOS/tasks.c ****     pxOverflowDelayedTaskList = &xDelayedTaskList2;
3695:FreeRTOS/tasks.c **** }
3696:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3697:FreeRTOS/tasks.c **** 
3698:FreeRTOS/tasks.c **** static void prvCheckTasksWaitingTermination( void )
3699:FreeRTOS/tasks.c **** {
3700:FreeRTOS/tasks.c ****     /** THIS FUNCTION IS CALLED FROM THE RTOS IDLE TASK **/
3701:FreeRTOS/tasks.c **** 
3702:FreeRTOS/tasks.c ****     #if ( INCLUDE_vTaskDelete == 1 )
3703:FreeRTOS/tasks.c ****         {
3704:FreeRTOS/tasks.c ****             TCB_t * pxTCB;
3705:FreeRTOS/tasks.c **** 
3706:FreeRTOS/tasks.c ****             /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
3707:FreeRTOS/tasks.c ****              * being called too often in the idle task. */
3708:FreeRTOS/tasks.c ****             while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
3709:FreeRTOS/tasks.c ****             {
3710:FreeRTOS/tasks.c ****                 taskENTER_CRITICAL();
3711:FreeRTOS/tasks.c ****                 {
3712:FreeRTOS/tasks.c ****                     pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e
3713:FreeRTOS/tasks.c ****                     ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
3714:FreeRTOS/tasks.c ****                     --uxCurrentNumberOfTasks;
3715:FreeRTOS/tasks.c ****                     --uxDeletedTasksWaitingCleanUp;
3716:FreeRTOS/tasks.c ****                 }
3717:FreeRTOS/tasks.c ****                 taskEXIT_CRITICAL();
3718:FreeRTOS/tasks.c **** 
3719:FreeRTOS/tasks.c ****                 prvDeleteTCB( pxTCB );
3720:FreeRTOS/tasks.c ****             }
3721:FreeRTOS/tasks.c ****         }
3722:FreeRTOS/tasks.c ****     #endif /* INCLUDE_vTaskDelete */
3723:FreeRTOS/tasks.c **** }
3724:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3725:FreeRTOS/tasks.c **** 
3726:FreeRTOS/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
3727:FreeRTOS/tasks.c **** 
3728:FreeRTOS/tasks.c ****     void vTaskGetInfo( TaskHandle_t xTask,
3729:FreeRTOS/tasks.c ****                        TaskStatus_t * pxTaskStatus,
3730:FreeRTOS/tasks.c ****                        BaseType_t xGetFreeStackSpace,
3731:FreeRTOS/tasks.c ****                        eTaskState eState )
3732:FreeRTOS/tasks.c ****     {
3733:FreeRTOS/tasks.c ****         TCB_t * pxTCB;
3734:FreeRTOS/tasks.c **** 
3735:FreeRTOS/tasks.c ****         /* xTask is NULL then get the state of the calling task. */
3736:FreeRTOS/tasks.c ****         pxTCB = prvGetTCBFromHandle( xTask );
3737:FreeRTOS/tasks.c **** 
3738:FreeRTOS/tasks.c ****         pxTaskStatus->xHandle = ( TaskHandle_t ) pxTCB;
3739:FreeRTOS/tasks.c ****         pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName[ 0 ] );
3740:FreeRTOS/tasks.c ****         pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
3741:FreeRTOS/tasks.c ****         pxTaskStatus->pxStackBase = pxTCB->pxStack;
3742:FreeRTOS/tasks.c ****         pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;
3743:FreeRTOS/tasks.c **** 
3744:FreeRTOS/tasks.c ****         #if ( configUSE_MUTEXES == 1 )
3745:FreeRTOS/tasks.c ****             {
ARM GAS  /tmp/ccrgBt0i.s 			page 72


3746:FreeRTOS/tasks.c ****                 pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
3747:FreeRTOS/tasks.c ****             }
3748:FreeRTOS/tasks.c ****         #else
3749:FreeRTOS/tasks.c ****             {
3750:FreeRTOS/tasks.c ****                 pxTaskStatus->uxBasePriority = 0;
3751:FreeRTOS/tasks.c ****             }
3752:FreeRTOS/tasks.c ****         #endif
3753:FreeRTOS/tasks.c **** 
3754:FreeRTOS/tasks.c ****         #if ( configGENERATE_RUN_TIME_STATS == 1 )
3755:FreeRTOS/tasks.c ****             {
3756:FreeRTOS/tasks.c ****                 pxTaskStatus->ulRunTimeCounter = pxTCB->ulRunTimeCounter;
3757:FreeRTOS/tasks.c ****             }
3758:FreeRTOS/tasks.c ****         #else
3759:FreeRTOS/tasks.c ****             {
3760:FreeRTOS/tasks.c ****                 pxTaskStatus->ulRunTimeCounter = ( configRUN_TIME_COUNTER_TYPE ) 0;
3761:FreeRTOS/tasks.c ****             }
3762:FreeRTOS/tasks.c ****         #endif
3763:FreeRTOS/tasks.c **** 
3764:FreeRTOS/tasks.c ****         /* Obtaining the task state is a little fiddly, so is only done if the
3765:FreeRTOS/tasks.c ****          * value of eState passed into this function is eInvalid - otherwise the
3766:FreeRTOS/tasks.c ****          * state is just set to whatever is passed in. */
3767:FreeRTOS/tasks.c ****         if( eState != eInvalid )
3768:FreeRTOS/tasks.c ****         {
3769:FreeRTOS/tasks.c ****             if( pxTCB == pxCurrentTCB )
3770:FreeRTOS/tasks.c ****             {
3771:FreeRTOS/tasks.c ****                 pxTaskStatus->eCurrentState = eRunning;
3772:FreeRTOS/tasks.c ****             }
3773:FreeRTOS/tasks.c ****             else
3774:FreeRTOS/tasks.c ****             {
3775:FreeRTOS/tasks.c ****                 pxTaskStatus->eCurrentState = eState;
3776:FreeRTOS/tasks.c **** 
3777:FreeRTOS/tasks.c ****                 #if ( INCLUDE_vTaskSuspend == 1 )
3778:FreeRTOS/tasks.c ****                     {
3779:FreeRTOS/tasks.c ****                         /* If the task is in the suspended list then there is a
3780:FreeRTOS/tasks.c ****                          *  chance it is actually just blocked indefinitely - so really
3781:FreeRTOS/tasks.c ****                          *  it should be reported as being in the Blocked state. */
3782:FreeRTOS/tasks.c ****                         if( eState == eSuspended )
3783:FreeRTOS/tasks.c ****                         {
3784:FreeRTOS/tasks.c ****                             vTaskSuspendAll();
3785:FreeRTOS/tasks.c ****                             {
3786:FreeRTOS/tasks.c ****                                 if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
3787:FreeRTOS/tasks.c ****                                 {
3788:FreeRTOS/tasks.c ****                                     pxTaskStatus->eCurrentState = eBlocked;
3789:FreeRTOS/tasks.c ****                                 }
3790:FreeRTOS/tasks.c ****                             }
3791:FreeRTOS/tasks.c ****                             ( void ) xTaskResumeAll();
3792:FreeRTOS/tasks.c ****                         }
3793:FreeRTOS/tasks.c ****                     }
3794:FreeRTOS/tasks.c ****                 #endif /* INCLUDE_vTaskSuspend */
3795:FreeRTOS/tasks.c ****             }
3796:FreeRTOS/tasks.c ****         }
3797:FreeRTOS/tasks.c ****         else
3798:FreeRTOS/tasks.c ****         {
3799:FreeRTOS/tasks.c ****             pxTaskStatus->eCurrentState = eTaskGetState( pxTCB );
3800:FreeRTOS/tasks.c ****         }
3801:FreeRTOS/tasks.c **** 
3802:FreeRTOS/tasks.c ****         /* Obtaining the stack space takes some time, so the xGetFreeStackSpace
ARM GAS  /tmp/ccrgBt0i.s 			page 73


3803:FreeRTOS/tasks.c ****          * parameter is provided to allow it to be skipped. */
3804:FreeRTOS/tasks.c ****         if( xGetFreeStackSpace != pdFALSE )
3805:FreeRTOS/tasks.c ****         {
3806:FreeRTOS/tasks.c ****             #if ( portSTACK_GROWTH > 0 )
3807:FreeRTOS/tasks.c ****                 {
3808:FreeRTOS/tasks.c ****                     pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) 
3809:FreeRTOS/tasks.c ****                 }
3810:FreeRTOS/tasks.c ****             #else
3811:FreeRTOS/tasks.c ****                 {
3812:FreeRTOS/tasks.c ****                     pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) 
3813:FreeRTOS/tasks.c ****                 }
3814:FreeRTOS/tasks.c ****             #endif
3815:FreeRTOS/tasks.c ****         }
3816:FreeRTOS/tasks.c ****         else
3817:FreeRTOS/tasks.c ****         {
3818:FreeRTOS/tasks.c ****             pxTaskStatus->usStackHighWaterMark = 0;
3819:FreeRTOS/tasks.c ****         }
3820:FreeRTOS/tasks.c ****     }
3821:FreeRTOS/tasks.c **** 
3822:FreeRTOS/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
3823:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3824:FreeRTOS/tasks.c **** 
3825:FreeRTOS/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
3826:FreeRTOS/tasks.c **** 
3827:FreeRTOS/tasks.c ****     static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t * pxTaskStatusArray,
3828:FreeRTOS/tasks.c ****                                                      List_t * pxList,
3829:FreeRTOS/tasks.c ****                                                      eTaskState eState )
3830:FreeRTOS/tasks.c ****     {
3831:FreeRTOS/tasks.c ****         configLIST_VOLATILE TCB_t * pxNextTCB, * pxFirstTCB;
3832:FreeRTOS/tasks.c ****         UBaseType_t uxTask = 0;
3833:FreeRTOS/tasks.c **** 
3834:FreeRTOS/tasks.c ****         if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
3835:FreeRTOS/tasks.c ****         {
3836:FreeRTOS/tasks.c ****             listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList ); /*lint !e9079 void * is used as this
3837:FreeRTOS/tasks.c **** 
3838:FreeRTOS/tasks.c ****             /* Populate an TaskStatus_t structure within the
3839:FreeRTOS/tasks.c ****              * pxTaskStatusArray array for each task that is referenced from
3840:FreeRTOS/tasks.c ****              * pxList.  See the definition of TaskStatus_t in task.h for the
3841:FreeRTOS/tasks.c ****              * meaning of each TaskStatus_t structure member. */
3842:FreeRTOS/tasks.c ****             do
3843:FreeRTOS/tasks.c ****             {
3844:FreeRTOS/tasks.c ****                 listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList ); /*lint !e9079 void * is used as t
3845:FreeRTOS/tasks.c ****                 vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE,
3846:FreeRTOS/tasks.c ****                 uxTask++;
3847:FreeRTOS/tasks.c ****             } while( pxNextTCB != pxFirstTCB );
3848:FreeRTOS/tasks.c ****         }
3849:FreeRTOS/tasks.c ****         else
3850:FreeRTOS/tasks.c ****         {
3851:FreeRTOS/tasks.c ****             mtCOVERAGE_TEST_MARKER();
3852:FreeRTOS/tasks.c ****         }
3853:FreeRTOS/tasks.c **** 
3854:FreeRTOS/tasks.c ****         return uxTask;
3855:FreeRTOS/tasks.c ****     }
3856:FreeRTOS/tasks.c **** 
3857:FreeRTOS/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
3858:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3859:FreeRTOS/tasks.c **** 
ARM GAS  /tmp/ccrgBt0i.s 			page 74


3860:FreeRTOS/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) || ( INCLUD
3861:FreeRTOS/tasks.c **** 
3862:FreeRTOS/tasks.c ****     static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
3863:FreeRTOS/tasks.c ****     {
3864:FreeRTOS/tasks.c ****         uint32_t ulCount = 0U;
3865:FreeRTOS/tasks.c **** 
3866:FreeRTOS/tasks.c ****         while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
3867:FreeRTOS/tasks.c ****         {
3868:FreeRTOS/tasks.c ****             pucStackByte -= portSTACK_GROWTH;
3869:FreeRTOS/tasks.c ****             ulCount++;
3870:FreeRTOS/tasks.c ****         }
3871:FreeRTOS/tasks.c **** 
3872:FreeRTOS/tasks.c ****         ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on sma
3873:FreeRTOS/tasks.c **** 
3874:FreeRTOS/tasks.c ****         return ( configSTACK_DEPTH_TYPE ) ulCount;
3875:FreeRTOS/tasks.c ****     }
3876:FreeRTOS/tasks.c **** 
3877:FreeRTOS/tasks.c **** #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) || ( 
3878:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3879:FreeRTOS/tasks.c **** 
3880:FreeRTOS/tasks.c **** #if ( INCLUDE_uxTaskGetStackHighWaterMark2 == 1 )
3881:FreeRTOS/tasks.c **** 
3882:FreeRTOS/tasks.c **** /* uxTaskGetStackHighWaterMark() and uxTaskGetStackHighWaterMark2() are the
3883:FreeRTOS/tasks.c ****  * same except for their return type.  Using configSTACK_DEPTH_TYPE allows the
3884:FreeRTOS/tasks.c ****  * user to determine the return type.  It gets around the problem of the value
3885:FreeRTOS/tasks.c ****  * overflowing on 8-bit types without breaking backward compatibility for
3886:FreeRTOS/tasks.c ****  * applications that expect an 8-bit return type. */
3887:FreeRTOS/tasks.c ****     configSTACK_DEPTH_TYPE uxTaskGetStackHighWaterMark2( TaskHandle_t xTask )
3888:FreeRTOS/tasks.c ****     {
3889:FreeRTOS/tasks.c ****         TCB_t * pxTCB;
3890:FreeRTOS/tasks.c ****         uint8_t * pucEndOfStack;
3891:FreeRTOS/tasks.c ****         configSTACK_DEPTH_TYPE uxReturn;
3892:FreeRTOS/tasks.c **** 
3893:FreeRTOS/tasks.c ****         /* uxTaskGetStackHighWaterMark() and uxTaskGetStackHighWaterMark2() are
3894:FreeRTOS/tasks.c ****          * the same except for their return type.  Using configSTACK_DEPTH_TYPE
3895:FreeRTOS/tasks.c ****          * allows the user to determine the return type.  It gets around the
3896:FreeRTOS/tasks.c ****          * problem of the value overflowing on 8-bit types without breaking
3897:FreeRTOS/tasks.c ****          * backward compatibility for applications that expect an 8-bit return
3898:FreeRTOS/tasks.c ****          * type. */
3899:FreeRTOS/tasks.c **** 
3900:FreeRTOS/tasks.c ****         pxTCB = prvGetTCBFromHandle( xTask );
3901:FreeRTOS/tasks.c **** 
3902:FreeRTOS/tasks.c ****         #if portSTACK_GROWTH < 0
3903:FreeRTOS/tasks.c ****             {
3904:FreeRTOS/tasks.c ****                 pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
3905:FreeRTOS/tasks.c ****             }
3906:FreeRTOS/tasks.c ****         #else
3907:FreeRTOS/tasks.c ****             {
3908:FreeRTOS/tasks.c ****                 pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
3909:FreeRTOS/tasks.c ****             }
3910:FreeRTOS/tasks.c ****         #endif
3911:FreeRTOS/tasks.c **** 
3912:FreeRTOS/tasks.c ****         uxReturn = prvTaskCheckFreeStackSpace( pucEndOfStack );
3913:FreeRTOS/tasks.c **** 
3914:FreeRTOS/tasks.c ****         return uxReturn;
3915:FreeRTOS/tasks.c ****     }
3916:FreeRTOS/tasks.c **** 
ARM GAS  /tmp/ccrgBt0i.s 			page 75


3917:FreeRTOS/tasks.c **** #endif /* INCLUDE_uxTaskGetStackHighWaterMark2 */
3918:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3919:FreeRTOS/tasks.c **** 
3920:FreeRTOS/tasks.c **** #if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
3921:FreeRTOS/tasks.c **** 
3922:FreeRTOS/tasks.c ****     UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )
3923:FreeRTOS/tasks.c ****     {
3924:FreeRTOS/tasks.c ****         TCB_t * pxTCB;
3925:FreeRTOS/tasks.c ****         uint8_t * pucEndOfStack;
3926:FreeRTOS/tasks.c ****         UBaseType_t uxReturn;
3927:FreeRTOS/tasks.c **** 
3928:FreeRTOS/tasks.c ****         pxTCB = prvGetTCBFromHandle( xTask );
3929:FreeRTOS/tasks.c **** 
3930:FreeRTOS/tasks.c ****         #if portSTACK_GROWTH < 0
3931:FreeRTOS/tasks.c ****             {
3932:FreeRTOS/tasks.c ****                 pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
3933:FreeRTOS/tasks.c ****             }
3934:FreeRTOS/tasks.c ****         #else
3935:FreeRTOS/tasks.c ****             {
3936:FreeRTOS/tasks.c ****                 pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
3937:FreeRTOS/tasks.c ****             }
3938:FreeRTOS/tasks.c ****         #endif
3939:FreeRTOS/tasks.c **** 
3940:FreeRTOS/tasks.c ****         uxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );
3941:FreeRTOS/tasks.c **** 
3942:FreeRTOS/tasks.c ****         return uxReturn;
3943:FreeRTOS/tasks.c ****     }
3944:FreeRTOS/tasks.c **** 
3945:FreeRTOS/tasks.c **** #endif /* INCLUDE_uxTaskGetStackHighWaterMark */
3946:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
3947:FreeRTOS/tasks.c **** 
3948:FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
3949:FreeRTOS/tasks.c **** 
3950:FreeRTOS/tasks.c ****     static void prvDeleteTCB( TCB_t * pxTCB )
3951:FreeRTOS/tasks.c ****     {
3952:FreeRTOS/tasks.c ****         /* This call is required specifically for the TriCore port.  It must be
3953:FreeRTOS/tasks.c ****          * above the vPortFree() calls.  The call is also used by ports/demos that
3954:FreeRTOS/tasks.c ****          * want to allocate and clean RAM statically. */
3955:FreeRTOS/tasks.c ****         portCLEAN_UP_TCB( pxTCB );
3956:FreeRTOS/tasks.c **** 
3957:FreeRTOS/tasks.c ****         /* Free up the memory allocated by the scheduler for the task.  It is up
3958:FreeRTOS/tasks.c ****          * to the task to free any memory allocated at the application level.
3959:FreeRTOS/tasks.c ****          * See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html
3960:FreeRTOS/tasks.c ****          * for additional information. */
3961:FreeRTOS/tasks.c ****         #if ( configUSE_NEWLIB_REENTRANT == 1 )
3962:FreeRTOS/tasks.c ****             {
3963:FreeRTOS/tasks.c ****                 _reclaim_reent( &( pxTCB->xNewLib_reent ) );
3964:FreeRTOS/tasks.c ****             }
3965:FreeRTOS/tasks.c ****         #endif /* configUSE_NEWLIB_REENTRANT */
3966:FreeRTOS/tasks.c **** 
3967:FreeRTOS/tasks.c ****         #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 )
3968:FreeRTOS/tasks.c ****             {
3969:FreeRTOS/tasks.c ****                 /* The task can only have been allocated dynamically - free both
3970:FreeRTOS/tasks.c ****                  * the stack and TCB. */
3971:FreeRTOS/tasks.c ****                 vPortFreeStack( pxTCB->pxStack );
3972:FreeRTOS/tasks.c ****                 vPortFree( pxTCB );
3973:FreeRTOS/tasks.c ****             }
ARM GAS  /tmp/ccrgBt0i.s 			page 76


3974:FreeRTOS/tasks.c ****         #elif ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been
3975:FreeRTOS/tasks.c ****             {
3976:FreeRTOS/tasks.c ****                 /* The task could have been allocated statically or dynamically, so
3977:FreeRTOS/tasks.c ****                  * check what was statically allocated before trying to free the
3978:FreeRTOS/tasks.c ****                  * memory. */
3979:FreeRTOS/tasks.c ****                 if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
3980:FreeRTOS/tasks.c ****                 {
3981:FreeRTOS/tasks.c ****                     /* Both the stack and TCB were allocated dynamically, so both
3982:FreeRTOS/tasks.c ****                      * must be freed. */
3983:FreeRTOS/tasks.c ****                     vPortFreeStack( pxTCB->pxStack );
3984:FreeRTOS/tasks.c ****                     vPortFree( pxTCB );
3985:FreeRTOS/tasks.c ****                 }
3986:FreeRTOS/tasks.c ****                 else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
3987:FreeRTOS/tasks.c ****                 {
3988:FreeRTOS/tasks.c ****                     /* Only the stack was statically allocated, so the TCB is the
3989:FreeRTOS/tasks.c ****                      * only memory that must be freed. */
3990:FreeRTOS/tasks.c ****                     vPortFree( pxTCB );
3991:FreeRTOS/tasks.c ****                 }
3992:FreeRTOS/tasks.c ****                 else
3993:FreeRTOS/tasks.c ****                 {
3994:FreeRTOS/tasks.c ****                     /* Neither the stack nor the TCB were allocated dynamically, so
3995:FreeRTOS/tasks.c ****                      * nothing needs to be freed. */
3996:FreeRTOS/tasks.c ****                     configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND
3997:FreeRTOS/tasks.c ****                     mtCOVERAGE_TEST_MARKER();
3998:FreeRTOS/tasks.c ****                 }
3999:FreeRTOS/tasks.c ****             }
4000:FreeRTOS/tasks.c ****         #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
4001:FreeRTOS/tasks.c ****     }
4002:FreeRTOS/tasks.c **** 
4003:FreeRTOS/tasks.c **** #endif /* INCLUDE_vTaskDelete */
4004:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
4005:FreeRTOS/tasks.c **** 
4006:FreeRTOS/tasks.c **** static void prvResetNextTaskUnblockTime( void )
4007:FreeRTOS/tasks.c **** {
 104              		.loc 1 4007 0
 105              		.cfi_startproc
 106              		@ args = 0, pretend = 0, frame = 0
 107              		@ frame_needed = 0, uses_anonymous_args = 0
 108              		@ link register save eliminated.
4008:FreeRTOS/tasks.c ****     if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 109              		.loc 1 4008 0
 110 0000 074B     		ldr	r3, .L15
 111 0002 1B68     		ldr	r3, [r3]
 112 0004 1B68     		ldr	r3, [r3]
 113 0006 33B1     		cbz	r3, .L14
4009:FreeRTOS/tasks.c ****     {
4010:FreeRTOS/tasks.c ****         /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
4011:FreeRTOS/tasks.c ****          * the maximum possible value so it is  extremely unlikely that the
4012:FreeRTOS/tasks.c ****          * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
4013:FreeRTOS/tasks.c ****          * there is an item in the delayed list. */
4014:FreeRTOS/tasks.c ****         xNextTaskUnblockTime = portMAX_DELAY;
4015:FreeRTOS/tasks.c ****     }
4016:FreeRTOS/tasks.c ****     else
4017:FreeRTOS/tasks.c ****     {
4018:FreeRTOS/tasks.c ****         /* The new current delayed list is not empty, get the value of
4019:FreeRTOS/tasks.c ****          * the item at the head of the delayed list.  This is the time at
4020:FreeRTOS/tasks.c ****          * which the task at the head of the delayed list should be removed
ARM GAS  /tmp/ccrgBt0i.s 			page 77


4021:FreeRTOS/tasks.c ****          * from the Blocked state. */
4022:FreeRTOS/tasks.c ****         xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
 114              		.loc 1 4022 0
 115 0008 054B     		ldr	r3, .L15
 116 000a 1B68     		ldr	r3, [r3]
 117 000c DB68     		ldr	r3, [r3, #12]
 118 000e 1A68     		ldr	r2, [r3]
 119 0010 044B     		ldr	r3, .L15+4
 120 0012 1A60     		str	r2, [r3]
4023:FreeRTOS/tasks.c ****     }
4024:FreeRTOS/tasks.c **** }
 121              		.loc 1 4024 0
 122 0014 7047     		bx	lr
 123              	.L14:
4014:FreeRTOS/tasks.c ****     }
 124              		.loc 1 4014 0
 125 0016 034B     		ldr	r3, .L15+4
 126 0018 4FF0FF32 		mov	r2, #-1
 127 001c 1A60     		str	r2, [r3]
 128 001e 7047     		bx	lr
 129              	.L16:
 130              		.align	2
 131              	.L15:
 132 0020 00000000 		.word	.LANCHOR2
 133 0024 00000000 		.word	.LANCHOR3
 134              		.cfi_endproc
 135              	.LFE42:
 137              		.section	.text.prvDeleteTCB,"ax",%progbits
 138              		.align	1
 139              		.syntax unified
 140              		.thumb
 141              		.thumb_func
 142              		.fpu softvfp
 144              	prvDeleteTCB:
 145              	.LFB41:
3951:FreeRTOS/tasks.c ****         /* This call is required specifically for the TriCore port.  It must be
 146              		.loc 1 3951 0
 147              		.cfi_startproc
 148              		@ args = 0, pretend = 0, frame = 0
 149              		@ frame_needed = 0, uses_anonymous_args = 0
 150              	.LVL9:
 151 0000 10B5     		push	{r4, lr}
 152              	.LCFI0:
 153              		.cfi_def_cfa_offset 8
 154              		.cfi_offset 4, -8
 155              		.cfi_offset 14, -4
 156 0002 0446     		mov	r4, r0
3971:FreeRTOS/tasks.c ****                 vPortFree( pxTCB );
 157              		.loc 1 3971 0
 158 0004 006B     		ldr	r0, [r0, #48]
 159              	.LVL10:
 160 0006 FFF7FEFF 		bl	vPortFree
 161              	.LVL11:
3972:FreeRTOS/tasks.c ****             }
 162              		.loc 1 3972 0
 163 000a 2046     		mov	r0, r4
 164 000c FFF7FEFF 		bl	vPortFree
ARM GAS  /tmp/ccrgBt0i.s 			page 78


 165              	.LVL12:
4001:FreeRTOS/tasks.c **** 
 166              		.loc 1 4001 0
 167 0010 10BD     		pop	{r4, pc}
 168              		.cfi_endproc
 169              	.LFE41:
 171              		.section	.text.prvInitialiseNewTask,"ax",%progbits
 172              		.align	1
 173              		.syntax unified
 174              		.thumb
 175              		.thumb_func
 176              		.fpu softvfp
 178              	prvInitialiseNewTask:
 179              	.LFB6:
 827:FreeRTOS/tasks.c ****     StackType_t * pxTopOfStack;
 180              		.loc 1 827 0
 181              		.cfi_startproc
 182              		@ args = 16, pretend = 0, frame = 0
 183              		@ frame_needed = 0, uses_anonymous_args = 0
 184              	.LVL13:
 185 0000 2DE9F047 		push	{r4, r5, r6, r7, r8, r9, r10, lr}
 186              	.LCFI1:
 187              		.cfi_def_cfa_offset 32
 188              		.cfi_offset 4, -32
 189              		.cfi_offset 5, -28
 190              		.cfi_offset 6, -24
 191              		.cfi_offset 7, -20
 192              		.cfi_offset 8, -16
 193              		.cfi_offset 9, -12
 194              		.cfi_offset 10, -8
 195              		.cfi_offset 14, -4
 196 0004 089D     		ldr	r5, [sp, #32]
 197 0006 DDF82480 		ldr	r8, [sp, #36]
 198 000a 0A9C     		ldr	r4, [sp, #40]
 860:FreeRTOS/tasks.c ****             pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( 
 199              		.loc 1 860 0
 200 000c 266B     		ldr	r6, [r4, #48]
 201 000e 02F18042 		add	r2, r2, #1073741824
 202              	.LVL14:
 203 0012 013A     		subs	r2, r2, #1
 204              	.LVL15:
 205 0014 06EB8206 		add	r6, r6, r2, lsl #2
 206              	.LVL16:
 861:FreeRTOS/tasks.c **** 
 207              		.loc 1 861 0
 208 0018 26F00706 		bic	r6, r6, #7
 209              	.LVL17:
 888:FreeRTOS/tasks.c ****     {
 210              		.loc 1 888 0
 211 001c D1B1     		cbz	r1, .L31
 212 001e 0F46     		mov	r7, r1
 890:FreeRTOS/tasks.c ****         {
 213              		.loc 1 890 0
 214 0020 0022     		movs	r2, #0
 215              	.LVL18:
 216              	.L20:
 890:FreeRTOS/tasks.c ****         {
ARM GAS  /tmp/ccrgBt0i.s 			page 79


 217              		.loc 1 890 0 is_stmt 0 discriminator 1
 218 0022 0F2A     		cmp	r2, #15
 219 0024 08D8     		bhi	.L22
 892:FreeRTOS/tasks.c **** 
 220              		.loc 1 892 0 is_stmt 1
 221 0026 17F802C0 		ldrb	ip, [r7, r2]	@ zero_extendqisi2
 222 002a A118     		adds	r1, r4, r2
 223 002c 81F834C0 		strb	ip, [r1, #52]
 897:FreeRTOS/tasks.c ****             {
 224              		.loc 1 897 0
 225 0030 B95C     		ldrb	r1, [r7, r2]	@ zero_extendqisi2
 226 0032 09B1     		cbz	r1, .L22
 890:FreeRTOS/tasks.c ****         {
 227              		.loc 1 890 0 discriminator 2
 228 0034 0132     		adds	r2, r2, #1
 229              	.LVL19:
 230 0036 F4E7     		b	.L20
 231              	.L22:
 909:FreeRTOS/tasks.c ****     }
 232              		.loc 1 909 0
 233 0038 0022     		movs	r2, #0
 234              	.LVL20:
 235 003a 84F84320 		strb	r2, [r4, #67]
 236              	.LVL21:
 237              	.L24:
 919:FreeRTOS/tasks.c **** 
 238              		.loc 1 919 0
 239 003e 062D     		cmp	r5, #6
 240 0040 0CD9     		bls	.L25
 241              	.LBB154:
 242              	.LBB155:
 243              		.loc 2 200 0
 244              		.syntax unified
 245              	@ 200 "FreeRTOS/ARM_CM3/portmacro.h" 1
 246 0042 4FF05003 			mov r3, #80												
 247 0046 83F31188 		msr basepri, r3											
 248 004a BFF36F8F 		isb														
 249 004e BFF34F8F 		dsb														
 250              	
 251              	@ 0 "" 2
 252              	.LVL22:
 253              		.thumb
 254              		.syntax unified
 255              	.L26:
 256 0052 FEE7     		b	.L26
 257              	.LVL23:
 258              	.L31:
 259              	.LBE155:
 260              	.LBE154:
 915:FreeRTOS/tasks.c ****     }
 261              		.loc 1 915 0
 262 0054 0022     		movs	r2, #0
 263 0056 84F83420 		strb	r2, [r4, #52]
 264 005a F0E7     		b	.L24
 265              	.LVL24:
 266              	.L25:
 267 005c 9946     		mov	r9, r3
ARM GAS  /tmp/ccrgBt0i.s 			page 80


 268 005e 0746     		mov	r7, r0
 269              	.LVL25:
 930:FreeRTOS/tasks.c ****     #if ( configUSE_MUTEXES == 1 )
 270              		.loc 1 930 0
 271 0060 E562     		str	r5, [r4, #44]
 933:FreeRTOS/tasks.c ****             pxNewTCB->uxMutexesHeld = 0;
 272              		.loc 1 933 0
 273 0062 6564     		str	r5, [r4, #68]
 934:FreeRTOS/tasks.c ****         }
 274              		.loc 1 934 0
 275 0064 4FF0000A 		mov	r10, #0
 276 0068 C4F848A0 		str	r10, [r4, #72]
 938:FreeRTOS/tasks.c ****     vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 277              		.loc 1 938 0
 278 006c 201D     		adds	r0, r4, #4
 279              	.LVL26:
 280 006e FFF7FEFF 		bl	vListInitialiseItem
 281              	.LVL27:
 939:FreeRTOS/tasks.c **** 
 282              		.loc 1 939 0
 283 0072 04F11800 		add	r0, r4, #24
 284 0076 FFF7FEFF 		bl	vListInitialiseItem
 285              	.LVL28:
 943:FreeRTOS/tasks.c **** 
 286              		.loc 1 943 0
 287 007a 2461     		str	r4, [r4, #16]
 946:FreeRTOS/tasks.c ****     listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 288              		.loc 1 946 0
 289 007c C5F10705 		rsb	r5, r5, #7
 290              	.LVL29:
 291 0080 A561     		str	r5, [r4, #24]
 947:FreeRTOS/tasks.c **** 
 292              		.loc 1 947 0
 293 0082 6462     		str	r4, [r4, #36]
 986:FreeRTOS/tasks.c ****             memset( ( void * ) &( pxNewTCB->ucNotifyState[ 0 ] ), 0x00, sizeof( pxNewTCB->ucNotifyS
 294              		.loc 1 986 0
 295 0084 C4F84CA0 		str	r10, [r4, #76]	@ unaligned
 987:FreeRTOS/tasks.c ****         }
 296              		.loc 1 987 0
 297 0088 84F850A0 		strb	r10, [r4, #80]
1052:FreeRTOS/tasks.c ****                 }
 298              		.loc 1 1052 0
 299 008c 4A46     		mov	r2, r9
 300 008e 3946     		mov	r1, r7
 301 0090 3046     		mov	r0, r6
 302 0092 FFF7FEFF 		bl	pxPortInitialiseStack
 303              	.LVL30:
 304 0096 2060     		str	r0, [r4]
1058:FreeRTOS/tasks.c ****     {
 305              		.loc 1 1058 0
 306 0098 B8F1000F 		cmp	r8, #0
 307 009c 01D0     		beq	.L19
1062:FreeRTOS/tasks.c ****     }
 308              		.loc 1 1062 0
 309 009e C8F80040 		str	r4, [r8]
 310              	.L19:
1068:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
ARM GAS  /tmp/ccrgBt0i.s 			page 81


 311              		.loc 1 1068 0
 312 00a2 BDE8F087 		pop	{r4, r5, r6, r7, r8, r9, r10, pc}
 313              		.cfi_endproc
 314              	.LFE6:
 316              		.section	.text.prvInitialiseTaskLists,"ax",%progbits
 317              		.align	1
 318              		.syntax unified
 319              		.thumb
 320              		.thumb_func
 321              		.fpu softvfp
 323              	prvInitialiseTaskLists:
 324              	.LFB39:
3667:FreeRTOS/tasks.c ****     UBaseType_t uxPriority;
 325              		.loc 1 3667 0
 326              		.cfi_startproc
 327              		@ args = 0, pretend = 0, frame = 0
 328              		@ frame_needed = 0, uses_anonymous_args = 0
 329 0000 38B5     		push	{r3, r4, r5, lr}
 330              	.LCFI2:
 331              		.cfi_def_cfa_offset 16
 332              		.cfi_offset 3, -16
 333              		.cfi_offset 4, -12
 334              		.cfi_offset 5, -8
 335              		.cfi_offset 14, -4
 336              	.LVL31:
3670:FreeRTOS/tasks.c ****     {
 337              		.loc 1 3670 0
 338 0002 0024     		movs	r4, #0
 339 0004 07E0     		b	.L33
 340              	.LVL32:
 341              	.L34:
3672:FreeRTOS/tasks.c ****     }
 342              		.loc 1 3672 0 discriminator 3
 343 0006 04EB8402 		add	r2, r4, r4, lsl #2
 344 000a 9300     		lsls	r3, r2, #2
 345 000c 0E48     		ldr	r0, .L36
 346 000e 1844     		add	r0, r0, r3
 347 0010 FFF7FEFF 		bl	vListInitialise
 348              	.LVL33:
3670:FreeRTOS/tasks.c ****     {
 349              		.loc 1 3670 0 discriminator 3
 350 0014 0134     		adds	r4, r4, #1
 351              	.LVL34:
 352              	.L33:
3670:FreeRTOS/tasks.c ****     {
 353              		.loc 1 3670 0 is_stmt 0 discriminator 1
 354 0016 062C     		cmp	r4, #6
 355 0018 F5D9     		bls	.L34
3675:FreeRTOS/tasks.c ****     vListInitialise( &xDelayedTaskList2 );
 356              		.loc 1 3675 0 is_stmt 1
 357 001a 0C4D     		ldr	r5, .L36+4
 358 001c 2846     		mov	r0, r5
 359 001e FFF7FEFF 		bl	vListInitialise
 360              	.LVL35:
3676:FreeRTOS/tasks.c ****     vListInitialise( &xPendingReadyList );
 361              		.loc 1 3676 0
 362 0022 0B4C     		ldr	r4, .L36+8
ARM GAS  /tmp/ccrgBt0i.s 			page 82


 363              	.LVL36:
 364 0024 2046     		mov	r0, r4
 365 0026 FFF7FEFF 		bl	vListInitialise
 366              	.LVL37:
3677:FreeRTOS/tasks.c **** 
 367              		.loc 1 3677 0
 368 002a 0A48     		ldr	r0, .L36+12
 369 002c FFF7FEFF 		bl	vListInitialise
 370              	.LVL38:
3681:FreeRTOS/tasks.c ****         }
 371              		.loc 1 3681 0
 372 0030 0948     		ldr	r0, .L36+16
 373 0032 FFF7FEFF 		bl	vListInitialise
 374              	.LVL39:
3687:FreeRTOS/tasks.c ****         }
 375              		.loc 1 3687 0
 376 0036 0948     		ldr	r0, .L36+20
 377 0038 FFF7FEFF 		bl	vListInitialise
 378              	.LVL40:
3693:FreeRTOS/tasks.c ****     pxOverflowDelayedTaskList = &xDelayedTaskList2;
 379              		.loc 1 3693 0
 380 003c 084B     		ldr	r3, .L36+24
 381 003e 1D60     		str	r5, [r3]
3694:FreeRTOS/tasks.c **** }
 382              		.loc 1 3694 0
 383 0040 084B     		ldr	r3, .L36+28
 384 0042 1C60     		str	r4, [r3]
3695:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 385              		.loc 1 3695 0
 386 0044 38BD     		pop	{r3, r4, r5, pc}
 387              	.L37:
 388 0046 00BF     		.align	2
 389              	.L36:
 390 0048 00000000 		.word	.LANCHOR4
 391 004c 00000000 		.word	.LANCHOR5
 392 0050 00000000 		.word	.LANCHOR6
 393 0054 00000000 		.word	.LANCHOR1
 394 0058 00000000 		.word	.LANCHOR7
 395 005c 00000000 		.word	.LANCHOR0
 396 0060 00000000 		.word	.LANCHOR2
 397 0064 00000000 		.word	.LANCHOR8
 398              		.cfi_endproc
 399              	.LFE39:
 401              		.section	.text.prvAddNewTaskToReadyList,"ax",%progbits
 402              		.align	1
 403              		.syntax unified
 404              		.thumb
 405              		.thumb_func
 406              		.fpu softvfp
 408              	prvAddNewTaskToReadyList:
 409              	.LFB7:
1072:FreeRTOS/tasks.c ****     /* Ensure interrupts don't access the task lists while the lists are being
 410              		.loc 1 1072 0
 411              		.cfi_startproc
 412              		@ args = 0, pretend = 0, frame = 0
 413              		@ frame_needed = 0, uses_anonymous_args = 0
 414              	.LVL41:
ARM GAS  /tmp/ccrgBt0i.s 			page 83


 415 0000 38B5     		push	{r3, r4, r5, lr}
 416              	.LCFI3:
 417              		.cfi_def_cfa_offset 16
 418              		.cfi_offset 3, -16
 419              		.cfi_offset 4, -12
 420              		.cfi_offset 5, -8
 421              		.cfi_offset 14, -4
 422 0002 0446     		mov	r4, r0
1075:FreeRTOS/tasks.c ****     {
 423              		.loc 1 1075 0
 424 0004 FFF7FEFF 		bl	vPortEnterCritical
 425              	.LVL42:
1077:FreeRTOS/tasks.c **** 
 426              		.loc 1 1077 0
 427 0008 284A     		ldr	r2, .L45
 428 000a 1368     		ldr	r3, [r2]
 429 000c 0133     		adds	r3, r3, #1
 430 000e 1360     		str	r3, [r2]
1079:FreeRTOS/tasks.c ****         {
 431              		.loc 1 1079 0
 432 0010 274B     		ldr	r3, .L45+4
 433 0012 1B68     		ldr	r3, [r3]
 434 0014 5BB1     		cbz	r3, .L43
1102:FreeRTOS/tasks.c ****             {
 435              		.loc 1 1102 0
 436 0016 274B     		ldr	r3, .L45+8
 437 0018 1B68     		ldr	r3, [r3]
 438 001a 6BB9     		cbnz	r3, .L40
1104:FreeRTOS/tasks.c ****                 {
 439              		.loc 1 1104 0
 440 001c 244B     		ldr	r3, .L45+4
 441 001e 1B68     		ldr	r3, [r3]
 442 0020 DA6A     		ldr	r2, [r3, #44]
 443 0022 E36A     		ldr	r3, [r4, #44]
 444 0024 9A42     		cmp	r2, r3
 445 0026 07D8     		bhi	.L40
1106:FreeRTOS/tasks.c ****                 }
 446              		.loc 1 1106 0
 447 0028 214B     		ldr	r3, .L45+4
 448 002a 1C60     		str	r4, [r3]
 449 002c 04E0     		b	.L40
 450              	.L43:
1083:FreeRTOS/tasks.c **** 
 451              		.loc 1 1083 0
 452 002e 204B     		ldr	r3, .L45+4
 453 0030 1C60     		str	r4, [r3]
1085:FreeRTOS/tasks.c ****             {
 454              		.loc 1 1085 0
 455 0032 1368     		ldr	r3, [r2]
 456 0034 012B     		cmp	r3, #1
 457 0036 36D0     		beq	.L44
 458              	.L40:
1119:FreeRTOS/tasks.c **** 
 459              		.loc 1 1119 0
 460 0038 1F4A     		ldr	r2, .L45+12
 461 003a 1368     		ldr	r3, [r2]
 462 003c 0133     		adds	r3, r3, #1
ARM GAS  /tmp/ccrgBt0i.s 			page 84


 463 003e 1360     		str	r3, [r2]
1129:FreeRTOS/tasks.c **** 
 464              		.loc 1 1129 0
 465 0040 E36A     		ldr	r3, [r4, #44]
 466 0042 0122     		movs	r2, #1
 467 0044 9A40     		lsls	r2, r2, r3
 468 0046 1D49     		ldr	r1, .L45+16
 469 0048 0868     		ldr	r0, [r1]
 470 004a 0243     		orrs	r2, r2, r0
 471 004c 0A60     		str	r2, [r1]
 472              	.LBB156:
 473 004e 1C4A     		ldr	r2, .L45+20
 474 0050 03EB8303 		add	r3, r3, r3, lsl #2
 475 0054 9900     		lsls	r1, r3, #2
 476 0056 1144     		add	r1, r1, r2
 477 0058 4B68     		ldr	r3, [r1, #4]
 478              	.LVL43:
 479 005a A360     		str	r3, [r4, #8]
 480 005c 9968     		ldr	r1, [r3, #8]
 481 005e E160     		str	r1, [r4, #12]
 482 0060 9868     		ldr	r0, [r3, #8]
 483 0062 211D     		adds	r1, r4, #4
 484 0064 4160     		str	r1, [r0, #4]
 485 0066 9960     		str	r1, [r3, #8]
 486 0068 E06A     		ldr	r0, [r4, #44]
 487 006a 8300     		lsls	r3, r0, #2
 488              	.LVL44:
 489 006c 1D18     		adds	r5, r3, r0
 490 006e A900     		lsls	r1, r5, #2
 491 0070 5518     		adds	r5, r2, r1
 492 0072 6561     		str	r5, [r4, #20]
 493 0074 5158     		ldr	r1, [r2, r1]
 494 0076 0131     		adds	r1, r1, #1
 495 0078 0344     		add	r3, r3, r0
 496 007a 9800     		lsls	r0, r3, #2
 497 007c 1150     		str	r1, [r2, r0]
 498              	.LBE156:
1133:FreeRTOS/tasks.c **** 
 499              		.loc 1 1133 0
 500 007e FFF7FEFF 		bl	vPortExitCritical
 501              	.LVL45:
1135:FreeRTOS/tasks.c ****     {
 502              		.loc 1 1135 0
 503 0082 0C4B     		ldr	r3, .L45+8
 504 0084 1B68     		ldr	r3, [r3]
 505 0086 6BB1     		cbz	r3, .L38
1139:FreeRTOS/tasks.c ****         {
 506              		.loc 1 1139 0
 507 0088 094B     		ldr	r3, .L45+4
 508 008a 1B68     		ldr	r3, [r3]
 509 008c DA6A     		ldr	r2, [r3, #44]
 510 008e E36A     		ldr	r3, [r4, #44]
 511 0090 9A42     		cmp	r2, r3
 512 0092 07D2     		bcs	.L38
1141:FreeRTOS/tasks.c ****         }
 513              		.loc 1 1141 0
 514 0094 0B4B     		ldr	r3, .L45+24
ARM GAS  /tmp/ccrgBt0i.s 			page 85


 515 0096 4FF08052 		mov	r2, #268435456
 516 009a 1A60     		str	r2, [r3]
 517              		.syntax unified
 518              	@ 1141 "FreeRTOS/tasks.c" 1
 519 009c BFF34F8F 		dsb
 520              	@ 0 "" 2
 521              	@ 1141 "FreeRTOS/tasks.c" 1
 522 00a0 BFF36F8F 		isb
 523              	@ 0 "" 2
 524              		.thumb
 525              		.syntax unified
 526              	.L38:
1152:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 527              		.loc 1 1152 0
 528 00a4 38BD     		pop	{r3, r4, r5, pc}
 529              	.LVL46:
 530              	.L44:
1090:FreeRTOS/tasks.c ****             }
 531              		.loc 1 1090 0
 532 00a6 FFF7FEFF 		bl	prvInitialiseTaskLists
 533              	.LVL47:
 534 00aa C5E7     		b	.L40
 535              	.L46:
 536              		.align	2
 537              	.L45:
 538 00ac 00000000 		.word	.LANCHOR9
 539 00b0 00000000 		.word	.LANCHOR10
 540 00b4 00000000 		.word	.LANCHOR11
 541 00b8 00000000 		.word	.LANCHOR12
 542 00bc 00000000 		.word	.LANCHOR13
 543 00c0 00000000 		.word	.LANCHOR4
 544 00c4 04ED00E0 		.word	-536810236
 545              		.cfi_endproc
 546              	.LFE7:
 548              		.section	.text.prvCheckTasksWaitingTermination,"ax",%progbits
 549              		.align	1
 550              		.syntax unified
 551              		.thumb
 552              		.thumb_func
 553              		.fpu softvfp
 555              	prvCheckTasksWaitingTermination:
 556              	.LFB40:
3699:FreeRTOS/tasks.c ****     /** THIS FUNCTION IS CALLED FROM THE RTOS IDLE TASK **/
 557              		.loc 1 3699 0
 558              		.cfi_startproc
 559              		@ args = 0, pretend = 0, frame = 0
 560              		@ frame_needed = 0, uses_anonymous_args = 0
 561              	.LBB157:
3708:FreeRTOS/tasks.c ****             {
 562              		.loc 1 3708 0
 563 0000 0F4B     		ldr	r3, .L54
 564 0002 1B68     		ldr	r3, [r3]
 565 0004 D3B1     		cbz	r3, .L53
 566              	.LBE157:
3699:FreeRTOS/tasks.c ****     /** THIS FUNCTION IS CALLED FROM THE RTOS IDLE TASK **/
 567              		.loc 1 3699 0
 568 0006 10B5     		push	{r4, lr}
ARM GAS  /tmp/ccrgBt0i.s 			page 86


 569              	.LCFI4:
 570              		.cfi_def_cfa_offset 8
 571              		.cfi_offset 4, -8
 572              		.cfi_offset 14, -4
 573              	.L49:
 574              	.LBB158:
3710:FreeRTOS/tasks.c ****                 {
 575              		.loc 1 3710 0
 576 0008 FFF7FEFF 		bl	vPortEnterCritical
 577              	.LVL48:
3712:FreeRTOS/tasks.c ****                     ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 578              		.loc 1 3712 0
 579 000c 0D4B     		ldr	r3, .L54+4
 580 000e DB68     		ldr	r3, [r3, #12]
 581 0010 DC68     		ldr	r4, [r3, #12]
 582              	.LVL49:
3713:FreeRTOS/tasks.c ****                     --uxCurrentNumberOfTasks;
 583              		.loc 1 3713 0
 584 0012 201D     		adds	r0, r4, #4
 585 0014 FFF7FEFF 		bl	uxListRemove
 586              	.LVL50:
3714:FreeRTOS/tasks.c ****                     --uxDeletedTasksWaitingCleanUp;
 587              		.loc 1 3714 0
 588 0018 0B4A     		ldr	r2, .L54+8
 589 001a 1368     		ldr	r3, [r2]
 590 001c 013B     		subs	r3, r3, #1
 591 001e 1360     		str	r3, [r2]
3715:FreeRTOS/tasks.c ****                 }
 592              		.loc 1 3715 0
 593 0020 074A     		ldr	r2, .L54
 594 0022 1368     		ldr	r3, [r2]
 595 0024 013B     		subs	r3, r3, #1
 596 0026 1360     		str	r3, [r2]
3717:FreeRTOS/tasks.c **** 
 597              		.loc 1 3717 0
 598 0028 FFF7FEFF 		bl	vPortExitCritical
 599              	.LVL51:
3719:FreeRTOS/tasks.c ****             }
 600              		.loc 1 3719 0
 601 002c 2046     		mov	r0, r4
 602 002e FFF7FEFF 		bl	prvDeleteTCB
 603              	.LVL52:
3708:FreeRTOS/tasks.c ****             {
 604              		.loc 1 3708 0
 605 0032 034B     		ldr	r3, .L54
 606 0034 1B68     		ldr	r3, [r3]
 607 0036 002B     		cmp	r3, #0
 608 0038 E6D1     		bne	.L49
 609              	.LBE158:
3723:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 610              		.loc 1 3723 0
 611 003a 10BD     		pop	{r4, pc}
 612              	.LVL53:
 613              	.L53:
 614              	.LCFI5:
 615              		.cfi_def_cfa_offset 0
 616              		.cfi_restore 4
ARM GAS  /tmp/ccrgBt0i.s 			page 87


 617              		.cfi_restore 14
 618 003c 7047     		bx	lr
 619              	.L55:
 620 003e 00BF     		.align	2
 621              	.L54:
 622 0040 00000000 		.word	.LANCHOR14
 623 0044 00000000 		.word	.LANCHOR7
 624 0048 00000000 		.word	.LANCHOR9
 625              		.cfi_endproc
 626              	.LFE40:
 628              		.section	.text.prvIdleTask,"ax",%progbits
 629              		.align	1
 630              		.syntax unified
 631              		.thumb
 632              		.thumb_func
 633              		.fpu softvfp
 635              	prvIdleTask:
 636              	.LFB38:
3442:FreeRTOS/tasks.c ****     /* Stop warnings. */
 637              		.loc 1 3442 0
 638              		.cfi_startproc
 639              		@ Volatile: function does not return.
 640              		@ args = 0, pretend = 0, frame = 0
 641              		@ frame_needed = 0, uses_anonymous_args = 0
 642              	.LVL54:
 643 0000 08B5     		push	{r3, lr}
 644              	.LCFI6:
 645              		.cfi_def_cfa_offset 8
 646              		.cfi_offset 3, -8
 647              		.cfi_offset 14, -4
 648              	.LVL55:
 649              	.L57:
3458:FreeRTOS/tasks.c **** 
 650              		.loc 1 3458 0
 651 0002 FFF7FEFF 		bl	prvCheckTasksWaitingTermination
 652              	.LVL56:
3481:FreeRTOS/tasks.c ****                 {
 653              		.loc 1 3481 0
 654 0006 064B     		ldr	r3, .L60
 655 0008 1B68     		ldr	r3, [r3]
 656 000a 012B     		cmp	r3, #1
 657 000c F9D9     		bls	.L57
3483:FreeRTOS/tasks.c ****                 }
 658              		.loc 1 3483 0
 659 000e 054B     		ldr	r3, .L60+4
 660 0010 4FF08052 		mov	r2, #268435456
 661 0014 1A60     		str	r2, [r3]
 662              		.syntax unified
 663              	@ 3483 "FreeRTOS/tasks.c" 1
 664 0016 BFF34F8F 		dsb
 665              	@ 0 "" 2
 666              	@ 3483 "FreeRTOS/tasks.c" 1
 667 001a BFF36F8F 		isb
 668              	@ 0 "" 2
 669              		.thumb
 670              		.syntax unified
 671 001e F0E7     		b	.L57
ARM GAS  /tmp/ccrgBt0i.s 			page 88


 672              	.L61:
 673              		.align	2
 674              	.L60:
 675 0020 00000000 		.word	.LANCHOR4
 676 0024 04ED00E0 		.word	-536810236
 677              		.cfi_endproc
 678              	.LFE38:
 680              		.section	.text.prvAddCurrentTaskToDelayedList,"ax",%progbits
 681              		.align	1
 682              		.syntax unified
 683              		.thumb
 684              		.thumb_func
 685              		.fpu softvfp
 687              	prvAddCurrentTaskToDelayedList:
 688              	.LFB57:
4025:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
4026:FreeRTOS/tasks.c **** 
4027:FreeRTOS/tasks.c **** #if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
4028:FreeRTOS/tasks.c **** 
4029:FreeRTOS/tasks.c ****     TaskHandle_t xTaskGetCurrentTaskHandle( void )
4030:FreeRTOS/tasks.c ****     {
4031:FreeRTOS/tasks.c ****         TaskHandle_t xReturn;
4032:FreeRTOS/tasks.c **** 
4033:FreeRTOS/tasks.c ****         /* A critical section is not required as this is not called from
4034:FreeRTOS/tasks.c ****          * an interrupt and the current TCB will always be the same for any
4035:FreeRTOS/tasks.c ****          * individual execution thread. */
4036:FreeRTOS/tasks.c ****         xReturn = pxCurrentTCB;
4037:FreeRTOS/tasks.c **** 
4038:FreeRTOS/tasks.c ****         return xReturn;
4039:FreeRTOS/tasks.c ****     }
4040:FreeRTOS/tasks.c **** 
4041:FreeRTOS/tasks.c **** #endif /* ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) ) */
4042:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
4043:FreeRTOS/tasks.c **** 
4044:FreeRTOS/tasks.c **** #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
4045:FreeRTOS/tasks.c **** 
4046:FreeRTOS/tasks.c ****     BaseType_t xTaskGetSchedulerState( void )
4047:FreeRTOS/tasks.c ****     {
4048:FreeRTOS/tasks.c ****         BaseType_t xReturn;
4049:FreeRTOS/tasks.c **** 
4050:FreeRTOS/tasks.c ****         if( xSchedulerRunning == pdFALSE )
4051:FreeRTOS/tasks.c ****         {
4052:FreeRTOS/tasks.c ****             xReturn = taskSCHEDULER_NOT_STARTED;
4053:FreeRTOS/tasks.c ****         }
4054:FreeRTOS/tasks.c ****         else
4055:FreeRTOS/tasks.c ****         {
4056:FreeRTOS/tasks.c ****             if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
4057:FreeRTOS/tasks.c ****             {
4058:FreeRTOS/tasks.c ****                 xReturn = taskSCHEDULER_RUNNING;
4059:FreeRTOS/tasks.c ****             }
4060:FreeRTOS/tasks.c ****             else
4061:FreeRTOS/tasks.c ****             {
4062:FreeRTOS/tasks.c ****                 xReturn = taskSCHEDULER_SUSPENDED;
4063:FreeRTOS/tasks.c ****             }
4064:FreeRTOS/tasks.c ****         }
4065:FreeRTOS/tasks.c **** 
4066:FreeRTOS/tasks.c ****         return xReturn;
ARM GAS  /tmp/ccrgBt0i.s 			page 89


4067:FreeRTOS/tasks.c ****     }
4068:FreeRTOS/tasks.c **** 
4069:FreeRTOS/tasks.c **** #endif /* ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) ) */
4070:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
4071:FreeRTOS/tasks.c **** 
4072:FreeRTOS/tasks.c **** #if ( configUSE_MUTEXES == 1 )
4073:FreeRTOS/tasks.c **** 
4074:FreeRTOS/tasks.c ****     BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
4075:FreeRTOS/tasks.c ****     {
4076:FreeRTOS/tasks.c ****         TCB_t * const pxMutexHolderTCB = pxMutexHolder;
4077:FreeRTOS/tasks.c ****         BaseType_t xReturn = pdFALSE;
4078:FreeRTOS/tasks.c **** 
4079:FreeRTOS/tasks.c ****         /* If the mutex was given back by an interrupt while the queue was
4080:FreeRTOS/tasks.c ****          * locked then the mutex holder might now be NULL.  _RB_ Is this still
4081:FreeRTOS/tasks.c ****          * needed as interrupts can no longer use mutexes? */
4082:FreeRTOS/tasks.c ****         if( pxMutexHolder != NULL )
4083:FreeRTOS/tasks.c ****         {
4084:FreeRTOS/tasks.c ****             /* If the holder of the mutex has a priority below the priority of
4085:FreeRTOS/tasks.c ****              * the task attempting to obtain the mutex then it will temporarily
4086:FreeRTOS/tasks.c ****              * inherit the priority of the task attempting to obtain the mutex. */
4087:FreeRTOS/tasks.c ****             if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
4088:FreeRTOS/tasks.c ****             {
4089:FreeRTOS/tasks.c ****                 /* Adjust the mutex holder state to account for its new
4090:FreeRTOS/tasks.c ****                  * priority.  Only reset the event list item value if the value is
4091:FreeRTOS/tasks.c ****                  * not being used for anything else. */
4092:FreeRTOS/tasks.c ****                 if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_
4093:FreeRTOS/tasks.c ****                 {
4094:FreeRTOS/tasks.c ****                     listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) 
4095:FreeRTOS/tasks.c ****                 }
4096:FreeRTOS/tasks.c ****                 else
4097:FreeRTOS/tasks.c ****                 {
4098:FreeRTOS/tasks.c ****                     mtCOVERAGE_TEST_MARKER();
4099:FreeRTOS/tasks.c ****                 }
4100:FreeRTOS/tasks.c **** 
4101:FreeRTOS/tasks.c ****                 /* If the task being modified is in the ready state it will need
4102:FreeRTOS/tasks.c ****                  * to be moved into a new list. */
4103:FreeRTOS/tasks.c ****                 if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] )
4104:FreeRTOS/tasks.c ****                 {
4105:FreeRTOS/tasks.c ****                     if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 
4106:FreeRTOS/tasks.c ****                     {
4107:FreeRTOS/tasks.c ****                         /* It is known that the task is in its ready list so
4108:FreeRTOS/tasks.c ****                          * there is no need to check again and the port level
4109:FreeRTOS/tasks.c ****                          * reset macro can be called directly. */
4110:FreeRTOS/tasks.c ****                         portRESET_READY_PRIORITY( pxMutexHolderTCB->uxPriority, uxTopReadyPriority 
4111:FreeRTOS/tasks.c ****                     }
4112:FreeRTOS/tasks.c ****                     else
4113:FreeRTOS/tasks.c ****                     {
4114:FreeRTOS/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
4115:FreeRTOS/tasks.c ****                     }
4116:FreeRTOS/tasks.c **** 
4117:FreeRTOS/tasks.c ****                     /* Inherit the priority before being moved into the new list. */
4118:FreeRTOS/tasks.c ****                     pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
4119:FreeRTOS/tasks.c ****                     prvAddTaskToReadyList( pxMutexHolderTCB );
4120:FreeRTOS/tasks.c ****                 }
4121:FreeRTOS/tasks.c ****                 else
4122:FreeRTOS/tasks.c ****                 {
4123:FreeRTOS/tasks.c ****                     /* Just inherit the priority. */
ARM GAS  /tmp/ccrgBt0i.s 			page 90


4124:FreeRTOS/tasks.c ****                     pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
4125:FreeRTOS/tasks.c ****                 }
4126:FreeRTOS/tasks.c **** 
4127:FreeRTOS/tasks.c ****                 traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );
4128:FreeRTOS/tasks.c **** 
4129:FreeRTOS/tasks.c ****                 /* Inheritance occurred. */
4130:FreeRTOS/tasks.c ****                 xReturn = pdTRUE;
4131:FreeRTOS/tasks.c ****             }
4132:FreeRTOS/tasks.c ****             else
4133:FreeRTOS/tasks.c ****             {
4134:FreeRTOS/tasks.c ****                 if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
4135:FreeRTOS/tasks.c ****                 {
4136:FreeRTOS/tasks.c ****                     /* The base priority of the mutex holder is lower than the
4137:FreeRTOS/tasks.c ****                      * priority of the task attempting to take the mutex, but the
4138:FreeRTOS/tasks.c ****                      * current priority of the mutex holder is not lower than the
4139:FreeRTOS/tasks.c ****                      * priority of the task attempting to take the mutex.
4140:FreeRTOS/tasks.c ****                      * Therefore the mutex holder must have already inherited a
4141:FreeRTOS/tasks.c ****                      * priority, but inheritance would have occurred if that had
4142:FreeRTOS/tasks.c ****                      * not been the case. */
4143:FreeRTOS/tasks.c ****                     xReturn = pdTRUE;
4144:FreeRTOS/tasks.c ****                 }
4145:FreeRTOS/tasks.c ****                 else
4146:FreeRTOS/tasks.c ****                 {
4147:FreeRTOS/tasks.c ****                     mtCOVERAGE_TEST_MARKER();
4148:FreeRTOS/tasks.c ****                 }
4149:FreeRTOS/tasks.c ****             }
4150:FreeRTOS/tasks.c ****         }
4151:FreeRTOS/tasks.c ****         else
4152:FreeRTOS/tasks.c ****         {
4153:FreeRTOS/tasks.c ****             mtCOVERAGE_TEST_MARKER();
4154:FreeRTOS/tasks.c ****         }
4155:FreeRTOS/tasks.c **** 
4156:FreeRTOS/tasks.c ****         return xReturn;
4157:FreeRTOS/tasks.c ****     }
4158:FreeRTOS/tasks.c **** 
4159:FreeRTOS/tasks.c **** #endif /* configUSE_MUTEXES */
4160:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
4161:FreeRTOS/tasks.c **** 
4162:FreeRTOS/tasks.c **** #if ( configUSE_MUTEXES == 1 )
4163:FreeRTOS/tasks.c **** 
4164:FreeRTOS/tasks.c ****     BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
4165:FreeRTOS/tasks.c ****     {
4166:FreeRTOS/tasks.c ****         TCB_t * const pxTCB = pxMutexHolder;
4167:FreeRTOS/tasks.c ****         BaseType_t xReturn = pdFALSE;
4168:FreeRTOS/tasks.c **** 
4169:FreeRTOS/tasks.c ****         if( pxMutexHolder != NULL )
4170:FreeRTOS/tasks.c ****         {
4171:FreeRTOS/tasks.c ****             /* A task can only have an inherited priority if it holds the mutex.
4172:FreeRTOS/tasks.c ****              * If the mutex is held by a task then it cannot be given from an
4173:FreeRTOS/tasks.c ****              * interrupt, and if a mutex is given by the holding task then it must
4174:FreeRTOS/tasks.c ****              * be the running state task. */
4175:FreeRTOS/tasks.c ****             configASSERT( pxTCB == pxCurrentTCB );
4176:FreeRTOS/tasks.c ****             configASSERT( pxTCB->uxMutexesHeld );
4177:FreeRTOS/tasks.c ****             ( pxTCB->uxMutexesHeld )--;
4178:FreeRTOS/tasks.c **** 
4179:FreeRTOS/tasks.c ****             /* Has the holder of the mutex inherited the priority of another
4180:FreeRTOS/tasks.c ****              * task? */
ARM GAS  /tmp/ccrgBt0i.s 			page 91


4181:FreeRTOS/tasks.c ****             if( pxTCB->uxPriority != pxTCB->uxBasePriority )
4182:FreeRTOS/tasks.c ****             {
4183:FreeRTOS/tasks.c ****                 /* Only disinherit if no other mutexes are held. */
4184:FreeRTOS/tasks.c ****                 if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
4185:FreeRTOS/tasks.c ****                 {
4186:FreeRTOS/tasks.c ****                     /* A task can only have an inherited priority if it holds
4187:FreeRTOS/tasks.c ****                      * the mutex.  If the mutex is held by a task then it cannot be
4188:FreeRTOS/tasks.c ****                      * given from an interrupt, and if a mutex is given by the
4189:FreeRTOS/tasks.c ****                      * holding task then it must be the running state task.  Remove
4190:FreeRTOS/tasks.c ****                      * the holding task from the ready list. */
4191:FreeRTOS/tasks.c ****                     if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
4192:FreeRTOS/tasks.c ****                     {
4193:FreeRTOS/tasks.c ****                         portRESET_READY_PRIORITY( pxTCB->uxPriority, uxTopReadyPriority );
4194:FreeRTOS/tasks.c ****                     }
4195:FreeRTOS/tasks.c ****                     else
4196:FreeRTOS/tasks.c ****                     {
4197:FreeRTOS/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
4198:FreeRTOS/tasks.c ****                     }
4199:FreeRTOS/tasks.c **** 
4200:FreeRTOS/tasks.c ****                     /* Disinherit the priority before adding the task into the
4201:FreeRTOS/tasks.c ****                      * new  ready list. */
4202:FreeRTOS/tasks.c ****                     traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
4203:FreeRTOS/tasks.c ****                     pxTCB->uxPriority = pxTCB->uxBasePriority;
4204:FreeRTOS/tasks.c **** 
4205:FreeRTOS/tasks.c ****                     /* Reset the event list item value.  It cannot be in use for
4206:FreeRTOS/tasks.c ****                      * any other purpose if this task is running, and it must be
4207:FreeRTOS/tasks.c ****                      * running to give back the mutex. */
4208:FreeRTOS/tasks.c ****                     listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_P
4209:FreeRTOS/tasks.c ****                     prvAddTaskToReadyList( pxTCB );
4210:FreeRTOS/tasks.c **** 
4211:FreeRTOS/tasks.c ****                     /* Return true to indicate that a context switch is required.
4212:FreeRTOS/tasks.c ****                      * This is only actually required in the corner case whereby
4213:FreeRTOS/tasks.c ****                      * multiple mutexes were held and the mutexes were given back
4214:FreeRTOS/tasks.c ****                      * in an order different to that in which they were taken.
4215:FreeRTOS/tasks.c ****                      * If a context switch did not occur when the first mutex was
4216:FreeRTOS/tasks.c ****                      * returned, even if a task was waiting on it, then a context
4217:FreeRTOS/tasks.c ****                      * switch should occur when the last mutex is returned whether
4218:FreeRTOS/tasks.c ****                      * a task is waiting on it or not. */
4219:FreeRTOS/tasks.c ****                     xReturn = pdTRUE;
4220:FreeRTOS/tasks.c ****                 }
4221:FreeRTOS/tasks.c ****                 else
4222:FreeRTOS/tasks.c ****                 {
4223:FreeRTOS/tasks.c ****                     mtCOVERAGE_TEST_MARKER();
4224:FreeRTOS/tasks.c ****                 }
4225:FreeRTOS/tasks.c ****             }
4226:FreeRTOS/tasks.c ****             else
4227:FreeRTOS/tasks.c ****             {
4228:FreeRTOS/tasks.c ****                 mtCOVERAGE_TEST_MARKER();
4229:FreeRTOS/tasks.c ****             }
4230:FreeRTOS/tasks.c ****         }
4231:FreeRTOS/tasks.c ****         else
4232:FreeRTOS/tasks.c ****         {
4233:FreeRTOS/tasks.c ****             mtCOVERAGE_TEST_MARKER();
4234:FreeRTOS/tasks.c ****         }
4235:FreeRTOS/tasks.c **** 
4236:FreeRTOS/tasks.c ****         return xReturn;
4237:FreeRTOS/tasks.c ****     }
ARM GAS  /tmp/ccrgBt0i.s 			page 92


4238:FreeRTOS/tasks.c **** 
4239:FreeRTOS/tasks.c **** #endif /* configUSE_MUTEXES */
4240:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
4241:FreeRTOS/tasks.c **** 
4242:FreeRTOS/tasks.c **** #if ( configUSE_MUTEXES == 1 )
4243:FreeRTOS/tasks.c **** 
4244:FreeRTOS/tasks.c ****     void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder,
4245:FreeRTOS/tasks.c ****                                               UBaseType_t uxHighestPriorityWaitingTask )
4246:FreeRTOS/tasks.c ****     {
4247:FreeRTOS/tasks.c ****         TCB_t * const pxTCB = pxMutexHolder;
4248:FreeRTOS/tasks.c ****         UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
4249:FreeRTOS/tasks.c ****         const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;
4250:FreeRTOS/tasks.c **** 
4251:FreeRTOS/tasks.c ****         if( pxMutexHolder != NULL )
4252:FreeRTOS/tasks.c ****         {
4253:FreeRTOS/tasks.c ****             /* If pxMutexHolder is not NULL then the holder must hold at least
4254:FreeRTOS/tasks.c ****              * one mutex. */
4255:FreeRTOS/tasks.c ****             configASSERT( pxTCB->uxMutexesHeld );
4256:FreeRTOS/tasks.c **** 
4257:FreeRTOS/tasks.c ****             /* Determine the priority to which the priority of the task that
4258:FreeRTOS/tasks.c ****              * holds the mutex should be set.  This will be the greater of the
4259:FreeRTOS/tasks.c ****              * holding task's base priority and the priority of the highest
4260:FreeRTOS/tasks.c ****              * priority task that is waiting to obtain the mutex. */
4261:FreeRTOS/tasks.c ****             if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
4262:FreeRTOS/tasks.c ****             {
4263:FreeRTOS/tasks.c ****                 uxPriorityToUse = uxHighestPriorityWaitingTask;
4264:FreeRTOS/tasks.c ****             }
4265:FreeRTOS/tasks.c ****             else
4266:FreeRTOS/tasks.c ****             {
4267:FreeRTOS/tasks.c ****                 uxPriorityToUse = pxTCB->uxBasePriority;
4268:FreeRTOS/tasks.c ****             }
4269:FreeRTOS/tasks.c **** 
4270:FreeRTOS/tasks.c ****             /* Does the priority need to change? */
4271:FreeRTOS/tasks.c ****             if( pxTCB->uxPriority != uxPriorityToUse )
4272:FreeRTOS/tasks.c ****             {
4273:FreeRTOS/tasks.c ****                 /* Only disinherit if no other mutexes are held.  This is a
4274:FreeRTOS/tasks.c ****                  * simplification in the priority inheritance implementation.  If
4275:FreeRTOS/tasks.c ****                  * the task that holds the mutex is also holding other mutexes then
4276:FreeRTOS/tasks.c ****                  * the other mutexes may have caused the priority inheritance. */
4277:FreeRTOS/tasks.c ****                 if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
4278:FreeRTOS/tasks.c ****                 {
4279:FreeRTOS/tasks.c ****                     /* If a task has timed out because it already holds the
4280:FreeRTOS/tasks.c ****                      * mutex it was trying to obtain then it cannot of inherited
4281:FreeRTOS/tasks.c ****                      * its own priority. */
4282:FreeRTOS/tasks.c ****                     configASSERT( pxTCB != pxCurrentTCB );
4283:FreeRTOS/tasks.c **** 
4284:FreeRTOS/tasks.c ****                     /* Disinherit the priority, remembering the previous
4285:FreeRTOS/tasks.c ****                      * priority to facilitate determining the subject task's
4286:FreeRTOS/tasks.c ****                      * state. */
4287:FreeRTOS/tasks.c ****                     traceTASK_PRIORITY_DISINHERIT( pxTCB, uxPriorityToUse );
4288:FreeRTOS/tasks.c ****                     uxPriorityUsedOnEntry = pxTCB->uxPriority;
4289:FreeRTOS/tasks.c ****                     pxTCB->uxPriority = uxPriorityToUse;
4290:FreeRTOS/tasks.c **** 
4291:FreeRTOS/tasks.c ****                     /* Only reset the event list item value if the value is not
4292:FreeRTOS/tasks.c ****                      * being used for anything else. */
4293:FreeRTOS/tasks.c ****                     if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_IT
4294:FreeRTOS/tasks.c ****                     {
ARM GAS  /tmp/ccrgBt0i.s 			page 93


4295:FreeRTOS/tasks.c ****                         listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configM
4296:FreeRTOS/tasks.c ****                     }
4297:FreeRTOS/tasks.c ****                     else
4298:FreeRTOS/tasks.c ****                     {
4299:FreeRTOS/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
4300:FreeRTOS/tasks.c ****                     }
4301:FreeRTOS/tasks.c **** 
4302:FreeRTOS/tasks.c ****                     /* If the running task is not the task that holds the mutex
4303:FreeRTOS/tasks.c ****                      * then the task that holds the mutex could be in either the
4304:FreeRTOS/tasks.c ****                      * Ready, Blocked or Suspended states.  Only remove the task
4305:FreeRTOS/tasks.c ****                      * from its current state list if it is in the Ready state as
4306:FreeRTOS/tasks.c ****                      * the task's priority is going to change and there is one
4307:FreeRTOS/tasks.c ****                      * Ready list per priority. */
4308:FreeRTOS/tasks.c ****                     if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &
4309:FreeRTOS/tasks.c ****                     {
4310:FreeRTOS/tasks.c ****                         if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
4311:FreeRTOS/tasks.c ****                         {
4312:FreeRTOS/tasks.c ****                             /* It is known that the task is in its ready list so
4313:FreeRTOS/tasks.c ****                              * there is no need to check again and the port level
4314:FreeRTOS/tasks.c ****                              * reset macro can be called directly. */
4315:FreeRTOS/tasks.c ****                             portRESET_READY_PRIORITY( pxTCB->uxPriority, uxTopReadyPriority );
4316:FreeRTOS/tasks.c ****                         }
4317:FreeRTOS/tasks.c ****                         else
4318:FreeRTOS/tasks.c ****                         {
4319:FreeRTOS/tasks.c ****                             mtCOVERAGE_TEST_MARKER();
4320:FreeRTOS/tasks.c ****                         }
4321:FreeRTOS/tasks.c **** 
4322:FreeRTOS/tasks.c ****                         prvAddTaskToReadyList( pxTCB );
4323:FreeRTOS/tasks.c ****                     }
4324:FreeRTOS/tasks.c ****                     else
4325:FreeRTOS/tasks.c ****                     {
4326:FreeRTOS/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
4327:FreeRTOS/tasks.c ****                     }
4328:FreeRTOS/tasks.c ****                 }
4329:FreeRTOS/tasks.c ****                 else
4330:FreeRTOS/tasks.c ****                 {
4331:FreeRTOS/tasks.c ****                     mtCOVERAGE_TEST_MARKER();
4332:FreeRTOS/tasks.c ****                 }
4333:FreeRTOS/tasks.c ****             }
4334:FreeRTOS/tasks.c ****             else
4335:FreeRTOS/tasks.c ****             {
4336:FreeRTOS/tasks.c ****                 mtCOVERAGE_TEST_MARKER();
4337:FreeRTOS/tasks.c ****             }
4338:FreeRTOS/tasks.c ****         }
4339:FreeRTOS/tasks.c ****         else
4340:FreeRTOS/tasks.c ****         {
4341:FreeRTOS/tasks.c ****             mtCOVERAGE_TEST_MARKER();
4342:FreeRTOS/tasks.c ****         }
4343:FreeRTOS/tasks.c ****     }
4344:FreeRTOS/tasks.c **** 
4345:FreeRTOS/tasks.c **** #endif /* configUSE_MUTEXES */
4346:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
4347:FreeRTOS/tasks.c **** 
4348:FreeRTOS/tasks.c **** #if ( portCRITICAL_NESTING_IN_TCB == 1 )
4349:FreeRTOS/tasks.c **** 
4350:FreeRTOS/tasks.c ****     void vTaskEnterCritical( void )
4351:FreeRTOS/tasks.c ****     {
ARM GAS  /tmp/ccrgBt0i.s 			page 94


4352:FreeRTOS/tasks.c ****         portDISABLE_INTERRUPTS();
4353:FreeRTOS/tasks.c **** 
4354:FreeRTOS/tasks.c ****         if( xSchedulerRunning != pdFALSE )
4355:FreeRTOS/tasks.c ****         {
4356:FreeRTOS/tasks.c ****             ( pxCurrentTCB->uxCriticalNesting )++;
4357:FreeRTOS/tasks.c **** 
4358:FreeRTOS/tasks.c ****             /* This is not the interrupt safe version of the enter critical
4359:FreeRTOS/tasks.c ****              * function so  assert() if it is being called from an interrupt
4360:FreeRTOS/tasks.c ****              * context.  Only API functions that end in "FromISR" can be used in an
4361:FreeRTOS/tasks.c ****              * interrupt.  Only assert if the critical nesting count is 1 to
4362:FreeRTOS/tasks.c ****              * protect against recursive calls if the assert function also uses a
4363:FreeRTOS/tasks.c ****              * critical section. */
4364:FreeRTOS/tasks.c ****             if( pxCurrentTCB->uxCriticalNesting == 1 )
4365:FreeRTOS/tasks.c ****             {
4366:FreeRTOS/tasks.c ****                 portASSERT_IF_IN_ISR();
4367:FreeRTOS/tasks.c ****             }
4368:FreeRTOS/tasks.c ****         }
4369:FreeRTOS/tasks.c ****         else
4370:FreeRTOS/tasks.c ****         {
4371:FreeRTOS/tasks.c ****             mtCOVERAGE_TEST_MARKER();
4372:FreeRTOS/tasks.c ****         }
4373:FreeRTOS/tasks.c ****     }
4374:FreeRTOS/tasks.c **** 
4375:FreeRTOS/tasks.c **** #endif /* portCRITICAL_NESTING_IN_TCB */
4376:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
4377:FreeRTOS/tasks.c **** 
4378:FreeRTOS/tasks.c **** #if ( portCRITICAL_NESTING_IN_TCB == 1 )
4379:FreeRTOS/tasks.c **** 
4380:FreeRTOS/tasks.c ****     void vTaskExitCritical( void )
4381:FreeRTOS/tasks.c ****     {
4382:FreeRTOS/tasks.c ****         if( xSchedulerRunning != pdFALSE )
4383:FreeRTOS/tasks.c ****         {
4384:FreeRTOS/tasks.c ****             if( pxCurrentTCB->uxCriticalNesting > 0U )
4385:FreeRTOS/tasks.c ****             {
4386:FreeRTOS/tasks.c ****                 ( pxCurrentTCB->uxCriticalNesting )--;
4387:FreeRTOS/tasks.c **** 
4388:FreeRTOS/tasks.c ****                 if( pxCurrentTCB->uxCriticalNesting == 0U )
4389:FreeRTOS/tasks.c ****                 {
4390:FreeRTOS/tasks.c ****                     portENABLE_INTERRUPTS();
4391:FreeRTOS/tasks.c ****                 }
4392:FreeRTOS/tasks.c ****                 else
4393:FreeRTOS/tasks.c ****                 {
4394:FreeRTOS/tasks.c ****                     mtCOVERAGE_TEST_MARKER();
4395:FreeRTOS/tasks.c ****                 }
4396:FreeRTOS/tasks.c ****             }
4397:FreeRTOS/tasks.c ****             else
4398:FreeRTOS/tasks.c ****             {
4399:FreeRTOS/tasks.c ****                 mtCOVERAGE_TEST_MARKER();
4400:FreeRTOS/tasks.c ****             }
4401:FreeRTOS/tasks.c ****         }
4402:FreeRTOS/tasks.c ****         else
4403:FreeRTOS/tasks.c ****         {
4404:FreeRTOS/tasks.c ****             mtCOVERAGE_TEST_MARKER();
4405:FreeRTOS/tasks.c ****         }
4406:FreeRTOS/tasks.c ****     }
4407:FreeRTOS/tasks.c **** 
4408:FreeRTOS/tasks.c **** #endif /* portCRITICAL_NESTING_IN_TCB */
ARM GAS  /tmp/ccrgBt0i.s 			page 95


4409:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
4410:FreeRTOS/tasks.c **** 
4411:FreeRTOS/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
4412:FreeRTOS/tasks.c **** 
4413:FreeRTOS/tasks.c ****     static char * prvWriteNameToBuffer( char * pcBuffer,
4414:FreeRTOS/tasks.c ****                                         const char * pcTaskName )
4415:FreeRTOS/tasks.c ****     {
4416:FreeRTOS/tasks.c ****         size_t x;
4417:FreeRTOS/tasks.c **** 
4418:FreeRTOS/tasks.c ****         /* Start by copying the entire string. */
4419:FreeRTOS/tasks.c ****         strcpy( pcBuffer, pcTaskName );
4420:FreeRTOS/tasks.c **** 
4421:FreeRTOS/tasks.c ****         /* Pad the end of the string with spaces to ensure columns line up when
4422:FreeRTOS/tasks.c ****          * printed out. */
4423:FreeRTOS/tasks.c ****         for( x = strlen( pcBuffer ); x < ( size_t ) ( configMAX_TASK_NAME_LEN - 1 ); x++ )
4424:FreeRTOS/tasks.c ****         {
4425:FreeRTOS/tasks.c ****             pcBuffer[ x ] = ' ';
4426:FreeRTOS/tasks.c ****         }
4427:FreeRTOS/tasks.c **** 
4428:FreeRTOS/tasks.c ****         /* Terminate. */
4429:FreeRTOS/tasks.c ****         pcBuffer[ x ] = ( char ) 0x00;
4430:FreeRTOS/tasks.c **** 
4431:FreeRTOS/tasks.c ****         /* Return the new end of string. */
4432:FreeRTOS/tasks.c ****         return &( pcBuffer[ x ] );
4433:FreeRTOS/tasks.c ****     }
4434:FreeRTOS/tasks.c **** 
4435:FreeRTOS/tasks.c **** #endif /* ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) */
4436:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
4437:FreeRTOS/tasks.c **** 
4438:FreeRTOS/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( config
4439:FreeRTOS/tasks.c **** 
4440:FreeRTOS/tasks.c ****     void vTaskList( char * pcWriteBuffer )
4441:FreeRTOS/tasks.c ****     {
4442:FreeRTOS/tasks.c ****         TaskStatus_t * pxTaskStatusArray;
4443:FreeRTOS/tasks.c ****         UBaseType_t uxArraySize, x;
4444:FreeRTOS/tasks.c ****         char cStatus;
4445:FreeRTOS/tasks.c **** 
4446:FreeRTOS/tasks.c ****         /*
4447:FreeRTOS/tasks.c ****          * PLEASE NOTE:
4448:FreeRTOS/tasks.c ****          *
4449:FreeRTOS/tasks.c ****          * This function is provided for convenience only, and is used by many
4450:FreeRTOS/tasks.c ****          * of the demo applications.  Do not consider it to be part of the
4451:FreeRTOS/tasks.c ****          * scheduler.
4452:FreeRTOS/tasks.c ****          *
4453:FreeRTOS/tasks.c ****          * vTaskList() calls uxTaskGetSystemState(), then formats part of the
4454:FreeRTOS/tasks.c ****          * uxTaskGetSystemState() output into a human readable table that
4455:FreeRTOS/tasks.c ****          * displays task: names, states, priority, stack usage and task number.
4456:FreeRTOS/tasks.c ****          * Stack usage specified as the number of unused StackType_t words stack can hold
4457:FreeRTOS/tasks.c ****          * on top of stack - not the number of bytes.
4458:FreeRTOS/tasks.c ****          *
4459:FreeRTOS/tasks.c ****          * vTaskList() has a dependency on the sprintf() C library function that
4460:FreeRTOS/tasks.c ****          * might bloat the code size, use a lot of stack, and provide different
4461:FreeRTOS/tasks.c ****          * results on different platforms.  An alternative, tiny, third party,
4462:FreeRTOS/tasks.c ****          * and limited functionality implementation of sprintf() is provided in
4463:FreeRTOS/tasks.c ****          * many of the FreeRTOS/Demo sub-directories in a file called
4464:FreeRTOS/tasks.c ****          * printf-stdarg.c (note printf-stdarg.c does not provide a full
4465:FreeRTOS/tasks.c ****          * snprintf() implementation!).
ARM GAS  /tmp/ccrgBt0i.s 			page 96


4466:FreeRTOS/tasks.c ****          *
4467:FreeRTOS/tasks.c ****          * It is recommended that production systems call uxTaskGetSystemState()
4468:FreeRTOS/tasks.c ****          * directly to get access to raw stats data, rather than indirectly
4469:FreeRTOS/tasks.c ****          * through a call to vTaskList().
4470:FreeRTOS/tasks.c ****          */
4471:FreeRTOS/tasks.c **** 
4472:FreeRTOS/tasks.c **** 
4473:FreeRTOS/tasks.c ****         /* Make sure the write buffer does not contain a string. */
4474:FreeRTOS/tasks.c ****         *pcWriteBuffer = ( char ) 0x00;
4475:FreeRTOS/tasks.c **** 
4476:FreeRTOS/tasks.c ****         /* Take a snapshot of the number of tasks in case it changes while this
4477:FreeRTOS/tasks.c ****          * function is executing. */
4478:FreeRTOS/tasks.c ****         uxArraySize = uxCurrentNumberOfTasks;
4479:FreeRTOS/tasks.c **** 
4480:FreeRTOS/tasks.c ****         /* Allocate an array index for each task.  NOTE!  if
4481:FreeRTOS/tasks.c ****          * configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
4482:FreeRTOS/tasks.c ****          * equate to NULL. */
4483:FreeRTOS/tasks.c ****         pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) ); /*lint
4484:FreeRTOS/tasks.c **** 
4485:FreeRTOS/tasks.c ****         if( pxTaskStatusArray != NULL )
4486:FreeRTOS/tasks.c ****         {
4487:FreeRTOS/tasks.c ****             /* Generate the (binary) data. */
4488:FreeRTOS/tasks.c ****             uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, NULL );
4489:FreeRTOS/tasks.c **** 
4490:FreeRTOS/tasks.c ****             /* Create a human readable table from the binary data. */
4491:FreeRTOS/tasks.c ****             for( x = 0; x < uxArraySize; x++ )
4492:FreeRTOS/tasks.c ****             {
4493:FreeRTOS/tasks.c ****                 switch( pxTaskStatusArray[ x ].eCurrentState )
4494:FreeRTOS/tasks.c ****                 {
4495:FreeRTOS/tasks.c ****                     case eRunning:
4496:FreeRTOS/tasks.c ****                         cStatus = tskRUNNING_CHAR;
4497:FreeRTOS/tasks.c ****                         break;
4498:FreeRTOS/tasks.c **** 
4499:FreeRTOS/tasks.c ****                     case eReady:
4500:FreeRTOS/tasks.c ****                         cStatus = tskREADY_CHAR;
4501:FreeRTOS/tasks.c ****                         break;
4502:FreeRTOS/tasks.c **** 
4503:FreeRTOS/tasks.c ****                     case eBlocked:
4504:FreeRTOS/tasks.c ****                         cStatus = tskBLOCKED_CHAR;
4505:FreeRTOS/tasks.c ****                         break;
4506:FreeRTOS/tasks.c **** 
4507:FreeRTOS/tasks.c ****                     case eSuspended:
4508:FreeRTOS/tasks.c ****                         cStatus = tskSUSPENDED_CHAR;
4509:FreeRTOS/tasks.c ****                         break;
4510:FreeRTOS/tasks.c **** 
4511:FreeRTOS/tasks.c ****                     case eDeleted:
4512:FreeRTOS/tasks.c ****                         cStatus = tskDELETED_CHAR;
4513:FreeRTOS/tasks.c ****                         break;
4514:FreeRTOS/tasks.c **** 
4515:FreeRTOS/tasks.c ****                     case eInvalid: /* Fall through. */
4516:FreeRTOS/tasks.c ****                     default:       /* Should not get here, but it is included
4517:FreeRTOS/tasks.c ****                                     * to prevent static checking errors. */
4518:FreeRTOS/tasks.c ****                         cStatus = ( char ) 0x00;
4519:FreeRTOS/tasks.c ****                         break;
4520:FreeRTOS/tasks.c ****                 }
4521:FreeRTOS/tasks.c **** 
4522:FreeRTOS/tasks.c ****                 /* Write the task name to the string, padding with spaces so it
ARM GAS  /tmp/ccrgBt0i.s 			page 97


4523:FreeRTOS/tasks.c ****                  * can be printed in tabular form more easily. */
4524:FreeRTOS/tasks.c ****                 pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskN
4525:FreeRTOS/tasks.c **** 
4526:FreeRTOS/tasks.c ****                 /* Write the rest of the string. */
4527:FreeRTOS/tasks.c ****                 sprintf( pcWriteBuffer, "\t%c\t%u\t%u\t%u\r\n", cStatus, ( unsigned int ) pxTaskSta
4528:FreeRTOS/tasks.c ****                 pcWriteBuffer += strlen( pcWriteBuffer );                                          
4529:FreeRTOS/tasks.c ****             }
4530:FreeRTOS/tasks.c **** 
4531:FreeRTOS/tasks.c ****             /* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
4532:FreeRTOS/tasks.c ****              * is 0 then vPortFree() will be #defined to nothing. */
4533:FreeRTOS/tasks.c ****             vPortFree( pxTaskStatusArray );
4534:FreeRTOS/tasks.c ****         }
4535:FreeRTOS/tasks.c ****         else
4536:FreeRTOS/tasks.c ****         {
4537:FreeRTOS/tasks.c ****             mtCOVERAGE_TEST_MARKER();
4538:FreeRTOS/tasks.c ****         }
4539:FreeRTOS/tasks.c ****     }
4540:FreeRTOS/tasks.c **** 
4541:FreeRTOS/tasks.c **** #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( 
4542:FreeRTOS/tasks.c **** /*----------------------------------------------------------*/
4543:FreeRTOS/tasks.c **** 
4544:FreeRTOS/tasks.c **** #if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( c
4545:FreeRTOS/tasks.c **** 
4546:FreeRTOS/tasks.c ****     void vTaskGetRunTimeStats( char * pcWriteBuffer )
4547:FreeRTOS/tasks.c ****     {
4548:FreeRTOS/tasks.c ****         TaskStatus_t * pxTaskStatusArray;
4549:FreeRTOS/tasks.c ****         UBaseType_t uxArraySize, x;
4550:FreeRTOS/tasks.c ****         configRUN_TIME_COUNTER_TYPE ulTotalTime, ulStatsAsPercentage;
4551:FreeRTOS/tasks.c **** 
4552:FreeRTOS/tasks.c ****         #if ( configUSE_TRACE_FACILITY != 1 )
4553:FreeRTOS/tasks.c ****             {
4554:FreeRTOS/tasks.c ****                 #error configUSE_TRACE_FACILITY must also be set to 1 in FreeRTOSConfig.h to use vT
4555:FreeRTOS/tasks.c ****             }
4556:FreeRTOS/tasks.c ****         #endif
4557:FreeRTOS/tasks.c **** 
4558:FreeRTOS/tasks.c ****         /*
4559:FreeRTOS/tasks.c ****          * PLEASE NOTE:
4560:FreeRTOS/tasks.c ****          *
4561:FreeRTOS/tasks.c ****          * This function is provided for convenience only, and is used by many
4562:FreeRTOS/tasks.c ****          * of the demo applications.  Do not consider it to be part of the
4563:FreeRTOS/tasks.c ****          * scheduler.
4564:FreeRTOS/tasks.c ****          *
4565:FreeRTOS/tasks.c ****          * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part
4566:FreeRTOS/tasks.c ****          * of the uxTaskGetSystemState() output into a human readable table that
4567:FreeRTOS/tasks.c ****          * displays the amount of time each task has spent in the Running state
4568:FreeRTOS/tasks.c ****          * in both absolute and percentage terms.
4569:FreeRTOS/tasks.c ****          *
4570:FreeRTOS/tasks.c ****          * vTaskGetRunTimeStats() has a dependency on the sprintf() C library
4571:FreeRTOS/tasks.c ****          * function that might bloat the code size, use a lot of stack, and
4572:FreeRTOS/tasks.c ****          * provide different results on different platforms.  An alternative,
4573:FreeRTOS/tasks.c ****          * tiny, third party, and limited functionality implementation of
4574:FreeRTOS/tasks.c ****          * sprintf() is provided in many of the FreeRTOS/Demo sub-directories in
4575:FreeRTOS/tasks.c ****          * a file called printf-stdarg.c (note printf-stdarg.c does not provide
4576:FreeRTOS/tasks.c ****          * a full snprintf() implementation!).
4577:FreeRTOS/tasks.c ****          *
4578:FreeRTOS/tasks.c ****          * It is recommended that production systems call uxTaskGetSystemState()
4579:FreeRTOS/tasks.c ****          * directly to get access to raw stats data, rather than indirectly
ARM GAS  /tmp/ccrgBt0i.s 			page 98


4580:FreeRTOS/tasks.c ****          * through a call to vTaskGetRunTimeStats().
4581:FreeRTOS/tasks.c ****          */
4582:FreeRTOS/tasks.c **** 
4583:FreeRTOS/tasks.c ****         /* Make sure the write buffer does not contain a string. */
4584:FreeRTOS/tasks.c ****         *pcWriteBuffer = ( char ) 0x00;
4585:FreeRTOS/tasks.c **** 
4586:FreeRTOS/tasks.c ****         /* Take a snapshot of the number of tasks in case it changes while this
4587:FreeRTOS/tasks.c ****          * function is executing. */
4588:FreeRTOS/tasks.c ****         uxArraySize = uxCurrentNumberOfTasks;
4589:FreeRTOS/tasks.c **** 
4590:FreeRTOS/tasks.c ****         /* Allocate an array index for each task.  NOTE!  If
4591:FreeRTOS/tasks.c ****          * configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
4592:FreeRTOS/tasks.c ****          * equate to NULL. */
4593:FreeRTOS/tasks.c ****         pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) ); /*lint
4594:FreeRTOS/tasks.c **** 
4595:FreeRTOS/tasks.c ****         if( pxTaskStatusArray != NULL )
4596:FreeRTOS/tasks.c ****         {
4597:FreeRTOS/tasks.c ****             /* Generate the (binary) data. */
4598:FreeRTOS/tasks.c ****             uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalTime );
4599:FreeRTOS/tasks.c **** 
4600:FreeRTOS/tasks.c ****             /* For percentage calculations. */
4601:FreeRTOS/tasks.c ****             ulTotalTime /= 100UL;
4602:FreeRTOS/tasks.c **** 
4603:FreeRTOS/tasks.c ****             /* Avoid divide by zero errors. */
4604:FreeRTOS/tasks.c ****             if( ulTotalTime > 0UL )
4605:FreeRTOS/tasks.c ****             {
4606:FreeRTOS/tasks.c ****                 /* Create a human readable table from the binary data. */
4607:FreeRTOS/tasks.c ****                 for( x = 0; x < uxArraySize; x++ )
4608:FreeRTOS/tasks.c ****                 {
4609:FreeRTOS/tasks.c ****                     /* What percentage of the total run time has the task used?
4610:FreeRTOS/tasks.c ****                      * This will always be rounded down to the nearest integer.
4611:FreeRTOS/tasks.c ****                      * ulTotalRunTime has already been divided by 100. */
4612:FreeRTOS/tasks.c ****                     ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalTime;
4613:FreeRTOS/tasks.c **** 
4614:FreeRTOS/tasks.c ****                     /* Write the task name to the string, padding with
4615:FreeRTOS/tasks.c ****                      * spaces so it can be printed in tabular form more
4616:FreeRTOS/tasks.c ****                      * easily. */
4617:FreeRTOS/tasks.c ****                     pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcT
4618:FreeRTOS/tasks.c **** 
4619:FreeRTOS/tasks.c ****                     if( ulStatsAsPercentage > 0UL )
4620:FreeRTOS/tasks.c ****                     {
4621:FreeRTOS/tasks.c ****                         #ifdef portLU_PRINTF_SPECIFIER_REQUIRED
4622:FreeRTOS/tasks.c ****                             {
4623:FreeRTOS/tasks.c ****                                 sprintf( pcWriteBuffer, "\t%lu\t\t%lu%%\r\n", pxTaskStatusArray[ x 
4624:FreeRTOS/tasks.c ****                             }
4625:FreeRTOS/tasks.c ****                         #else
4626:FreeRTOS/tasks.c ****                             {
4627:FreeRTOS/tasks.c ****                                 /* sizeof( int ) == sizeof( long ) so a smaller
4628:FreeRTOS/tasks.c ****                                  * printf() library can be used. */
4629:FreeRTOS/tasks.c ****                                 sprintf( pcWriteBuffer, "\t%u\t\t%u%%\r\n", ( unsigned int ) pxTask
4630:FreeRTOS/tasks.c ****                             }
4631:FreeRTOS/tasks.c ****                         #endif
4632:FreeRTOS/tasks.c ****                     }
4633:FreeRTOS/tasks.c ****                     else
4634:FreeRTOS/tasks.c ****                     {
4635:FreeRTOS/tasks.c ****                         /* If the percentage is zero here then the task has
4636:FreeRTOS/tasks.c ****                          * consumed less than 1% of the total run time. */
ARM GAS  /tmp/ccrgBt0i.s 			page 99


4637:FreeRTOS/tasks.c ****                         #ifdef portLU_PRINTF_SPECIFIER_REQUIRED
4638:FreeRTOS/tasks.c ****                             {
4639:FreeRTOS/tasks.c ****                                 sprintf( pcWriteBuffer, "\t%lu\t\t<1%%\r\n", pxTaskStatusArray[ x ]
4640:FreeRTOS/tasks.c ****                             }
4641:FreeRTOS/tasks.c ****                         #else
4642:FreeRTOS/tasks.c ****                             {
4643:FreeRTOS/tasks.c ****                                 /* sizeof( int ) == sizeof( long ) so a smaller
4644:FreeRTOS/tasks.c ****                                  * printf() library can be used. */
4645:FreeRTOS/tasks.c ****                                 sprintf( pcWriteBuffer, "\t%u\t\t<1%%\r\n", ( unsigned int ) pxTask
4646:FreeRTOS/tasks.c ****                             }
4647:FreeRTOS/tasks.c ****                         #endif
4648:FreeRTOS/tasks.c ****                     }
4649:FreeRTOS/tasks.c **** 
4650:FreeRTOS/tasks.c ****                     pcWriteBuffer += strlen( pcWriteBuffer ); /*lint !e9016 Pointer arithmetic ok o
4651:FreeRTOS/tasks.c ****                 }
4652:FreeRTOS/tasks.c ****             }
4653:FreeRTOS/tasks.c ****             else
4654:FreeRTOS/tasks.c ****             {
4655:FreeRTOS/tasks.c ****                 mtCOVERAGE_TEST_MARKER();
4656:FreeRTOS/tasks.c ****             }
4657:FreeRTOS/tasks.c **** 
4658:FreeRTOS/tasks.c ****             /* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
4659:FreeRTOS/tasks.c ****              * is 0 then vPortFree() will be #defined to nothing. */
4660:FreeRTOS/tasks.c ****             vPortFree( pxTaskStatusArray );
4661:FreeRTOS/tasks.c ****         }
4662:FreeRTOS/tasks.c ****         else
4663:FreeRTOS/tasks.c ****         {
4664:FreeRTOS/tasks.c ****             mtCOVERAGE_TEST_MARKER();
4665:FreeRTOS/tasks.c ****         }
4666:FreeRTOS/tasks.c ****     }
4667:FreeRTOS/tasks.c **** 
4668:FreeRTOS/tasks.c **** #endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) 
4669:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
4670:FreeRTOS/tasks.c **** 
4671:FreeRTOS/tasks.c **** TickType_t uxTaskResetEventItemValue( void )
4672:FreeRTOS/tasks.c **** {
4673:FreeRTOS/tasks.c ****     TickType_t uxReturn;
4674:FreeRTOS/tasks.c **** 
4675:FreeRTOS/tasks.c ****     uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
4676:FreeRTOS/tasks.c **** 
4677:FreeRTOS/tasks.c ****     /* Reset the event list item to its normal value - so it can be used with
4678:FreeRTOS/tasks.c ****      * queues and semaphores. */
4679:FreeRTOS/tasks.c ****     listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITI
4680:FreeRTOS/tasks.c **** 
4681:FreeRTOS/tasks.c ****     return uxReturn;
4682:FreeRTOS/tasks.c **** }
4683:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
4684:FreeRTOS/tasks.c **** 
4685:FreeRTOS/tasks.c **** #if ( configUSE_MUTEXES == 1 )
4686:FreeRTOS/tasks.c **** 
4687:FreeRTOS/tasks.c ****     TaskHandle_t pvTaskIncrementMutexHeldCount( void )
4688:FreeRTOS/tasks.c ****     {
4689:FreeRTOS/tasks.c ****         /* If xSemaphoreCreateMutex() is called before any tasks have been created
4690:FreeRTOS/tasks.c ****          * then pxCurrentTCB will be NULL. */
4691:FreeRTOS/tasks.c ****         if( pxCurrentTCB != NULL )
4692:FreeRTOS/tasks.c ****         {
4693:FreeRTOS/tasks.c ****             ( pxCurrentTCB->uxMutexesHeld )++;
ARM GAS  /tmp/ccrgBt0i.s 			page 100


4694:FreeRTOS/tasks.c ****         }
4695:FreeRTOS/tasks.c **** 
4696:FreeRTOS/tasks.c ****         return pxCurrentTCB;
4697:FreeRTOS/tasks.c ****     }
4698:FreeRTOS/tasks.c **** 
4699:FreeRTOS/tasks.c **** #endif /* configUSE_MUTEXES */
4700:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
4701:FreeRTOS/tasks.c **** 
4702:FreeRTOS/tasks.c **** #if ( configUSE_TASK_NOTIFICATIONS == 1 )
4703:FreeRTOS/tasks.c **** 
4704:FreeRTOS/tasks.c ****     uint32_t ulTaskGenericNotifyTake( UBaseType_t uxIndexToWait,
4705:FreeRTOS/tasks.c ****                                       BaseType_t xClearCountOnExit,
4706:FreeRTOS/tasks.c ****                                       TickType_t xTicksToWait )
4707:FreeRTOS/tasks.c ****     {
4708:FreeRTOS/tasks.c ****         uint32_t ulReturn;
4709:FreeRTOS/tasks.c **** 
4710:FreeRTOS/tasks.c ****         configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );
4711:FreeRTOS/tasks.c **** 
4712:FreeRTOS/tasks.c ****         taskENTER_CRITICAL();
4713:FreeRTOS/tasks.c ****         {
4714:FreeRTOS/tasks.c ****             /* Only block if the notification count is not already non-zero. */
4715:FreeRTOS/tasks.c ****             if( pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] == 0UL )
4716:FreeRTOS/tasks.c ****             {
4717:FreeRTOS/tasks.c ****                 /* Mark this task as waiting for a notification. */
4718:FreeRTOS/tasks.c ****                 pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
4719:FreeRTOS/tasks.c **** 
4720:FreeRTOS/tasks.c ****                 if( xTicksToWait > ( TickType_t ) 0 )
4721:FreeRTOS/tasks.c ****                 {
4722:FreeRTOS/tasks.c ****                     prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
4723:FreeRTOS/tasks.c ****                     traceTASK_NOTIFY_TAKE_BLOCK( uxIndexToWait );
4724:FreeRTOS/tasks.c **** 
4725:FreeRTOS/tasks.c ****                     /* All ports are written to allow a yield in a critical
4726:FreeRTOS/tasks.c ****                      * section (some will yield immediately, others wait until the
4727:FreeRTOS/tasks.c ****                      * critical section exits) - but it is not something that
4728:FreeRTOS/tasks.c ****                      * application code should ever do. */
4729:FreeRTOS/tasks.c ****                     portYIELD_WITHIN_API();
4730:FreeRTOS/tasks.c ****                 }
4731:FreeRTOS/tasks.c ****                 else
4732:FreeRTOS/tasks.c ****                 {
4733:FreeRTOS/tasks.c ****                     mtCOVERAGE_TEST_MARKER();
4734:FreeRTOS/tasks.c ****                 }
4735:FreeRTOS/tasks.c ****             }
4736:FreeRTOS/tasks.c ****             else
4737:FreeRTOS/tasks.c ****             {
4738:FreeRTOS/tasks.c ****                 mtCOVERAGE_TEST_MARKER();
4739:FreeRTOS/tasks.c ****             }
4740:FreeRTOS/tasks.c ****         }
4741:FreeRTOS/tasks.c ****         taskEXIT_CRITICAL();
4742:FreeRTOS/tasks.c **** 
4743:FreeRTOS/tasks.c ****         taskENTER_CRITICAL();
4744:FreeRTOS/tasks.c ****         {
4745:FreeRTOS/tasks.c ****             traceTASK_NOTIFY_TAKE( uxIndexToWait );
4746:FreeRTOS/tasks.c ****             ulReturn = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
4747:FreeRTOS/tasks.c **** 
4748:FreeRTOS/tasks.c ****             if( ulReturn != 0UL )
4749:FreeRTOS/tasks.c ****             {
4750:FreeRTOS/tasks.c ****                 if( xClearCountOnExit != pdFALSE )
ARM GAS  /tmp/ccrgBt0i.s 			page 101


4751:FreeRTOS/tasks.c ****                 {
4752:FreeRTOS/tasks.c ****                     pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = 0UL;
4753:FreeRTOS/tasks.c ****                 }
4754:FreeRTOS/tasks.c ****                 else
4755:FreeRTOS/tasks.c ****                 {
4756:FreeRTOS/tasks.c ****                     pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = ulReturn - ( uint32_t ) 1;
4757:FreeRTOS/tasks.c ****                 }
4758:FreeRTOS/tasks.c ****             }
4759:FreeRTOS/tasks.c ****             else
4760:FreeRTOS/tasks.c ****             {
4761:FreeRTOS/tasks.c ****                 mtCOVERAGE_TEST_MARKER();
4762:FreeRTOS/tasks.c ****             }
4763:FreeRTOS/tasks.c **** 
4764:FreeRTOS/tasks.c ****             pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
4765:FreeRTOS/tasks.c ****         }
4766:FreeRTOS/tasks.c ****         taskEXIT_CRITICAL();
4767:FreeRTOS/tasks.c **** 
4768:FreeRTOS/tasks.c ****         return ulReturn;
4769:FreeRTOS/tasks.c ****     }
4770:FreeRTOS/tasks.c **** 
4771:FreeRTOS/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4772:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
4773:FreeRTOS/tasks.c **** 
4774:FreeRTOS/tasks.c **** #if ( configUSE_TASK_NOTIFICATIONS == 1 )
4775:FreeRTOS/tasks.c **** 
4776:FreeRTOS/tasks.c ****     BaseType_t xTaskGenericNotifyWait( UBaseType_t uxIndexToWait,
4777:FreeRTOS/tasks.c ****                                        uint32_t ulBitsToClearOnEntry,
4778:FreeRTOS/tasks.c ****                                        uint32_t ulBitsToClearOnExit,
4779:FreeRTOS/tasks.c ****                                        uint32_t * pulNotificationValue,
4780:FreeRTOS/tasks.c ****                                        TickType_t xTicksToWait )
4781:FreeRTOS/tasks.c ****     {
4782:FreeRTOS/tasks.c ****         BaseType_t xReturn;
4783:FreeRTOS/tasks.c **** 
4784:FreeRTOS/tasks.c ****         configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );
4785:FreeRTOS/tasks.c **** 
4786:FreeRTOS/tasks.c ****         taskENTER_CRITICAL();
4787:FreeRTOS/tasks.c ****         {
4788:FreeRTOS/tasks.c ****             /* Only block if a notification is not already pending. */
4789:FreeRTOS/tasks.c ****             if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
4790:FreeRTOS/tasks.c ****             {
4791:FreeRTOS/tasks.c ****                 /* Clear bits in the task's notification value as bits may get
4792:FreeRTOS/tasks.c ****                  * set  by the notifying task or interrupt.  This can be used to
4793:FreeRTOS/tasks.c ****                  * clear the value to zero. */
4794:FreeRTOS/tasks.c ****                 pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnEntry;
4795:FreeRTOS/tasks.c **** 
4796:FreeRTOS/tasks.c ****                 /* Mark this task as waiting for a notification. */
4797:FreeRTOS/tasks.c ****                 pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
4798:FreeRTOS/tasks.c **** 
4799:FreeRTOS/tasks.c ****                 if( xTicksToWait > ( TickType_t ) 0 )
4800:FreeRTOS/tasks.c ****                 {
4801:FreeRTOS/tasks.c ****                     prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
4802:FreeRTOS/tasks.c ****                     traceTASK_NOTIFY_WAIT_BLOCK( uxIndexToWait );
4803:FreeRTOS/tasks.c **** 
4804:FreeRTOS/tasks.c ****                     /* All ports are written to allow a yield in a critical
4805:FreeRTOS/tasks.c ****                      * section (some will yield immediately, others wait until the
4806:FreeRTOS/tasks.c ****                      * critical section exits) - but it is not something that
4807:FreeRTOS/tasks.c ****                      * application code should ever do. */
ARM GAS  /tmp/ccrgBt0i.s 			page 102


4808:FreeRTOS/tasks.c ****                     portYIELD_WITHIN_API();
4809:FreeRTOS/tasks.c ****                 }
4810:FreeRTOS/tasks.c ****                 else
4811:FreeRTOS/tasks.c ****                 {
4812:FreeRTOS/tasks.c ****                     mtCOVERAGE_TEST_MARKER();
4813:FreeRTOS/tasks.c ****                 }
4814:FreeRTOS/tasks.c ****             }
4815:FreeRTOS/tasks.c ****             else
4816:FreeRTOS/tasks.c ****             {
4817:FreeRTOS/tasks.c ****                 mtCOVERAGE_TEST_MARKER();
4818:FreeRTOS/tasks.c ****             }
4819:FreeRTOS/tasks.c ****         }
4820:FreeRTOS/tasks.c ****         taskEXIT_CRITICAL();
4821:FreeRTOS/tasks.c **** 
4822:FreeRTOS/tasks.c ****         taskENTER_CRITICAL();
4823:FreeRTOS/tasks.c ****         {
4824:FreeRTOS/tasks.c ****             traceTASK_NOTIFY_WAIT( uxIndexToWait );
4825:FreeRTOS/tasks.c **** 
4826:FreeRTOS/tasks.c ****             if( pulNotificationValue != NULL )
4827:FreeRTOS/tasks.c ****             {
4828:FreeRTOS/tasks.c ****                 /* Output the current notification value, which may or may not
4829:FreeRTOS/tasks.c ****                  * have changed. */
4830:FreeRTOS/tasks.c ****                 *pulNotificationValue = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
4831:FreeRTOS/tasks.c ****             }
4832:FreeRTOS/tasks.c **** 
4833:FreeRTOS/tasks.c ****             /* If ucNotifyValue is set then either the task never entered the
4834:FreeRTOS/tasks.c ****              * blocked state (because a notification was already pending) or the
4835:FreeRTOS/tasks.c ****              * task unblocked because of a notification.  Otherwise the task
4836:FreeRTOS/tasks.c ****              * unblocked because of a timeout. */
4837:FreeRTOS/tasks.c ****             if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
4838:FreeRTOS/tasks.c ****             {
4839:FreeRTOS/tasks.c ****                 /* A notification was not received. */
4840:FreeRTOS/tasks.c ****                 xReturn = pdFALSE;
4841:FreeRTOS/tasks.c ****             }
4842:FreeRTOS/tasks.c ****             else
4843:FreeRTOS/tasks.c ****             {
4844:FreeRTOS/tasks.c ****                 /* A notification was already pending or a notification was
4845:FreeRTOS/tasks.c ****                  * received while the task was waiting. */
4846:FreeRTOS/tasks.c ****                 pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnExit;
4847:FreeRTOS/tasks.c ****                 xReturn = pdTRUE;
4848:FreeRTOS/tasks.c ****             }
4849:FreeRTOS/tasks.c **** 
4850:FreeRTOS/tasks.c ****             pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
4851:FreeRTOS/tasks.c ****         }
4852:FreeRTOS/tasks.c ****         taskEXIT_CRITICAL();
4853:FreeRTOS/tasks.c **** 
4854:FreeRTOS/tasks.c ****         return xReturn;
4855:FreeRTOS/tasks.c ****     }
4856:FreeRTOS/tasks.c **** 
4857:FreeRTOS/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4858:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
4859:FreeRTOS/tasks.c **** 
4860:FreeRTOS/tasks.c **** #if ( configUSE_TASK_NOTIFICATIONS == 1 )
4861:FreeRTOS/tasks.c **** 
4862:FreeRTOS/tasks.c ****     BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify,
4863:FreeRTOS/tasks.c ****                                    UBaseType_t uxIndexToNotify,
4864:FreeRTOS/tasks.c ****                                    uint32_t ulValue,
ARM GAS  /tmp/ccrgBt0i.s 			page 103


4865:FreeRTOS/tasks.c ****                                    eNotifyAction eAction,
4866:FreeRTOS/tasks.c ****                                    uint32_t * pulPreviousNotificationValue )
4867:FreeRTOS/tasks.c ****     {
4868:FreeRTOS/tasks.c ****         TCB_t * pxTCB;
4869:FreeRTOS/tasks.c ****         BaseType_t xReturn = pdPASS;
4870:FreeRTOS/tasks.c ****         uint8_t ucOriginalNotifyState;
4871:FreeRTOS/tasks.c **** 
4872:FreeRTOS/tasks.c ****         configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
4873:FreeRTOS/tasks.c ****         configASSERT( xTaskToNotify );
4874:FreeRTOS/tasks.c ****         pxTCB = xTaskToNotify;
4875:FreeRTOS/tasks.c **** 
4876:FreeRTOS/tasks.c ****         taskENTER_CRITICAL();
4877:FreeRTOS/tasks.c ****         {
4878:FreeRTOS/tasks.c ****             if( pulPreviousNotificationValue != NULL )
4879:FreeRTOS/tasks.c ****             {
4880:FreeRTOS/tasks.c ****                 *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
4881:FreeRTOS/tasks.c ****             }
4882:FreeRTOS/tasks.c **** 
4883:FreeRTOS/tasks.c ****             ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
4884:FreeRTOS/tasks.c **** 
4885:FreeRTOS/tasks.c ****             pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
4886:FreeRTOS/tasks.c **** 
4887:FreeRTOS/tasks.c ****             switch( eAction )
4888:FreeRTOS/tasks.c ****             {
4889:FreeRTOS/tasks.c ****                 case eSetBits:
4890:FreeRTOS/tasks.c ****                     pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
4891:FreeRTOS/tasks.c ****                     break;
4892:FreeRTOS/tasks.c **** 
4893:FreeRTOS/tasks.c ****                 case eIncrement:
4894:FreeRTOS/tasks.c ****                     ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
4895:FreeRTOS/tasks.c ****                     break;
4896:FreeRTOS/tasks.c **** 
4897:FreeRTOS/tasks.c ****                 case eSetValueWithOverwrite:
4898:FreeRTOS/tasks.c ****                     pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
4899:FreeRTOS/tasks.c ****                     break;
4900:FreeRTOS/tasks.c **** 
4901:FreeRTOS/tasks.c ****                 case eSetValueWithoutOverwrite:
4902:FreeRTOS/tasks.c **** 
4903:FreeRTOS/tasks.c ****                     if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
4904:FreeRTOS/tasks.c ****                     {
4905:FreeRTOS/tasks.c ****                         pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
4906:FreeRTOS/tasks.c ****                     }
4907:FreeRTOS/tasks.c ****                     else
4908:FreeRTOS/tasks.c ****                     {
4909:FreeRTOS/tasks.c ****                         /* The value could not be written to the task. */
4910:FreeRTOS/tasks.c ****                         xReturn = pdFAIL;
4911:FreeRTOS/tasks.c ****                     }
4912:FreeRTOS/tasks.c **** 
4913:FreeRTOS/tasks.c ****                     break;
4914:FreeRTOS/tasks.c **** 
4915:FreeRTOS/tasks.c ****                 case eNoAction:
4916:FreeRTOS/tasks.c **** 
4917:FreeRTOS/tasks.c ****                     /* The task is being notified without its notify value being
4918:FreeRTOS/tasks.c ****                      * updated. */
4919:FreeRTOS/tasks.c ****                     break;
4920:FreeRTOS/tasks.c **** 
4921:FreeRTOS/tasks.c ****                 default:
ARM GAS  /tmp/ccrgBt0i.s 			page 104


4922:FreeRTOS/tasks.c **** 
4923:FreeRTOS/tasks.c ****                     /* Should not get here if all enums are handled.
4924:FreeRTOS/tasks.c ****                      * Artificially force an assert by testing a value the
4925:FreeRTOS/tasks.c ****                      * compiler can't assume is const. */
4926:FreeRTOS/tasks.c ****                     configASSERT( xTickCount == ( TickType_t ) 0 );
4927:FreeRTOS/tasks.c **** 
4928:FreeRTOS/tasks.c ****                     break;
4929:FreeRTOS/tasks.c ****             }
4930:FreeRTOS/tasks.c **** 
4931:FreeRTOS/tasks.c ****             traceTASK_NOTIFY( uxIndexToNotify );
4932:FreeRTOS/tasks.c **** 
4933:FreeRTOS/tasks.c ****             /* If the task is in the blocked state specifically to wait for a
4934:FreeRTOS/tasks.c ****              * notification then unblock it now. */
4935:FreeRTOS/tasks.c ****             if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
4936:FreeRTOS/tasks.c ****             {
4937:FreeRTOS/tasks.c ****                 listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
4938:FreeRTOS/tasks.c ****                 prvAddTaskToReadyList( pxTCB );
4939:FreeRTOS/tasks.c **** 
4940:FreeRTOS/tasks.c ****                 /* The task should not have been on an event list. */
4941:FreeRTOS/tasks.c ****                 configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
4942:FreeRTOS/tasks.c **** 
4943:FreeRTOS/tasks.c ****                 #if ( configUSE_TICKLESS_IDLE != 0 )
4944:FreeRTOS/tasks.c ****                     {
4945:FreeRTOS/tasks.c ****                         /* If a task is blocked waiting for a notification then
4946:FreeRTOS/tasks.c ****                          * xNextTaskUnblockTime might be set to the blocked task's time
4947:FreeRTOS/tasks.c ****                          * out time.  If the task is unblocked for a reason other than
4948:FreeRTOS/tasks.c ****                          * a timeout xNextTaskUnblockTime is normally left unchanged,
4949:FreeRTOS/tasks.c ****                          * because it will automatically get reset to a new value when
4950:FreeRTOS/tasks.c ****                          * the tick count equals xNextTaskUnblockTime.  However if
4951:FreeRTOS/tasks.c ****                          * tickless idling is used it might be more important to enter
4952:FreeRTOS/tasks.c ****                          * sleep mode at the earliest possible time - so reset
4953:FreeRTOS/tasks.c ****                          * xNextTaskUnblockTime here to ensure it is updated at the
4954:FreeRTOS/tasks.c ****                          * earliest possible time. */
4955:FreeRTOS/tasks.c ****                         prvResetNextTaskUnblockTime();
4956:FreeRTOS/tasks.c ****                     }
4957:FreeRTOS/tasks.c ****                 #endif
4958:FreeRTOS/tasks.c **** 
4959:FreeRTOS/tasks.c ****                 if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
4960:FreeRTOS/tasks.c ****                 {
4961:FreeRTOS/tasks.c ****                     /* The notified task has a priority above the currently
4962:FreeRTOS/tasks.c ****                      * executing task so a yield is required. */
4963:FreeRTOS/tasks.c ****                     taskYIELD_IF_USING_PREEMPTION();
4964:FreeRTOS/tasks.c ****                 }
4965:FreeRTOS/tasks.c ****                 else
4966:FreeRTOS/tasks.c ****                 {
4967:FreeRTOS/tasks.c ****                     mtCOVERAGE_TEST_MARKER();
4968:FreeRTOS/tasks.c ****                 }
4969:FreeRTOS/tasks.c ****             }
4970:FreeRTOS/tasks.c ****             else
4971:FreeRTOS/tasks.c ****             {
4972:FreeRTOS/tasks.c ****                 mtCOVERAGE_TEST_MARKER();
4973:FreeRTOS/tasks.c ****             }
4974:FreeRTOS/tasks.c ****         }
4975:FreeRTOS/tasks.c ****         taskEXIT_CRITICAL();
4976:FreeRTOS/tasks.c **** 
4977:FreeRTOS/tasks.c ****         return xReturn;
4978:FreeRTOS/tasks.c ****     }
ARM GAS  /tmp/ccrgBt0i.s 			page 105


4979:FreeRTOS/tasks.c **** 
4980:FreeRTOS/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4981:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
4982:FreeRTOS/tasks.c **** 
4983:FreeRTOS/tasks.c **** #if ( configUSE_TASK_NOTIFICATIONS == 1 )
4984:FreeRTOS/tasks.c **** 
4985:FreeRTOS/tasks.c ****     BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify,
4986:FreeRTOS/tasks.c ****                                           UBaseType_t uxIndexToNotify,
4987:FreeRTOS/tasks.c ****                                           uint32_t ulValue,
4988:FreeRTOS/tasks.c ****                                           eNotifyAction eAction,
4989:FreeRTOS/tasks.c ****                                           uint32_t * pulPreviousNotificationValue,
4990:FreeRTOS/tasks.c ****                                           BaseType_t * pxHigherPriorityTaskWoken )
4991:FreeRTOS/tasks.c ****     {
4992:FreeRTOS/tasks.c ****         TCB_t * pxTCB;
4993:FreeRTOS/tasks.c ****         uint8_t ucOriginalNotifyState;
4994:FreeRTOS/tasks.c ****         BaseType_t xReturn = pdPASS;
4995:FreeRTOS/tasks.c ****         UBaseType_t uxSavedInterruptStatus;
4996:FreeRTOS/tasks.c **** 
4997:FreeRTOS/tasks.c ****         configASSERT( xTaskToNotify );
4998:FreeRTOS/tasks.c ****         configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
4999:FreeRTOS/tasks.c **** 
5000:FreeRTOS/tasks.c ****         /* RTOS ports that support interrupt nesting have the concept of a
5001:FreeRTOS/tasks.c ****          * maximum  system call (or maximum API call) interrupt priority.
5002:FreeRTOS/tasks.c ****          * Interrupts that are  above the maximum system call priority are keep
5003:FreeRTOS/tasks.c ****          * permanently enabled, even when the RTOS kernel is in a critical section,
5004:FreeRTOS/tasks.c ****          * but cannot make any calls to FreeRTOS API functions.  If configASSERT()
5005:FreeRTOS/tasks.c ****          * is defined in FreeRTOSConfig.h then
5006:FreeRTOS/tasks.c ****          * portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
5007:FreeRTOS/tasks.c ****          * failure if a FreeRTOS API function is called from an interrupt that has
5008:FreeRTOS/tasks.c ****          * been assigned a priority above the configured maximum system call
5009:FreeRTOS/tasks.c ****          * priority.  Only FreeRTOS functions that end in FromISR can be called
5010:FreeRTOS/tasks.c ****          * from interrupts  that have been assigned a priority at or (logically)
5011:FreeRTOS/tasks.c ****          * below the maximum system call interrupt priority.  FreeRTOS maintains a
5012:FreeRTOS/tasks.c ****          * separate interrupt safe API to ensure interrupt entry is as fast and as
5013:FreeRTOS/tasks.c ****          * simple as possible.  More information (albeit Cortex-M specific) is
5014:FreeRTOS/tasks.c ****          * provided on the following link:
5015:FreeRTOS/tasks.c ****          * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
5016:FreeRTOS/tasks.c ****         portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
5017:FreeRTOS/tasks.c **** 
5018:FreeRTOS/tasks.c ****         pxTCB = xTaskToNotify;
5019:FreeRTOS/tasks.c **** 
5020:FreeRTOS/tasks.c ****         uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
5021:FreeRTOS/tasks.c ****         {
5022:FreeRTOS/tasks.c ****             if( pulPreviousNotificationValue != NULL )
5023:FreeRTOS/tasks.c ****             {
5024:FreeRTOS/tasks.c ****                 *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
5025:FreeRTOS/tasks.c ****             }
5026:FreeRTOS/tasks.c **** 
5027:FreeRTOS/tasks.c ****             ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
5028:FreeRTOS/tasks.c ****             pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
5029:FreeRTOS/tasks.c **** 
5030:FreeRTOS/tasks.c ****             switch( eAction )
5031:FreeRTOS/tasks.c ****             {
5032:FreeRTOS/tasks.c ****                 case eSetBits:
5033:FreeRTOS/tasks.c ****                     pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
5034:FreeRTOS/tasks.c ****                     break;
5035:FreeRTOS/tasks.c **** 
ARM GAS  /tmp/ccrgBt0i.s 			page 106


5036:FreeRTOS/tasks.c ****                 case eIncrement:
5037:FreeRTOS/tasks.c ****                     ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
5038:FreeRTOS/tasks.c ****                     break;
5039:FreeRTOS/tasks.c **** 
5040:FreeRTOS/tasks.c ****                 case eSetValueWithOverwrite:
5041:FreeRTOS/tasks.c ****                     pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
5042:FreeRTOS/tasks.c ****                     break;
5043:FreeRTOS/tasks.c **** 
5044:FreeRTOS/tasks.c ****                 case eSetValueWithoutOverwrite:
5045:FreeRTOS/tasks.c **** 
5046:FreeRTOS/tasks.c ****                     if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
5047:FreeRTOS/tasks.c ****                     {
5048:FreeRTOS/tasks.c ****                         pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
5049:FreeRTOS/tasks.c ****                     }
5050:FreeRTOS/tasks.c ****                     else
5051:FreeRTOS/tasks.c ****                     {
5052:FreeRTOS/tasks.c ****                         /* The value could not be written to the task. */
5053:FreeRTOS/tasks.c ****                         xReturn = pdFAIL;
5054:FreeRTOS/tasks.c ****                     }
5055:FreeRTOS/tasks.c **** 
5056:FreeRTOS/tasks.c ****                     break;
5057:FreeRTOS/tasks.c **** 
5058:FreeRTOS/tasks.c ****                 case eNoAction:
5059:FreeRTOS/tasks.c **** 
5060:FreeRTOS/tasks.c ****                     /* The task is being notified without its notify value being
5061:FreeRTOS/tasks.c ****                      * updated. */
5062:FreeRTOS/tasks.c ****                     break;
5063:FreeRTOS/tasks.c **** 
5064:FreeRTOS/tasks.c ****                 default:
5065:FreeRTOS/tasks.c **** 
5066:FreeRTOS/tasks.c ****                     /* Should not get here if all enums are handled.
5067:FreeRTOS/tasks.c ****                      * Artificially force an assert by testing a value the
5068:FreeRTOS/tasks.c ****                      * compiler can't assume is const. */
5069:FreeRTOS/tasks.c ****                     configASSERT( xTickCount == ( TickType_t ) 0 );
5070:FreeRTOS/tasks.c ****                     break;
5071:FreeRTOS/tasks.c ****             }
5072:FreeRTOS/tasks.c **** 
5073:FreeRTOS/tasks.c ****             traceTASK_NOTIFY_FROM_ISR( uxIndexToNotify );
5074:FreeRTOS/tasks.c **** 
5075:FreeRTOS/tasks.c ****             /* If the task is in the blocked state specifically to wait for a
5076:FreeRTOS/tasks.c ****              * notification then unblock it now. */
5077:FreeRTOS/tasks.c ****             if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
5078:FreeRTOS/tasks.c ****             {
5079:FreeRTOS/tasks.c ****                 /* The task should not have been on an event list. */
5080:FreeRTOS/tasks.c ****                 configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
5081:FreeRTOS/tasks.c **** 
5082:FreeRTOS/tasks.c ****                 if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
5083:FreeRTOS/tasks.c ****                 {
5084:FreeRTOS/tasks.c ****                     listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
5085:FreeRTOS/tasks.c ****                     prvAddTaskToReadyList( pxTCB );
5086:FreeRTOS/tasks.c ****                 }
5087:FreeRTOS/tasks.c ****                 else
5088:FreeRTOS/tasks.c ****                 {
5089:FreeRTOS/tasks.c ****                     /* The delayed and ready lists cannot be accessed, so hold
5090:FreeRTOS/tasks.c ****                      * this task pending until the scheduler is resumed. */
5091:FreeRTOS/tasks.c ****                     listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
5092:FreeRTOS/tasks.c ****                 }
ARM GAS  /tmp/ccrgBt0i.s 			page 107


5093:FreeRTOS/tasks.c **** 
5094:FreeRTOS/tasks.c ****                 if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
5095:FreeRTOS/tasks.c ****                 {
5096:FreeRTOS/tasks.c ****                     /* The notified task has a priority above the currently
5097:FreeRTOS/tasks.c ****                      * executing task so a yield is required. */
5098:FreeRTOS/tasks.c ****                     if( pxHigherPriorityTaskWoken != NULL )
5099:FreeRTOS/tasks.c ****                     {
5100:FreeRTOS/tasks.c ****                         *pxHigherPriorityTaskWoken = pdTRUE;
5101:FreeRTOS/tasks.c ****                     }
5102:FreeRTOS/tasks.c **** 
5103:FreeRTOS/tasks.c ****                     /* Mark that a yield is pending in case the user is not
5104:FreeRTOS/tasks.c ****                      * using the "xHigherPriorityTaskWoken" parameter to an ISR
5105:FreeRTOS/tasks.c ****                      * safe FreeRTOS function. */
5106:FreeRTOS/tasks.c ****                     xYieldPending = pdTRUE;
5107:FreeRTOS/tasks.c ****                 }
5108:FreeRTOS/tasks.c ****                 else
5109:FreeRTOS/tasks.c ****                 {
5110:FreeRTOS/tasks.c ****                     mtCOVERAGE_TEST_MARKER();
5111:FreeRTOS/tasks.c ****                 }
5112:FreeRTOS/tasks.c ****             }
5113:FreeRTOS/tasks.c ****         }
5114:FreeRTOS/tasks.c ****         portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
5115:FreeRTOS/tasks.c **** 
5116:FreeRTOS/tasks.c ****         return xReturn;
5117:FreeRTOS/tasks.c ****     }
5118:FreeRTOS/tasks.c **** 
5119:FreeRTOS/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
5120:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
5121:FreeRTOS/tasks.c **** 
5122:FreeRTOS/tasks.c **** #if ( configUSE_TASK_NOTIFICATIONS == 1 )
5123:FreeRTOS/tasks.c **** 
5124:FreeRTOS/tasks.c ****     void vTaskGenericNotifyGiveFromISR( TaskHandle_t xTaskToNotify,
5125:FreeRTOS/tasks.c ****                                         UBaseType_t uxIndexToNotify,
5126:FreeRTOS/tasks.c ****                                         BaseType_t * pxHigherPriorityTaskWoken )
5127:FreeRTOS/tasks.c ****     {
5128:FreeRTOS/tasks.c ****         TCB_t * pxTCB;
5129:FreeRTOS/tasks.c ****         uint8_t ucOriginalNotifyState;
5130:FreeRTOS/tasks.c ****         UBaseType_t uxSavedInterruptStatus;
5131:FreeRTOS/tasks.c **** 
5132:FreeRTOS/tasks.c ****         configASSERT( xTaskToNotify );
5133:FreeRTOS/tasks.c ****         configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
5134:FreeRTOS/tasks.c **** 
5135:FreeRTOS/tasks.c ****         /* RTOS ports that support interrupt nesting have the concept of a
5136:FreeRTOS/tasks.c ****          * maximum  system call (or maximum API call) interrupt priority.
5137:FreeRTOS/tasks.c ****          * Interrupts that are  above the maximum system call priority are keep
5138:FreeRTOS/tasks.c ****          * permanently enabled, even when the RTOS kernel is in a critical section,
5139:FreeRTOS/tasks.c ****          * but cannot make any calls to FreeRTOS API functions.  If configASSERT()
5140:FreeRTOS/tasks.c ****          * is defined in FreeRTOSConfig.h then
5141:FreeRTOS/tasks.c ****          * portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
5142:FreeRTOS/tasks.c ****          * failure if a FreeRTOS API function is called from an interrupt that has
5143:FreeRTOS/tasks.c ****          * been assigned a priority above the configured maximum system call
5144:FreeRTOS/tasks.c ****          * priority.  Only FreeRTOS functions that end in FromISR can be called
5145:FreeRTOS/tasks.c ****          * from interrupts  that have been assigned a priority at or (logically)
5146:FreeRTOS/tasks.c ****          * below the maximum system call interrupt priority.  FreeRTOS maintains a
5147:FreeRTOS/tasks.c ****          * separate interrupt safe API to ensure interrupt entry is as fast and as
5148:FreeRTOS/tasks.c ****          * simple as possible.  More information (albeit Cortex-M specific) is
5149:FreeRTOS/tasks.c ****          * provided on the following link:
ARM GAS  /tmp/ccrgBt0i.s 			page 108


5150:FreeRTOS/tasks.c ****          * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
5151:FreeRTOS/tasks.c ****         portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
5152:FreeRTOS/tasks.c **** 
5153:FreeRTOS/tasks.c ****         pxTCB = xTaskToNotify;
5154:FreeRTOS/tasks.c **** 
5155:FreeRTOS/tasks.c ****         uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
5156:FreeRTOS/tasks.c ****         {
5157:FreeRTOS/tasks.c ****             ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
5158:FreeRTOS/tasks.c ****             pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
5159:FreeRTOS/tasks.c **** 
5160:FreeRTOS/tasks.c ****             /* 'Giving' is equivalent to incrementing a count in a counting
5161:FreeRTOS/tasks.c ****              * semaphore. */
5162:FreeRTOS/tasks.c ****             ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
5163:FreeRTOS/tasks.c **** 
5164:FreeRTOS/tasks.c ****             traceTASK_NOTIFY_GIVE_FROM_ISR( uxIndexToNotify );
5165:FreeRTOS/tasks.c **** 
5166:FreeRTOS/tasks.c ****             /* If the task is in the blocked state specifically to wait for a
5167:FreeRTOS/tasks.c ****              * notification then unblock it now. */
5168:FreeRTOS/tasks.c ****             if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
5169:FreeRTOS/tasks.c ****             {
5170:FreeRTOS/tasks.c ****                 /* The task should not have been on an event list. */
5171:FreeRTOS/tasks.c ****                 configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
5172:FreeRTOS/tasks.c **** 
5173:FreeRTOS/tasks.c ****                 if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
5174:FreeRTOS/tasks.c ****                 {
5175:FreeRTOS/tasks.c ****                     listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
5176:FreeRTOS/tasks.c ****                     prvAddTaskToReadyList( pxTCB );
5177:FreeRTOS/tasks.c ****                 }
5178:FreeRTOS/tasks.c ****                 else
5179:FreeRTOS/tasks.c ****                 {
5180:FreeRTOS/tasks.c ****                     /* The delayed and ready lists cannot be accessed, so hold
5181:FreeRTOS/tasks.c ****                      * this task pending until the scheduler is resumed. */
5182:FreeRTOS/tasks.c ****                     listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
5183:FreeRTOS/tasks.c ****                 }
5184:FreeRTOS/tasks.c **** 
5185:FreeRTOS/tasks.c ****                 if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
5186:FreeRTOS/tasks.c ****                 {
5187:FreeRTOS/tasks.c ****                     /* The notified task has a priority above the currently
5188:FreeRTOS/tasks.c ****                      * executing task so a yield is required. */
5189:FreeRTOS/tasks.c ****                     if( pxHigherPriorityTaskWoken != NULL )
5190:FreeRTOS/tasks.c ****                     {
5191:FreeRTOS/tasks.c ****                         *pxHigherPriorityTaskWoken = pdTRUE;
5192:FreeRTOS/tasks.c ****                     }
5193:FreeRTOS/tasks.c **** 
5194:FreeRTOS/tasks.c ****                     /* Mark that a yield is pending in case the user is not
5195:FreeRTOS/tasks.c ****                      * using the "xHigherPriorityTaskWoken" parameter in an ISR
5196:FreeRTOS/tasks.c ****                      * safe FreeRTOS function. */
5197:FreeRTOS/tasks.c ****                     xYieldPending = pdTRUE;
5198:FreeRTOS/tasks.c ****                 }
5199:FreeRTOS/tasks.c ****                 else
5200:FreeRTOS/tasks.c ****                 {
5201:FreeRTOS/tasks.c ****                     mtCOVERAGE_TEST_MARKER();
5202:FreeRTOS/tasks.c ****                 }
5203:FreeRTOS/tasks.c ****             }
5204:FreeRTOS/tasks.c ****         }
5205:FreeRTOS/tasks.c ****         portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
5206:FreeRTOS/tasks.c ****     }
ARM GAS  /tmp/ccrgBt0i.s 			page 109


5207:FreeRTOS/tasks.c **** 
5208:FreeRTOS/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
5209:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
5210:FreeRTOS/tasks.c **** 
5211:FreeRTOS/tasks.c **** #if ( configUSE_TASK_NOTIFICATIONS == 1 )
5212:FreeRTOS/tasks.c **** 
5213:FreeRTOS/tasks.c ****     BaseType_t xTaskGenericNotifyStateClear( TaskHandle_t xTask,
5214:FreeRTOS/tasks.c ****                                              UBaseType_t uxIndexToClear )
5215:FreeRTOS/tasks.c ****     {
5216:FreeRTOS/tasks.c ****         TCB_t * pxTCB;
5217:FreeRTOS/tasks.c ****         BaseType_t xReturn;
5218:FreeRTOS/tasks.c **** 
5219:FreeRTOS/tasks.c ****         configASSERT( uxIndexToClear < configTASK_NOTIFICATION_ARRAY_ENTRIES );
5220:FreeRTOS/tasks.c **** 
5221:FreeRTOS/tasks.c ****         /* If null is passed in here then it is the calling task that is having
5222:FreeRTOS/tasks.c ****          * its notification state cleared. */
5223:FreeRTOS/tasks.c ****         pxTCB = prvGetTCBFromHandle( xTask );
5224:FreeRTOS/tasks.c **** 
5225:FreeRTOS/tasks.c ****         taskENTER_CRITICAL();
5226:FreeRTOS/tasks.c ****         {
5227:FreeRTOS/tasks.c ****             if( pxTCB->ucNotifyState[ uxIndexToClear ] == taskNOTIFICATION_RECEIVED )
5228:FreeRTOS/tasks.c ****             {
5229:FreeRTOS/tasks.c ****                 pxTCB->ucNotifyState[ uxIndexToClear ] = taskNOT_WAITING_NOTIFICATION;
5230:FreeRTOS/tasks.c ****                 xReturn = pdPASS;
5231:FreeRTOS/tasks.c ****             }
5232:FreeRTOS/tasks.c ****             else
5233:FreeRTOS/tasks.c ****             {
5234:FreeRTOS/tasks.c ****                 xReturn = pdFAIL;
5235:FreeRTOS/tasks.c ****             }
5236:FreeRTOS/tasks.c ****         }
5237:FreeRTOS/tasks.c ****         taskEXIT_CRITICAL();
5238:FreeRTOS/tasks.c **** 
5239:FreeRTOS/tasks.c ****         return xReturn;
5240:FreeRTOS/tasks.c ****     }
5241:FreeRTOS/tasks.c **** 
5242:FreeRTOS/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
5243:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
5244:FreeRTOS/tasks.c **** 
5245:FreeRTOS/tasks.c **** #if ( configUSE_TASK_NOTIFICATIONS == 1 )
5246:FreeRTOS/tasks.c **** 
5247:FreeRTOS/tasks.c ****     uint32_t ulTaskGenericNotifyValueClear( TaskHandle_t xTask,
5248:FreeRTOS/tasks.c ****                                             UBaseType_t uxIndexToClear,
5249:FreeRTOS/tasks.c ****                                             uint32_t ulBitsToClear )
5250:FreeRTOS/tasks.c ****     {
5251:FreeRTOS/tasks.c ****         TCB_t * pxTCB;
5252:FreeRTOS/tasks.c ****         uint32_t ulReturn;
5253:FreeRTOS/tasks.c **** 
5254:FreeRTOS/tasks.c ****         /* If null is passed in here then it is the calling task that is having
5255:FreeRTOS/tasks.c ****          * its notification state cleared. */
5256:FreeRTOS/tasks.c ****         pxTCB = prvGetTCBFromHandle( xTask );
5257:FreeRTOS/tasks.c **** 
5258:FreeRTOS/tasks.c ****         taskENTER_CRITICAL();
5259:FreeRTOS/tasks.c ****         {
5260:FreeRTOS/tasks.c ****             /* Return the notification as it was before the bits were cleared,
5261:FreeRTOS/tasks.c ****              * then clear the bit mask. */
5262:FreeRTOS/tasks.c ****             ulReturn = pxTCB->ulNotifiedValue[ uxIndexToClear ];
5263:FreeRTOS/tasks.c ****             pxTCB->ulNotifiedValue[ uxIndexToClear ] &= ~ulBitsToClear;
ARM GAS  /tmp/ccrgBt0i.s 			page 110


5264:FreeRTOS/tasks.c ****         }
5265:FreeRTOS/tasks.c ****         taskEXIT_CRITICAL();
5266:FreeRTOS/tasks.c **** 
5267:FreeRTOS/tasks.c ****         return ulReturn;
5268:FreeRTOS/tasks.c ****     }
5269:FreeRTOS/tasks.c **** 
5270:FreeRTOS/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
5271:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
5272:FreeRTOS/tasks.c **** 
5273:FreeRTOS/tasks.c **** #if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( INCLUDE_xTaskGetIdleTaskHandle == 1 ) )
5274:FreeRTOS/tasks.c **** 
5275:FreeRTOS/tasks.c ****     configRUN_TIME_COUNTER_TYPE ulTaskGetIdleRunTimeCounter( void )
5276:FreeRTOS/tasks.c ****     {
5277:FreeRTOS/tasks.c ****         return xIdleTaskHandle->ulRunTimeCounter;
5278:FreeRTOS/tasks.c ****     }
5279:FreeRTOS/tasks.c **** 
5280:FreeRTOS/tasks.c **** #endif
5281:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
5282:FreeRTOS/tasks.c **** 
5283:FreeRTOS/tasks.c **** #if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( INCLUDE_xTaskGetIdleTaskHandle == 1 ) )
5284:FreeRTOS/tasks.c **** 
5285:FreeRTOS/tasks.c ****     configRUN_TIME_COUNTER_TYPE ulTaskGetIdleRunTimePercent( void )
5286:FreeRTOS/tasks.c ****     {
5287:FreeRTOS/tasks.c ****         configRUN_TIME_COUNTER_TYPE ulTotalTime, ulReturn;
5288:FreeRTOS/tasks.c **** 
5289:FreeRTOS/tasks.c ****         ulTotalTime = portGET_RUN_TIME_COUNTER_VALUE();
5290:FreeRTOS/tasks.c **** 
5291:FreeRTOS/tasks.c ****         /* For percentage calculations. */
5292:FreeRTOS/tasks.c ****         ulTotalTime /= ( configRUN_TIME_COUNTER_TYPE ) 100;
5293:FreeRTOS/tasks.c **** 
5294:FreeRTOS/tasks.c ****         /* Avoid divide by zero errors. */
5295:FreeRTOS/tasks.c ****         if( ulTotalTime > ( configRUN_TIME_COUNTER_TYPE ) 0 )
5296:FreeRTOS/tasks.c ****         {
5297:FreeRTOS/tasks.c ****             ulReturn = xIdleTaskHandle->ulRunTimeCounter / ulTotalTime;
5298:FreeRTOS/tasks.c ****         }
5299:FreeRTOS/tasks.c ****         else
5300:FreeRTOS/tasks.c ****         {
5301:FreeRTOS/tasks.c ****             ulReturn = 0;
5302:FreeRTOS/tasks.c ****         }
5303:FreeRTOS/tasks.c **** 
5304:FreeRTOS/tasks.c ****         return ulReturn;
5305:FreeRTOS/tasks.c ****     }
5306:FreeRTOS/tasks.c **** 
5307:FreeRTOS/tasks.c **** #endif /* if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( INCLUDE_xTaskGetIdleTaskHandle == 1 ) ) 
5308:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
5309:FreeRTOS/tasks.c **** 
5310:FreeRTOS/tasks.c **** static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
5311:FreeRTOS/tasks.c ****                                             const BaseType_t xCanBlockIndefinitely )
5312:FreeRTOS/tasks.c **** {
 689              		.loc 1 5312 0
 690              		.cfi_startproc
 691              		@ args = 0, pretend = 0, frame = 0
 692              		@ frame_needed = 0, uses_anonymous_args = 0
 693              	.LVL57:
 694 0000 70B5     		push	{r4, r5, r6, lr}
 695              	.LCFI7:
 696              		.cfi_def_cfa_offset 16
ARM GAS  /tmp/ccrgBt0i.s 			page 111


 697              		.cfi_offset 4, -16
 698              		.cfi_offset 5, -12
 699              		.cfi_offset 6, -8
 700              		.cfi_offset 14, -4
 701 0002 0446     		mov	r4, r0
 702 0004 0E46     		mov	r6, r1
5313:FreeRTOS/tasks.c ****     TickType_t xTimeToWake;
5314:FreeRTOS/tasks.c ****     const TickType_t xConstTickCount = xTickCount;
 703              		.loc 1 5314 0
 704 0006 244B     		ldr	r3, .L70
 705 0008 1D68     		ldr	r5, [r3]
 706              	.LVL58:
5315:FreeRTOS/tasks.c **** 
5316:FreeRTOS/tasks.c ****     #if ( INCLUDE_xTaskAbortDelay == 1 )
5317:FreeRTOS/tasks.c ****         {
5318:FreeRTOS/tasks.c ****             /* About to enter a delayed list, so ensure the ucDelayAborted flag is
5319:FreeRTOS/tasks.c ****              * reset to pdFALSE so it can be detected as having been set to pdTRUE
5320:FreeRTOS/tasks.c ****              * when the task leaves the Blocked state. */
5321:FreeRTOS/tasks.c ****             pxCurrentTCB->ucDelayAborted = pdFALSE;
5322:FreeRTOS/tasks.c ****         }
5323:FreeRTOS/tasks.c ****     #endif
5324:FreeRTOS/tasks.c **** 
5325:FreeRTOS/tasks.c ****     /* Remove the task from the ready list before adding it to the blocked list
5326:FreeRTOS/tasks.c ****      * as the same list item is used for both lists. */
5327:FreeRTOS/tasks.c ****     if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 707              		.loc 1 5327 0
 708 000a 244B     		ldr	r3, .L70+4
 709 000c 1868     		ldr	r0, [r3]
 710              	.LVL59:
 711 000e 0430     		adds	r0, r0, #4
 712 0010 FFF7FEFF 		bl	uxListRemove
 713              	.LVL60:
 714 0014 50B9     		cbnz	r0, .L63
5328:FreeRTOS/tasks.c ****     {
5329:FreeRTOS/tasks.c ****         /* The current task must be in a ready list, so there is no need to
5330:FreeRTOS/tasks.c ****          * check, and the port reset macro can be called directly. */
5331:FreeRTOS/tasks.c ****         portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority ); /*lint !e931 pxCu
 715              		.loc 1 5331 0
 716 0016 214B     		ldr	r3, .L70+4
 717 0018 1B68     		ldr	r3, [r3]
 718 001a DA6A     		ldr	r2, [r3, #44]
 719 001c 0123     		movs	r3, #1
 720 001e 03FA02F2 		lsl	r2, r3, r2
 721 0022 1F49     		ldr	r1, .L70+8
 722 0024 0B68     		ldr	r3, [r1]
 723 0026 23EA0203 		bic	r3, r3, r2
 724 002a 0B60     		str	r3, [r1]
 725              	.L63:
5332:FreeRTOS/tasks.c ****     }
5333:FreeRTOS/tasks.c ****     else
5334:FreeRTOS/tasks.c ****     {
5335:FreeRTOS/tasks.c ****         mtCOVERAGE_TEST_MARKER();
5336:FreeRTOS/tasks.c ****     }
5337:FreeRTOS/tasks.c **** 
5338:FreeRTOS/tasks.c ****     #if ( INCLUDE_vTaskSuspend == 1 )
5339:FreeRTOS/tasks.c ****         {
5340:FreeRTOS/tasks.c ****             if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
ARM GAS  /tmp/ccrgBt0i.s 			page 112


 726              		.loc 1 5340 0
 727 002c B4F1FF3F 		cmp	r4, #-1
 728 0030 13D0     		beq	.L68
 729              	.L64:
5341:FreeRTOS/tasks.c ****             {
5342:FreeRTOS/tasks.c ****                 /* Add the task to the suspended task list instead of a delayed task
5343:FreeRTOS/tasks.c ****                  * list to ensure it is not woken by a timing event.  It will block
5344:FreeRTOS/tasks.c ****                  * indefinitely. */
5345:FreeRTOS/tasks.c ****                 listINSERT_END( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
5346:FreeRTOS/tasks.c ****             }
5347:FreeRTOS/tasks.c ****             else
5348:FreeRTOS/tasks.c ****             {
5349:FreeRTOS/tasks.c ****                 /* Calculate the time at which the task should be woken if the event
5350:FreeRTOS/tasks.c ****                  * does not occur.  This may overflow but this doesn't matter, the
5351:FreeRTOS/tasks.c ****                  * kernel will manage it correctly. */
5352:FreeRTOS/tasks.c ****                 xTimeToWake = xConstTickCount + xTicksToWait;
 730              		.loc 1 5352 0
 731 0032 2C44     		add	r4, r4, r5
 732              	.LVL61:
5353:FreeRTOS/tasks.c **** 
5354:FreeRTOS/tasks.c ****                 /* The list item will be inserted in wake time order. */
5355:FreeRTOS/tasks.c ****                 listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 733              		.loc 1 5355 0
 734 0034 194B     		ldr	r3, .L70+4
 735 0036 1B68     		ldr	r3, [r3]
 736 0038 5C60     		str	r4, [r3, #4]
5356:FreeRTOS/tasks.c **** 
5357:FreeRTOS/tasks.c ****                 if( xTimeToWake < xConstTickCount )
 737              		.loc 1 5357 0
 738 003a A542     		cmp	r5, r4
 739 003c 24D8     		bhi	.L69
5358:FreeRTOS/tasks.c ****                 {
5359:FreeRTOS/tasks.c ****                     /* Wake time has overflowed.  Place this item in the overflow
5360:FreeRTOS/tasks.c ****                      * list. */
5361:FreeRTOS/tasks.c ****                     vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
5362:FreeRTOS/tasks.c ****                 }
5363:FreeRTOS/tasks.c ****                 else
5364:FreeRTOS/tasks.c ****                 {
5365:FreeRTOS/tasks.c ****                     /* The wake time has not overflowed, so the current block list
5366:FreeRTOS/tasks.c ****                      * is used. */
5367:FreeRTOS/tasks.c ****                     vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 740              		.loc 1 5367 0
 741 003e 194B     		ldr	r3, .L70+12
 742 0040 1868     		ldr	r0, [r3]
 743 0042 164B     		ldr	r3, .L70+4
 744 0044 1968     		ldr	r1, [r3]
 745 0046 0431     		adds	r1, r1, #4
 746 0048 FFF7FEFF 		bl	vListInsert
 747              	.LVL62:
5368:FreeRTOS/tasks.c **** 
5369:FreeRTOS/tasks.c ****                     /* If the task entering the blocked state was placed at the
5370:FreeRTOS/tasks.c ****                      * head of the list of blocked tasks then xNextTaskUnblockTime
5371:FreeRTOS/tasks.c ****                      * needs to be updated too. */
5372:FreeRTOS/tasks.c ****                     if( xTimeToWake < xNextTaskUnblockTime )
 748              		.loc 1 5372 0
 749 004c 164B     		ldr	r3, .L70+16
 750 004e 1B68     		ldr	r3, [r3]
ARM GAS  /tmp/ccrgBt0i.s 			page 113


 751 0050 A342     		cmp	r3, r4
 752 0052 20D9     		bls	.L62
5373:FreeRTOS/tasks.c ****                     {
5374:FreeRTOS/tasks.c ****                         xNextTaskUnblockTime = xTimeToWake;
 753              		.loc 1 5374 0
 754 0054 144B     		ldr	r3, .L70+16
 755 0056 1C60     		str	r4, [r3]
5375:FreeRTOS/tasks.c ****                     }
5376:FreeRTOS/tasks.c ****                     else
5377:FreeRTOS/tasks.c ****                     {
5378:FreeRTOS/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
5379:FreeRTOS/tasks.c ****                     }
5380:FreeRTOS/tasks.c ****                 }
5381:FreeRTOS/tasks.c ****             }
5382:FreeRTOS/tasks.c ****         }
5383:FreeRTOS/tasks.c ****     #else /* INCLUDE_vTaskSuspend */
5384:FreeRTOS/tasks.c ****         {
5385:FreeRTOS/tasks.c ****             /* Calculate the time at which the task should be woken if the event
5386:FreeRTOS/tasks.c ****              * does not occur.  This may overflow but this doesn't matter, the kernel
5387:FreeRTOS/tasks.c ****              * will manage it correctly. */
5388:FreeRTOS/tasks.c ****             xTimeToWake = xConstTickCount + xTicksToWait;
5389:FreeRTOS/tasks.c **** 
5390:FreeRTOS/tasks.c ****             /* The list item will be inserted in wake time order. */
5391:FreeRTOS/tasks.c ****             listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
5392:FreeRTOS/tasks.c **** 
5393:FreeRTOS/tasks.c ****             if( xTimeToWake < xConstTickCount )
5394:FreeRTOS/tasks.c ****             {
5395:FreeRTOS/tasks.c ****                 /* Wake time has overflowed.  Place this item in the overflow list. */
5396:FreeRTOS/tasks.c ****                 vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
5397:FreeRTOS/tasks.c ****             }
5398:FreeRTOS/tasks.c ****             else
5399:FreeRTOS/tasks.c ****             {
5400:FreeRTOS/tasks.c ****                 /* The wake time has not overflowed, so the current block list is used. */
5401:FreeRTOS/tasks.c ****                 vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
5402:FreeRTOS/tasks.c **** 
5403:FreeRTOS/tasks.c ****                 /* If the task entering the blocked state was placed at the head of the
5404:FreeRTOS/tasks.c ****                  * list of blocked tasks then xNextTaskUnblockTime needs to be updated
5405:FreeRTOS/tasks.c ****                  * too. */
5406:FreeRTOS/tasks.c ****                 if( xTimeToWake < xNextTaskUnblockTime )
5407:FreeRTOS/tasks.c ****                 {
5408:FreeRTOS/tasks.c ****                     xNextTaskUnblockTime = xTimeToWake;
5409:FreeRTOS/tasks.c ****                 }
5410:FreeRTOS/tasks.c ****                 else
5411:FreeRTOS/tasks.c ****                 {
5412:FreeRTOS/tasks.c ****                     mtCOVERAGE_TEST_MARKER();
5413:FreeRTOS/tasks.c ****                 }
5414:FreeRTOS/tasks.c ****             }
5415:FreeRTOS/tasks.c **** 
5416:FreeRTOS/tasks.c ****             /* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
5417:FreeRTOS/tasks.c ****             ( void ) xCanBlockIndefinitely;
5418:FreeRTOS/tasks.c ****         }
5419:FreeRTOS/tasks.c ****     #endif /* INCLUDE_vTaskSuspend */
5420:FreeRTOS/tasks.c **** }
 756              		.loc 1 5420 0
 757 0058 1DE0     		b	.L62
 758              	.LVL63:
 759              	.L68:
ARM GAS  /tmp/ccrgBt0i.s 			page 114


5340:FreeRTOS/tasks.c ****             {
 760              		.loc 1 5340 0 discriminator 1
 761 005a 002E     		cmp	r6, #0
 762 005c E9D0     		beq	.L64
 763              	.LBB159:
5345:FreeRTOS/tasks.c ****             }
 764              		.loc 1 5345 0
 765 005e 134A     		ldr	r2, .L70+20
 766 0060 5168     		ldr	r1, [r2, #4]
 767              	.LVL64:
 768 0062 0E4B     		ldr	r3, .L70+4
 769 0064 1868     		ldr	r0, [r3]
 770 0066 8160     		str	r1, [r0, #8]
 771 0068 1868     		ldr	r0, [r3]
 772 006a 8C68     		ldr	r4, [r1, #8]
 773              	.LVL65:
 774 006c C460     		str	r4, [r0, #12]
 775 006e 1868     		ldr	r0, [r3]
 776 0070 8C68     		ldr	r4, [r1, #8]
 777 0072 0430     		adds	r0, r0, #4
 778 0074 6060     		str	r0, [r4, #4]
 779 0076 1868     		ldr	r0, [r3]
 780 0078 0430     		adds	r0, r0, #4
 781 007a 8860     		str	r0, [r1, #8]
 782 007c 1B68     		ldr	r3, [r3]
 783 007e 5A61     		str	r2, [r3, #20]
 784 0080 1368     		ldr	r3, [r2]
 785 0082 0133     		adds	r3, r3, #1
 786 0084 1360     		str	r3, [r2]
 787              	.LBE159:
 788 0086 06E0     		b	.L62
 789              	.LVL66:
 790              	.L69:
5361:FreeRTOS/tasks.c ****                 }
 791              		.loc 1 5361 0
 792 0088 094B     		ldr	r3, .L70+24
 793 008a 1868     		ldr	r0, [r3]
 794 008c 034B     		ldr	r3, .L70+4
 795 008e 1968     		ldr	r1, [r3]
 796 0090 0431     		adds	r1, r1, #4
 797 0092 FFF7FEFF 		bl	vListInsert
 798              	.LVL67:
 799              	.L62:
 800              		.loc 1 5420 0
 801 0096 70BD     		pop	{r4, r5, r6, pc}
 802              	.LVL68:
 803              	.L71:
 804              		.align	2
 805              	.L70:
 806 0098 00000000 		.word	.LANCHOR15
 807 009c 00000000 		.word	.LANCHOR10
 808 00a0 00000000 		.word	.LANCHOR13
 809 00a4 00000000 		.word	.LANCHOR2
 810 00a8 00000000 		.word	.LANCHOR3
 811 00ac 00000000 		.word	.LANCHOR0
 812 00b0 00000000 		.word	.LANCHOR8
 813              		.cfi_endproc
ARM GAS  /tmp/ccrgBt0i.s 			page 115


 814              	.LFE57:
 816              		.section	.text.xTaskCreate,"ax",%progbits
 817              		.align	1
 818              		.global	xTaskCreate
 819              		.syntax unified
 820              		.thumb
 821              		.thumb_func
 822              		.fpu softvfp
 824              	xTaskCreate:
 825              	.LFB5:
 734:FreeRTOS/tasks.c ****         TCB_t * pxNewTCB;
 826              		.loc 1 734 0
 827              		.cfi_startproc
 828              		@ args = 8, pretend = 0, frame = 0
 829              		@ frame_needed = 0, uses_anonymous_args = 0
 830              	.LVL69:
 831 0000 2DE9F043 		push	{r4, r5, r6, r7, r8, r9, lr}
 832              	.LCFI8:
 833              		.cfi_def_cfa_offset 28
 834              		.cfi_offset 4, -28
 835              		.cfi_offset 5, -24
 836              		.cfi_offset 6, -20
 837              		.cfi_offset 7, -16
 838              		.cfi_offset 8, -12
 839              		.cfi_offset 9, -8
 840              		.cfi_offset 14, -4
 841 0004 85B0     		sub	sp, sp, #20
 842              	.LCFI9:
 843              		.cfi_def_cfa_offset 48
 844 0006 0746     		mov	r7, r0
 845 0008 8846     		mov	r8, r1
 846 000a 1546     		mov	r5, r2
 847 000c 9946     		mov	r9, r3
 848              	.LBB160:
 768:FreeRTOS/tasks.c **** 
 849              		.loc 1 768 0
 850 000e 9000     		lsls	r0, r2, #2
 851              	.LVL70:
 852 0010 FFF7FEFF 		bl	pvPortMalloc
 853              	.LVL71:
 770:FreeRTOS/tasks.c ****                 {
 854              		.loc 1 770 0
 855 0014 F8B1     		cbz	r0, .L76
 856 0016 0646     		mov	r6, r0
 773:FreeRTOS/tasks.c **** 
 857              		.loc 1 773 0
 858 0018 5420     		movs	r0, #84
 859              	.LVL72:
 860 001a FFF7FEFF 		bl	pvPortMalloc
 861              	.LVL73:
 775:FreeRTOS/tasks.c ****                     {
 862              		.loc 1 775 0
 863 001e 0446     		mov	r4, r0
 864 0020 A8B1     		cbz	r0, .L74
 778:FreeRTOS/tasks.c ****                     }
 865              		.loc 1 778 0
 866 0022 0663     		str	r6, [r0, #48]
ARM GAS  /tmp/ccrgBt0i.s 			page 116


 867              	.LVL74:
 868              	.L75:
 869              	.LBE160:
 794:FreeRTOS/tasks.c ****         {
 870              		.loc 1 794 0
 871 0024 D4B1     		cbz	r4, .L77
 804:FreeRTOS/tasks.c ****             prvAddNewTaskToReadyList( pxNewTCB );
 872              		.loc 1 804 0
 873 0026 0023     		movs	r3, #0
 874 0028 0393     		str	r3, [sp, #12]
 875 002a 0294     		str	r4, [sp, #8]
 876 002c 0D9B     		ldr	r3, [sp, #52]
 877 002e 0193     		str	r3, [sp, #4]
 878 0030 0C9B     		ldr	r3, [sp, #48]
 879 0032 0093     		str	r3, [sp]
 880 0034 4B46     		mov	r3, r9
 881 0036 2A46     		mov	r2, r5
 882 0038 4146     		mov	r1, r8
 883 003a 3846     		mov	r0, r7
 884 003c FFF7FEFF 		bl	prvInitialiseNewTask
 885              	.LVL75:
 805:FreeRTOS/tasks.c ****             xReturn = pdPASS;
 886              		.loc 1 805 0
 887 0040 2046     		mov	r0, r4
 888 0042 FFF7FEFF 		bl	prvAddNewTaskToReadyList
 889              	.LVL76:
 806:FreeRTOS/tasks.c ****         }
 890              		.loc 1 806 0
 891 0046 0120     		movs	r0, #1
 892              	.LVL77:
 893              	.L72:
 814:FreeRTOS/tasks.c **** 
 894              		.loc 1 814 0
 895 0048 05B0     		add	sp, sp, #20
 896              	.LCFI10:
 897              		.cfi_remember_state
 898              		.cfi_def_cfa_offset 28
 899              		@ sp needed
 900 004a BDE8F083 		pop	{r4, r5, r6, r7, r8, r9, pc}
 901              	.LVL78:
 902              	.L74:
 903              	.LCFI11:
 904              		.cfi_restore_state
 905              	.LBB161:
 784:FreeRTOS/tasks.c ****                     }
 906              		.loc 1 784 0
 907 004e 3046     		mov	r0, r6
 908              	.LVL79:
 909 0050 FFF7FEFF 		bl	vPortFree
 910              	.LVL80:
 911 0054 E6E7     		b	.L75
 912              	.LVL81:
 913              	.L76:
 914              	.LBE161:
 810:FreeRTOS/tasks.c ****         }
 915              		.loc 1 810 0
 916 0056 4FF0FF30 		mov	r0, #-1
ARM GAS  /tmp/ccrgBt0i.s 			page 117


 917              	.LVL82:
 918 005a F5E7     		b	.L72
 919              	.LVL83:
 920              	.L77:
 921 005c 4FF0FF30 		mov	r0, #-1
 922              	.LVL84:
 813:FreeRTOS/tasks.c ****     }
 923              		.loc 1 813 0
 924 0060 F2E7     		b	.L72
 925              		.cfi_endproc
 926              	.LFE5:
 928              		.section	.text.vTaskDelete,"ax",%progbits
 929              		.align	1
 930              		.global	vTaskDelete
 931              		.syntax unified
 932              		.thumb
 933              		.thumb_func
 934              		.fpu softvfp
 936              	vTaskDelete:
 937              	.LFB8:
1158:FreeRTOS/tasks.c ****         TCB_t * pxTCB;
 938              		.loc 1 1158 0
 939              		.cfi_startproc
 940              		@ args = 0, pretend = 0, frame = 0
 941              		@ frame_needed = 0, uses_anonymous_args = 0
 942              	.LVL85:
 943 0000 38B5     		push	{r3, r4, r5, lr}
 944              	.LCFI12:
 945              		.cfi_def_cfa_offset 16
 946              		.cfi_offset 3, -16
 947              		.cfi_offset 4, -12
 948              		.cfi_offset 5, -8
 949              		.cfi_offset 14, -4
 950 0002 0446     		mov	r4, r0
1161:FreeRTOS/tasks.c ****         {
 951              		.loc 1 1161 0
 952 0004 FFF7FEFF 		bl	vPortEnterCritical
 953              	.LVL86:
1165:FreeRTOS/tasks.c **** 
 954              		.loc 1 1165 0
 955 0008 002C     		cmp	r4, #0
 956 000a 38D0     		beq	.L90
 957              	.LVL87:
 958              	.L80:
1168:FreeRTOS/tasks.c ****             {
 959              		.loc 1 1168 0 discriminator 4
 960 000c 251D     		adds	r5, r4, #4
 961 000e 2846     		mov	r0, r5
 962 0010 FFF7FEFF 		bl	uxListRemove
 963              	.LVL88:
 964 0014 70B9     		cbnz	r0, .L81
1170:FreeRTOS/tasks.c ****             }
 965              		.loc 1 1170 0
 966 0016 E26A     		ldr	r2, [r4, #44]
 967 0018 02EB8201 		add	r1, r2, r2, lsl #2
 968 001c 8B00     		lsls	r3, r1, #2
 969 001e 2849     		ldr	r1, .L93
ARM GAS  /tmp/ccrgBt0i.s 			page 118


 970 0020 CB58     		ldr	r3, [r1, r3]
 971 0022 3BB9     		cbnz	r3, .L81
1170:FreeRTOS/tasks.c ****             }
 972              		.loc 1 1170 0 is_stmt 0 discriminator 1
 973 0024 0123     		movs	r3, #1
 974 0026 03FA02F2 		lsl	r2, r3, r2
 975 002a 2649     		ldr	r1, .L93+4
 976 002c 0B68     		ldr	r3, [r1]
 977 002e 23EA0203 		bic	r3, r3, r2
 978 0032 0B60     		str	r3, [r1]
 979              	.L81:
1178:FreeRTOS/tasks.c ****             {
 980              		.loc 1 1178 0 is_stmt 1
 981 0034 A36A     		ldr	r3, [r4, #40]
 982 0036 1BB1     		cbz	r3, .L82
1180:FreeRTOS/tasks.c ****             }
 983              		.loc 1 1180 0
 984 0038 04F11800 		add	r0, r4, #24
 985 003c FFF7FEFF 		bl	uxListRemove
 986              	.LVL89:
 987              	.L82:
1191:FreeRTOS/tasks.c **** 
 988              		.loc 1 1191 0
 989 0040 214A     		ldr	r2, .L93+8
 990 0042 1368     		ldr	r3, [r2]
 991 0044 0133     		adds	r3, r3, #1
 992 0046 1360     		str	r3, [r2]
1193:FreeRTOS/tasks.c ****             {
 993              		.loc 1 1193 0
 994 0048 204B     		ldr	r3, .L93+12
 995 004a 1B68     		ldr	r3, [r3]
 996 004c A342     		cmp	r3, r4
 997 004e 19D0     		beq	.L91
1220:FreeRTOS/tasks.c ****                 traceTASK_DELETE( pxTCB );
 998              		.loc 1 1220 0
 999 0050 1F4A     		ldr	r2, .L93+16
 1000 0052 1368     		ldr	r3, [r2]
 1001 0054 013B     		subs	r3, r3, #1
 1002 0056 1360     		str	r3, [r2]
1225:FreeRTOS/tasks.c ****             }
 1003              		.loc 1 1225 0
 1004 0058 FFF7FEFF 		bl	prvResetNextTaskUnblockTime
 1005              	.LVL90:
 1006              	.L84:
1228:FreeRTOS/tasks.c **** 
 1007              		.loc 1 1228 0
 1008 005c FFF7FEFF 		bl	vPortExitCritical
 1009              	.LVL91:
1233:FreeRTOS/tasks.c ****         {
 1010              		.loc 1 1233 0
 1011 0060 1A4B     		ldr	r3, .L93+12
 1012 0062 1B68     		ldr	r3, [r3]
 1013 0064 A342     		cmp	r3, r4
 1014 0066 02D0     		beq	.L85
1235:FreeRTOS/tasks.c ****         }
 1015              		.loc 1 1235 0
 1016 0068 2046     		mov	r0, r4
ARM GAS  /tmp/ccrgBt0i.s 			page 119


 1017 006a FFF7FEFF 		bl	prvDeleteTCB
 1018              	.LVL92:
 1019              	.L85:
1240:FreeRTOS/tasks.c ****         {
 1020              		.loc 1 1240 0
 1021 006e 194B     		ldr	r3, .L93+20
 1022 0070 1B68     		ldr	r3, [r3]
 1023 0072 1BB1     		cbz	r3, .L79
1242:FreeRTOS/tasks.c ****             {
 1024              		.loc 1 1242 0
 1025 0074 154B     		ldr	r3, .L93+12
 1026 0076 1B68     		ldr	r3, [r3]
 1027 0078 A342     		cmp	r3, r4
 1028 007a 0CD0     		beq	.L92
 1029              	.L79:
1252:FreeRTOS/tasks.c **** 
 1030              		.loc 1 1252 0
 1031 007c 38BD     		pop	{r3, r4, r5, pc}
 1032              	.LVL93:
 1033              	.L90:
1165:FreeRTOS/tasks.c **** 
 1034              		.loc 1 1165 0 discriminator 1
 1035 007e 134B     		ldr	r3, .L93+12
 1036 0080 1C68     		ldr	r4, [r3]
 1037              	.LVL94:
 1038 0082 C3E7     		b	.L80
 1039              	.LVL95:
 1040              	.L91:
1200:FreeRTOS/tasks.c **** 
 1041              		.loc 1 1200 0
 1042 0084 2946     		mov	r1, r5
 1043 0086 1448     		ldr	r0, .L93+24
 1044 0088 FFF7FEFF 		bl	vListInsertEnd
 1045              	.LVL96:
1205:FreeRTOS/tasks.c **** 
 1046              		.loc 1 1205 0
 1047 008c 134A     		ldr	r2, .L93+28
 1048 008e 1368     		ldr	r3, [r2]
 1049 0090 0133     		adds	r3, r3, #1
 1050 0092 1360     		str	r3, [r2]
 1051 0094 E2E7     		b	.L84
 1052              	.L92:
1244:FreeRTOS/tasks.c ****                 portYIELD_WITHIN_API();
 1053              		.loc 1 1244 0
 1054 0096 124B     		ldr	r3, .L93+32
 1055 0098 1B68     		ldr	r3, [r3]
 1056 009a 43B1     		cbz	r3, .L87
 1057              	.LBB162:
 1058              	.LBB163:
 1059              		.loc 2 200 0
 1060              		.syntax unified
 1061              	@ 200 "FreeRTOS/ARM_CM3/portmacro.h" 1
 1062 009c 4FF05003 			mov r3, #80												
 1063 00a0 83F31188 		msr basepri, r3											
 1064 00a4 BFF36F8F 		isb														
 1065 00a8 BFF34F8F 		dsb														
 1066              	
ARM GAS  /tmp/ccrgBt0i.s 			page 120


 1067              	@ 0 "" 2
 1068              	.LVL97:
 1069              		.thumb
 1070              		.syntax unified
 1071              	.L88:
 1072 00ac FEE7     		b	.L88
 1073              	.L87:
 1074              	.LBE163:
 1075              	.LBE162:
1245:FreeRTOS/tasks.c ****             }
 1076              		.loc 1 1245 0
 1077 00ae 0D4B     		ldr	r3, .L93+36
 1078 00b0 4FF08052 		mov	r2, #268435456
 1079 00b4 1A60     		str	r2, [r3]
 1080              		.syntax unified
 1081              	@ 1245 "FreeRTOS/tasks.c" 1
 1082 00b6 BFF34F8F 		dsb
 1083              	@ 0 "" 2
 1084              	@ 1245 "FreeRTOS/tasks.c" 1
 1085 00ba BFF36F8F 		isb
 1086              	@ 0 "" 2
1252:FreeRTOS/tasks.c **** 
 1087              		.loc 1 1252 0
 1088              		.thumb
 1089              		.syntax unified
 1090 00be DDE7     		b	.L79
 1091              	.L94:
 1092              		.align	2
 1093              	.L93:
 1094 00c0 00000000 		.word	.LANCHOR4
 1095 00c4 00000000 		.word	.LANCHOR13
 1096 00c8 00000000 		.word	.LANCHOR12
 1097 00cc 00000000 		.word	.LANCHOR10
 1098 00d0 00000000 		.word	.LANCHOR9
 1099 00d4 00000000 		.word	.LANCHOR11
 1100 00d8 00000000 		.word	.LANCHOR7
 1101 00dc 00000000 		.word	.LANCHOR14
 1102 00e0 00000000 		.word	.LANCHOR16
 1103 00e4 04ED00E0 		.word	-536810236
 1104              		.cfi_endproc
 1105              	.LFE8:
 1107              		.section	.text.uxTaskPriorityGet,"ax",%progbits
 1108              		.align	1
 1109              		.global	uxTaskPriorityGet
 1110              		.syntax unified
 1111              		.thumb
 1112              		.thumb_func
 1113              		.fpu softvfp
 1115              	uxTaskPriorityGet:
 1116              	.LFB11:
1489:FreeRTOS/tasks.c ****         TCB_t const * pxTCB;
 1117              		.loc 1 1489 0
 1118              		.cfi_startproc
 1119              		@ args = 0, pretend = 0, frame = 0
 1120              		@ frame_needed = 0, uses_anonymous_args = 0
 1121              	.LVL98:
 1122 0000 10B5     		push	{r4, lr}
ARM GAS  /tmp/ccrgBt0i.s 			page 121


 1123              	.LCFI13:
 1124              		.cfi_def_cfa_offset 8
 1125              		.cfi_offset 4, -8
 1126              		.cfi_offset 14, -4
 1127 0002 0446     		mov	r4, r0
1493:FreeRTOS/tasks.c ****         {
 1128              		.loc 1 1493 0
 1129 0004 FFF7FEFF 		bl	vPortEnterCritical
 1130              	.LVL99:
1497:FreeRTOS/tasks.c ****             uxReturn = pxTCB->uxPriority;
 1131              		.loc 1 1497 0
 1132 0008 24B1     		cbz	r4, .L98
 1133              	.LVL100:
 1134              	.L96:
1498:FreeRTOS/tasks.c ****         }
 1135              		.loc 1 1498 0 discriminator 4
 1136 000a E46A     		ldr	r4, [r4, #44]
 1137              	.LVL101:
1500:FreeRTOS/tasks.c **** 
 1138              		.loc 1 1500 0 discriminator 4
 1139 000c FFF7FEFF 		bl	vPortExitCritical
 1140              	.LVL102:
1503:FreeRTOS/tasks.c **** 
 1141              		.loc 1 1503 0 discriminator 4
 1142 0010 2046     		mov	r0, r4
 1143 0012 10BD     		pop	{r4, pc}
 1144              	.LVL103:
 1145              	.L98:
1497:FreeRTOS/tasks.c ****             uxReturn = pxTCB->uxPriority;
 1146              		.loc 1 1497 0 discriminator 1
 1147 0014 014B     		ldr	r3, .L99
 1148 0016 1C68     		ldr	r4, [r3]
 1149              	.LVL104:
 1150 0018 F7E7     		b	.L96
 1151              	.L100:
 1152 001a 00BF     		.align	2
 1153              	.L99:
 1154 001c 00000000 		.word	.LANCHOR10
 1155              		.cfi_endproc
 1156              	.LFE11:
 1158              		.section	.text.uxTaskPriorityGetFromISR,"ax",%progbits
 1159              		.align	1
 1160              		.global	uxTaskPriorityGetFromISR
 1161              		.syntax unified
 1162              		.thumb
 1163              		.thumb_func
 1164              		.fpu softvfp
 1166              	uxTaskPriorityGetFromISR:
 1167              	.LFB12:
1511:FreeRTOS/tasks.c ****         TCB_t const * pxTCB;
 1168              		.loc 1 1511 0
 1169              		.cfi_startproc
 1170              		@ args = 0, pretend = 0, frame = 0
 1171              		@ frame_needed = 0, uses_anonymous_args = 0
 1172              	.LVL105:
 1173 0000 10B5     		push	{r4, lr}
 1174              	.LCFI14:
ARM GAS  /tmp/ccrgBt0i.s 			page 122


 1175              		.cfi_def_cfa_offset 8
 1176              		.cfi_offset 4, -8
 1177              		.cfi_offset 14, -4
 1178 0002 0446     		mov	r4, r0
1531:FreeRTOS/tasks.c **** 
 1179              		.loc 1 1531 0
 1180 0004 FFF7FEFF 		bl	vPortValidateInterruptPriority
 1181              	.LVL106:
 1182              	.LBB164:
 1183              	.LBB165:
 201:FreeRTOS/ARM_CM3/portmacro.h ****         (
 202:FreeRTOS/ARM_CM3/portmacro.h ****             "	mov %0, %1												\n"\
 203:FreeRTOS/ARM_CM3/portmacro.h ****             "	msr basepri, %0											\n"\
 204:FreeRTOS/ARM_CM3/portmacro.h ****             "	isb														\n"\
 205:FreeRTOS/ARM_CM3/portmacro.h ****             "	dsb														\n"\
 206:FreeRTOS/ARM_CM3/portmacro.h ****             : "=r" ( ulNewBASEPRI ) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "memory"
 207:FreeRTOS/ARM_CM3/portmacro.h ****         );
 208:FreeRTOS/ARM_CM3/portmacro.h ****     }
 209:FreeRTOS/ARM_CM3/portmacro.h **** 
 210:FreeRTOS/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 211:FreeRTOS/ARM_CM3/portmacro.h **** 
 212:FreeRTOS/ARM_CM3/portmacro.h ****     portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
 213:FreeRTOS/ARM_CM3/portmacro.h ****     {
 214:FreeRTOS/ARM_CM3/portmacro.h ****         uint32_t ulOriginalBASEPRI, ulNewBASEPRI;
 215:FreeRTOS/ARM_CM3/portmacro.h **** 
 216:FreeRTOS/ARM_CM3/portmacro.h ****         __asm volatile
 1184              		.loc 2 216 0
 1185              		.syntax unified
 1186              	@ 216 "FreeRTOS/ARM_CM3/portmacro.h" 1
 1187 0008 EFF31183 			mrs r3, basepri											
 1188 000c 4FF05002 		mov r2, #80												
 1189 0010 82F31188 		msr basepri, r2											
 1190 0014 BFF36F8F 		isb														
 1191 0018 BFF34F8F 		dsb														
 1192              	
 1193              	@ 0 "" 2
 1194              		.thumb
 1195              		.syntax unified
 1196              	.LBE165:
 1197              	.LBE164:
1537:FreeRTOS/tasks.c ****             uxReturn = pxTCB->uxPriority;
 1198              		.loc 1 1537 0
 1199 001c 1CB1     		cbz	r4, .L104
 1200              	.LVL107:
 1201              	.L102:
1538:FreeRTOS/tasks.c ****         }
 1202              		.loc 1 1538 0 discriminator 4
 1203 001e E06A     		ldr	r0, [r4, #44]
 1204              	.LVL108:
 1205              	.LBB166:
 1206              	.LBB167:
 217:FreeRTOS/ARM_CM3/portmacro.h ****         (
 218:FreeRTOS/ARM_CM3/portmacro.h ****             "	mrs %0, basepri											\n"\
 219:FreeRTOS/ARM_CM3/portmacro.h ****             "	mov %1, %2												\n"\
 220:FreeRTOS/ARM_CM3/portmacro.h ****             "	msr basepri, %1											\n"\
 221:FreeRTOS/ARM_CM3/portmacro.h ****             "	isb														\n"\
 222:FreeRTOS/ARM_CM3/portmacro.h ****             "	dsb														\n"\
ARM GAS  /tmp/ccrgBt0i.s 			page 123


 223:FreeRTOS/ARM_CM3/portmacro.h ****             : "=r" ( ulOriginalBASEPRI ), "=r" ( ulNewBASEPRI ) : "i" ( configMAX_SYSCALL_INTERRUPT
 224:FreeRTOS/ARM_CM3/portmacro.h ****         );
 225:FreeRTOS/ARM_CM3/portmacro.h **** 
 226:FreeRTOS/ARM_CM3/portmacro.h ****         /* This return will not be reached but is necessary to prevent compiler
 227:FreeRTOS/ARM_CM3/portmacro.h ****          * warnings. */
 228:FreeRTOS/ARM_CM3/portmacro.h ****         return ulOriginalBASEPRI;
 229:FreeRTOS/ARM_CM3/portmacro.h ****     }
 230:FreeRTOS/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 231:FreeRTOS/ARM_CM3/portmacro.h **** 
 232:FreeRTOS/ARM_CM3/portmacro.h ****     portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
 233:FreeRTOS/ARM_CM3/portmacro.h ****     {
 234:FreeRTOS/ARM_CM3/portmacro.h ****         __asm volatile
 1207              		.loc 2 234 0 discriminator 4
 1208              		.syntax unified
 1209              	@ 234 "FreeRTOS/ARM_CM3/portmacro.h" 1
 1210 0020 83F31188 			msr basepri, r3	
 1211              	@ 0 "" 2
 1212              	.LVL109:
 1213              		.thumb
 1214              		.syntax unified
 1215              	.LBE167:
 1216              	.LBE166:
1543:FreeRTOS/tasks.c **** 
 1217              		.loc 1 1543 0 discriminator 4
 1218 0024 10BD     		pop	{r4, pc}
 1219              	.LVL110:
 1220              	.L104:
1537:FreeRTOS/tasks.c ****             uxReturn = pxTCB->uxPriority;
 1221              		.loc 1 1537 0 discriminator 1
 1222 0026 014A     		ldr	r2, .L105
 1223 0028 1468     		ldr	r4, [r2]
 1224              	.LVL111:
 1225 002a F8E7     		b	.L102
 1226              	.L106:
 1227              		.align	2
 1228              	.L105:
 1229 002c 00000000 		.word	.LANCHOR10
 1230              		.cfi_endproc
 1231              	.LFE12:
 1233              		.section	.text.vTaskPrioritySet,"ax",%progbits
 1234              		.align	1
 1235              		.global	vTaskPrioritySet
 1236              		.syntax unified
 1237              		.thumb
 1238              		.thumb_func
 1239              		.fpu softvfp
 1241              	vTaskPrioritySet:
 1242              	.LFB13:
1552:FreeRTOS/tasks.c ****         TCB_t * pxTCB;
 1243              		.loc 1 1552 0
 1244              		.cfi_startproc
 1245              		@ args = 0, pretend = 0, frame = 0
 1246              		@ frame_needed = 0, uses_anonymous_args = 0
 1247              	.LVL112:
 1248 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 1249              	.LCFI15:
 1250              		.cfi_def_cfa_offset 24
ARM GAS  /tmp/ccrgBt0i.s 			page 124


 1251              		.cfi_offset 3, -24
 1252              		.cfi_offset 4, -20
 1253              		.cfi_offset 5, -16
 1254              		.cfi_offset 6, -12
 1255              		.cfi_offset 7, -8
 1256              		.cfi_offset 14, -4
 1257              	.LVL113:
1557:FreeRTOS/tasks.c **** 
 1258              		.loc 1 1557 0
 1259 0002 0629     		cmp	r1, #6
 1260 0004 08D9     		bls	.L108
 1261              	.LBB168:
 1262              	.LBB169:
 200:FreeRTOS/ARM_CM3/portmacro.h ****         (
 1263              		.loc 2 200 0
 1264              		.syntax unified
 1265              	@ 200 "FreeRTOS/ARM_CM3/portmacro.h" 1
 1266 0006 4FF05003 			mov r3, #80												
 1267 000a 83F31188 		msr basepri, r3											
 1268 000e BFF36F8F 		isb														
 1269 0012 BFF34F8F 		dsb														
 1270              	
 1271              	@ 0 "" 2
 1272              	.LVL114:
 1273              		.thumb
 1274              		.syntax unified
 1275              	.L109:
 1276 0016 FEE7     		b	.L109
 1277              	.L108:
 1278 0018 0446     		mov	r4, r0
 1279 001a 0D46     		mov	r5, r1
 1280              	.LVL115:
 1281              	.LBE169:
 1282              	.LBE168:
1569:FreeRTOS/tasks.c ****         {
 1283              		.loc 1 1569 0
 1284 001c FFF7FEFF 		bl	vPortEnterCritical
 1285              	.LVL116:
1573:FreeRTOS/tasks.c **** 
 1286              		.loc 1 1573 0
 1287 0020 0CB9     		cbnz	r4, .L110
1573:FreeRTOS/tasks.c **** 
 1288              		.loc 1 1573 0 is_stmt 0 discriminator 1
 1289 0022 304B     		ldr	r3, .L122
 1290 0024 1C68     		ldr	r4, [r3]
 1291              	.LVL117:
 1292              	.L110:
1579:FreeRTOS/tasks.c ****                 }
 1293              		.loc 1 1579 0 is_stmt 1 discriminator 4
 1294 0026 636C     		ldr	r3, [r4, #68]
 1295              	.LVL118:
1587:FreeRTOS/tasks.c ****             {
 1296              		.loc 1 1587 0 discriminator 4
 1297 0028 9D42     		cmp	r5, r3
 1298 002a 4CD0     		beq	.L111
1591:FreeRTOS/tasks.c ****                 {
 1299              		.loc 1 1591 0
ARM GAS  /tmp/ccrgBt0i.s 			page 125


 1300 002c 4ED9     		bls	.L112
1593:FreeRTOS/tasks.c ****                     {
 1301              		.loc 1 1593 0
 1302 002e 2D4A     		ldr	r2, .L122
 1303 0030 1268     		ldr	r2, [r2]
 1304 0032 A242     		cmp	r2, r4
 1305 0034 50D0     		beq	.L118
1598:FreeRTOS/tasks.c ****                         {
 1306              		.loc 1 1598 0
 1307 0036 2B4A     		ldr	r2, .L122
 1308 0038 1268     		ldr	r2, [r2]
 1309 003a D26A     		ldr	r2, [r2, #44]
 1310 003c AA42     		cmp	r2, r5
 1311 003e 4DD9     		bls	.L119
1555:FreeRTOS/tasks.c **** 
 1312              		.loc 1 1555 0
 1313 0040 0026     		movs	r6, #0
 1314              	.L113:
 1315              	.LVL119:
1631:FreeRTOS/tasks.c **** 
 1316              		.loc 1 1631 0
 1317 0042 E76A     		ldr	r7, [r4, #44]
 1318              	.LVL120:
1637:FreeRTOS/tasks.c ****                         {
 1319              		.loc 1 1637 0
 1320 0044 BB42     		cmp	r3, r7
 1321 0046 00D1     		bne	.L114
1639:FreeRTOS/tasks.c ****                         }
 1322              		.loc 1 1639 0
 1323 0048 E562     		str	r5, [r4, #44]
 1324              	.L114:
1647:FreeRTOS/tasks.c ****                     }
 1325              		.loc 1 1647 0
 1326 004a 6564     		str	r5, [r4, #68]
1657:FreeRTOS/tasks.c ****                 {
 1327              		.loc 1 1657 0
 1328 004c A369     		ldr	r3, [r4, #24]
 1329              	.LVL121:
 1330 004e 002B     		cmp	r3, #0
 1331 0050 02DB     		blt	.L115
1659:FreeRTOS/tasks.c ****                 }
 1332              		.loc 1 1659 0
 1333 0052 C5F10705 		rsb	r5, r5, #7
 1334              	.LVL122:
 1335 0056 A561     		str	r5, [r4, #24]
 1336              	.L115:
1670:FreeRTOS/tasks.c ****                 {
 1337              		.loc 1 1670 0
 1338 0058 6269     		ldr	r2, [r4, #20]
 1339 005a 2349     		ldr	r1, .L122+4
 1340 005c 1423     		movs	r3, #20
 1341 005e 03FB0713 		mla	r3, r3, r7, r1
 1342 0062 9A42     		cmp	r2, r3
 1343 0064 26D1     		bne	.L116
1675:FreeRTOS/tasks.c ****                     {
 1344              		.loc 1 1675 0
 1345 0066 251D     		adds	r5, r4, #4
ARM GAS  /tmp/ccrgBt0i.s 			page 126


 1346 0068 2846     		mov	r0, r5
 1347 006a FFF7FEFF 		bl	uxListRemove
 1348              	.LVL123:
 1349 006e 38B9     		cbnz	r0, .L117
1680:FreeRTOS/tasks.c ****                     }
 1350              		.loc 1 1680 0
 1351 0070 0123     		movs	r3, #1
 1352 0072 03FA07F2 		lsl	r2, r3, r7
 1353 0076 1D49     		ldr	r1, .L122+8
 1354 0078 0B68     		ldr	r3, [r1]
 1355 007a 23EA0203 		bic	r3, r3, r2
 1356 007e 0B60     		str	r3, [r1]
 1357              	.L117:
1687:FreeRTOS/tasks.c ****                 }
 1358              		.loc 1 1687 0
 1359 0080 E16A     		ldr	r1, [r4, #44]
 1360 0082 0123     		movs	r3, #1
 1361 0084 8B40     		lsls	r3, r3, r1
 1362 0086 194A     		ldr	r2, .L122+8
 1363 0088 1068     		ldr	r0, [r2]
 1364 008a 0343     		orrs	r3, r3, r0
 1365 008c 1360     		str	r3, [r2]
 1366              	.LBB170:
 1367 008e 164A     		ldr	r2, .L122+4
 1368 0090 1423     		movs	r3, #20
 1369 0092 03FB0121 		mla	r1, r3, r1, r2
 1370 0096 4968     		ldr	r1, [r1, #4]
 1371              	.LVL124:
 1372 0098 A160     		str	r1, [r4, #8]
 1373 009a 8868     		ldr	r0, [r1, #8]
 1374 009c E060     		str	r0, [r4, #12]
 1375 009e 8868     		ldr	r0, [r1, #8]
 1376 00a0 4560     		str	r5, [r0, #4]
 1377 00a2 8D60     		str	r5, [r1, #8]
 1378 00a4 E16A     		ldr	r1, [r4, #44]
 1379              	.LVL125:
 1380 00a6 03FB01F3 		mul	r3, r3, r1
 1381 00aa D118     		adds	r1, r2, r3
 1382 00ac 6161     		str	r1, [r4, #20]
 1383 00ae D158     		ldr	r1, [r2, r3]
 1384 00b0 0131     		adds	r1, r1, #1
 1385 00b2 D150     		str	r1, [r2, r3]
 1386              	.L116:
 1387              	.LBE170:
1694:FreeRTOS/tasks.c ****                 {
 1388              		.loc 1 1694 0
 1389 00b4 3EB1     		cbz	r6, .L111
1696:FreeRTOS/tasks.c ****                 }
 1390              		.loc 1 1696 0
 1391 00b6 0E4B     		ldr	r3, .L122+12
 1392 00b8 4FF08052 		mov	r2, #268435456
 1393 00bc 1A60     		str	r2, [r3]
 1394              		.syntax unified
 1395              	@ 1696 "FreeRTOS/tasks.c" 1
 1396 00be BFF34F8F 		dsb
 1397              	@ 0 "" 2
 1398              	@ 1696 "FreeRTOS/tasks.c" 1
ARM GAS  /tmp/ccrgBt0i.s 			page 127


 1399 00c2 BFF36F8F 		isb
 1400              	@ 0 "" 2
 1401              	.LVL126:
 1402              		.thumb
 1403              		.syntax unified
 1404              	.L111:
1708:FreeRTOS/tasks.c ****     }
 1405              		.loc 1 1708 0
 1406 00c6 FFF7FEFF 		bl	vPortExitCritical
 1407              	.LVL127:
1709:FreeRTOS/tasks.c **** 
 1408              		.loc 1 1709 0
 1409 00ca F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1410              	.LVL128:
 1411              	.L112:
1614:FreeRTOS/tasks.c ****                 {
 1412              		.loc 1 1614 0
 1413 00cc 054A     		ldr	r2, .L122
 1414 00ce 1268     		ldr	r2, [r2]
 1415 00d0 A242     		cmp	r2, r4
 1416 00d2 05D0     		beq	.L120
1555:FreeRTOS/tasks.c **** 
 1417              		.loc 1 1555 0
 1418 00d4 0026     		movs	r6, #0
 1419 00d6 B4E7     		b	.L113
 1420              	.L118:
 1421 00d8 0026     		movs	r6, #0
 1422 00da B2E7     		b	.L113
 1423              	.L119:
1600:FreeRTOS/tasks.c ****                         }
 1424              		.loc 1 1600 0
 1425 00dc 0126     		movs	r6, #1
 1426 00de B0E7     		b	.L113
 1427              	.L120:
1619:FreeRTOS/tasks.c ****                 }
 1428              		.loc 1 1619 0
 1429 00e0 0126     		movs	r6, #1
 1430 00e2 AEE7     		b	.L113
 1431              	.L123:
 1432              		.align	2
 1433              	.L122:
 1434 00e4 00000000 		.word	.LANCHOR10
 1435 00e8 00000000 		.word	.LANCHOR4
 1436 00ec 00000000 		.word	.LANCHOR13
 1437 00f0 04ED00E0 		.word	-536810236
 1438              		.cfi_endproc
 1439              	.LFE13:
 1441              		.section	.text.vTaskResume,"ax",%progbits
 1442              		.align	1
 1443              		.global	vTaskResume
 1444              		.syntax unified
 1445              		.thumb
 1446              		.thumb_func
 1447              		.fpu softvfp
 1449              	vTaskResume:
 1450              	.LFB16:
1869:FreeRTOS/tasks.c ****         TCB_t * const pxTCB = xTaskToResume;
ARM GAS  /tmp/ccrgBt0i.s 			page 128


 1451              		.loc 1 1869 0
 1452              		.cfi_startproc
 1453              		@ args = 0, pretend = 0, frame = 0
 1454              		@ frame_needed = 0, uses_anonymous_args = 0
 1455              	.LVL129:
 1456 0000 38B5     		push	{r3, r4, r5, lr}
 1457              	.LCFI16:
 1458              		.cfi_def_cfa_offset 16
 1459              		.cfi_offset 3, -16
 1460              		.cfi_offset 4, -12
 1461              		.cfi_offset 5, -8
 1462              		.cfi_offset 14, -4
 1463              	.LVL130:
1873:FreeRTOS/tasks.c **** 
 1464              		.loc 1 1873 0
 1465 0002 68B1     		cbz	r0, .L130
 1466 0004 0446     		mov	r4, r0
1877:FreeRTOS/tasks.c ****         {
 1467              		.loc 1 1877 0
 1468 0006 214B     		ldr	r3, .L132
 1469 0008 1B68     		ldr	r3, [r3]
 1470 000a 8342     		cmp	r3, r0
 1471 000c 07D0     		beq	.L124
1879:FreeRTOS/tasks.c ****             {
 1472              		.loc 1 1879 0
 1473 000e FFF7FEFF 		bl	vPortEnterCritical
 1474              	.LVL131:
1881:FreeRTOS/tasks.c ****                 {
 1475              		.loc 1 1881 0
 1476 0012 2046     		mov	r0, r4
 1477 0014 FFF7FEFF 		bl	prvTaskIsTaskSuspended
 1478              	.LVL132:
 1479 0018 58B9     		cbnz	r0, .L131
 1480              	.L128:
1908:FreeRTOS/tasks.c ****         }
 1481              		.loc 1 1908 0
 1482 001a FFF7FEFF 		bl	vPortExitCritical
 1483              	.LVL133:
 1484              	.L124:
1914:FreeRTOS/tasks.c **** 
 1485              		.loc 1 1914 0
 1486 001e 38BD     		pop	{r3, r4, r5, pc}
 1487              	.LVL134:
 1488              	.L130:
 1489              	.LBB171:
 1490              	.LBB172:
 200:FreeRTOS/ARM_CM3/portmacro.h ****         (
 1491              		.loc 2 200 0
 1492              		.syntax unified
 1493              	@ 200 "FreeRTOS/ARM_CM3/portmacro.h" 1
 1494 0020 4FF05003 			mov r3, #80												
 1495 0024 83F31188 		msr basepri, r3											
 1496 0028 BFF36F8F 		isb														
 1497 002c BFF34F8F 		dsb														
 1498              	
 1499              	@ 0 "" 2
 1500              	.LVL135:
ARM GAS  /tmp/ccrgBt0i.s 			page 129


 1501              		.thumb
 1502              		.syntax unified
 1503              	.L126:
 1504 0030 FEE7     		b	.L126
 1505              	.LVL136:
 1506              	.L131:
 1507              	.LBE172:
 1508              	.LBE171:
1887:FreeRTOS/tasks.c ****                     prvAddTaskToReadyList( pxTCB );
 1509              		.loc 1 1887 0
 1510 0032 251D     		adds	r5, r4, #4
 1511 0034 2846     		mov	r0, r5
 1512 0036 FFF7FEFF 		bl	uxListRemove
 1513              	.LVL137:
1888:FreeRTOS/tasks.c **** 
 1514              		.loc 1 1888 0
 1515 003a E16A     		ldr	r1, [r4, #44]
 1516 003c 0123     		movs	r3, #1
 1517 003e 8B40     		lsls	r3, r3, r1
 1518 0040 134A     		ldr	r2, .L132+4
 1519 0042 1068     		ldr	r0, [r2]
 1520 0044 0343     		orrs	r3, r3, r0
 1521 0046 1360     		str	r3, [r2]
 1522              	.LBB173:
 1523 0048 124A     		ldr	r2, .L132+8
 1524 004a 1423     		movs	r3, #20
 1525 004c 03FB0121 		mla	r1, r3, r1, r2
 1526 0050 4968     		ldr	r1, [r1, #4]
 1527              	.LVL138:
 1528 0052 A160     		str	r1, [r4, #8]
 1529 0054 8868     		ldr	r0, [r1, #8]
 1530 0056 E060     		str	r0, [r4, #12]
 1531 0058 8868     		ldr	r0, [r1, #8]
 1532 005a 4560     		str	r5, [r0, #4]
 1533 005c 8D60     		str	r5, [r1, #8]
 1534 005e E16A     		ldr	r1, [r4, #44]
 1535              	.LVL139:
 1536 0060 03FB01F3 		mul	r3, r3, r1
 1537 0064 D118     		adds	r1, r2, r3
 1538 0066 6161     		str	r1, [r4, #20]
 1539 0068 D158     		ldr	r1, [r2, r3]
 1540 006a 0131     		adds	r1, r1, #1
 1541 006c D150     		str	r1, [r2, r3]
 1542              	.LBE173:
1891:FreeRTOS/tasks.c ****                     {
 1543              		.loc 1 1891 0
 1544 006e E26A     		ldr	r2, [r4, #44]
 1545 0070 064B     		ldr	r3, .L132
 1546 0072 1B68     		ldr	r3, [r3]
 1547 0074 DB6A     		ldr	r3, [r3, #44]
 1548 0076 9A42     		cmp	r2, r3
 1549 0078 CFD3     		bcc	.L128
1896:FreeRTOS/tasks.c ****                     }
 1550              		.loc 1 1896 0
 1551 007a 074B     		ldr	r3, .L132+12
 1552 007c 4FF08052 		mov	r2, #268435456
 1553 0080 1A60     		str	r2, [r3]
ARM GAS  /tmp/ccrgBt0i.s 			page 130


 1554              		.syntax unified
 1555              	@ 1896 "FreeRTOS/tasks.c" 1
 1556 0082 BFF34F8F 		dsb
 1557              	@ 0 "" 2
 1558              	@ 1896 "FreeRTOS/tasks.c" 1
 1559 0086 BFF36F8F 		isb
 1560              	@ 0 "" 2
 1561              		.thumb
 1562              		.syntax unified
 1563 008a C6E7     		b	.L128
 1564              	.L133:
 1565              		.align	2
 1566              	.L132:
 1567 008c 00000000 		.word	.LANCHOR10
 1568 0090 00000000 		.word	.LANCHOR13
 1569 0094 00000000 		.word	.LANCHOR4
 1570 0098 04ED00E0 		.word	-536810236
 1571              		.cfi_endproc
 1572              	.LFE16:
 1574              		.section	.text.xTaskResumeFromISR,"ax",%progbits
 1575              		.align	1
 1576              		.global	xTaskResumeFromISR
 1577              		.syntax unified
 1578              		.thumb
 1579              		.thumb_func
 1580              		.fpu softvfp
 1582              	xTaskResumeFromISR:
 1583              	.LFB17:
1923:FreeRTOS/tasks.c ****         BaseType_t xYieldRequired = pdFALSE;
 1584              		.loc 1 1923 0
 1585              		.cfi_startproc
 1586              		@ args = 0, pretend = 0, frame = 0
 1587              		@ frame_needed = 0, uses_anonymous_args = 0
 1588              	.LVL140:
 1589 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 1590              	.LCFI17:
 1591              		.cfi_def_cfa_offset 24
 1592              		.cfi_offset 3, -24
 1593              		.cfi_offset 4, -20
 1594              		.cfi_offset 5, -16
 1595              		.cfi_offset 6, -12
 1596              		.cfi_offset 7, -8
 1597              		.cfi_offset 14, -4
 1598              	.LVL141:
1928:FreeRTOS/tasks.c **** 
 1599              		.loc 1 1928 0
 1600 0002 40B9     		cbnz	r0, .L135
 1601              	.LBB174:
 1602              	.LBB175:
 200:FreeRTOS/ARM_CM3/portmacro.h ****         (
 1603              		.loc 2 200 0
 1604              		.syntax unified
 1605              	@ 200 "FreeRTOS/ARM_CM3/portmacro.h" 1
 1606 0004 4FF05003 			mov r3, #80												
 1607 0008 83F31188 		msr basepri, r3											
 1608 000c BFF36F8F 		isb														
 1609 0010 BFF34F8F 		dsb														
ARM GAS  /tmp/ccrgBt0i.s 			page 131


 1610              	
 1611              	@ 0 "" 2
 1612              	.LVL142:
 1613              		.thumb
 1614              		.syntax unified
 1615              	.L136:
 1616 0014 FEE7     		b	.L136
 1617              	.L135:
 1618 0016 0446     		mov	r4, r0
 1619              	.LBE175:
 1620              	.LBE174:
1946:FreeRTOS/tasks.c **** 
 1621              		.loc 1 1946 0
 1622 0018 FFF7FEFF 		bl	vPortValidateInterruptPriority
 1623              	.LVL143:
 1624              	.LBB176:
 1625              	.LBB177:
 216:FreeRTOS/ARM_CM3/portmacro.h ****         (
 1626              		.loc 2 216 0
 1627              		.syntax unified
 1628              	@ 216 "FreeRTOS/ARM_CM3/portmacro.h" 1
 1629 001c EFF31186 			mrs r6, basepri											
 1630 0020 4FF05003 		mov r3, #80												
 1631 0024 83F31188 		msr basepri, r3											
 1632 0028 BFF36F8F 		isb														
 1633 002c BFF34F8F 		dsb														
 1634              	
 1635              	@ 0 "" 2
 1636              		.thumb
 1637              		.syntax unified
 1638              	.LBE177:
 1639              	.LBE176:
1950:FreeRTOS/tasks.c ****             {
 1640              		.loc 1 1950 0
 1641 0030 2046     		mov	r0, r4
 1642 0032 FFF7FEFF 		bl	prvTaskIsTaskSuspended
 1643              	.LVL144:
 1644 0036 0028     		cmp	r0, #0
 1645 0038 37D0     		beq	.L140
1955:FreeRTOS/tasks.c ****                 {
 1646              		.loc 1 1955 0
 1647 003a 1D4B     		ldr	r3, .L143
 1648 003c 1B68     		ldr	r3, [r3]
 1649 003e 002B     		cmp	r3, #0
 1650 0040 2CD1     		bne	.L138
1959:FreeRTOS/tasks.c ****                     {
 1651              		.loc 1 1959 0
 1652 0042 E26A     		ldr	r2, [r4, #44]
 1653 0044 1B4B     		ldr	r3, .L143+4
 1654 0046 1B68     		ldr	r3, [r3]
 1655 0048 DB6A     		ldr	r3, [r3, #44]
 1656 004a 9A42     		cmp	r2, r3
 1657 004c 24D3     		bcc	.L141
 1658              	.LVL145:
1966:FreeRTOS/tasks.c ****                     }
 1659              		.loc 1 1966 0
 1660 004e 0125     		movs	r5, #1
ARM GAS  /tmp/ccrgBt0i.s 			page 132


 1661 0050 194B     		ldr	r3, .L143+8
 1662 0052 1D60     		str	r5, [r3]
 1663              	.LVL146:
 1664              	.L139:
1973:FreeRTOS/tasks.c ****                     prvAddTaskToReadyList( pxTCB );
 1665              		.loc 1 1973 0
 1666 0054 271D     		adds	r7, r4, #4
 1667 0056 3846     		mov	r0, r7
 1668 0058 FFF7FEFF 		bl	uxListRemove
 1669              	.LVL147:
1974:FreeRTOS/tasks.c ****                 }
 1670              		.loc 1 1974 0
 1671 005c E16A     		ldr	r1, [r4, #44]
 1672 005e 0123     		movs	r3, #1
 1673 0060 8B40     		lsls	r3, r3, r1
 1674 0062 164A     		ldr	r2, .L143+12
 1675 0064 1068     		ldr	r0, [r2]
 1676 0066 0343     		orrs	r3, r3, r0
 1677 0068 1360     		str	r3, [r2]
 1678              	.LBB178:
 1679 006a 154A     		ldr	r2, .L143+16
 1680 006c 1423     		movs	r3, #20
 1681 006e 03FB0121 		mla	r1, r3, r1, r2
 1682 0072 4968     		ldr	r1, [r1, #4]
 1683              	.LVL148:
 1684 0074 A160     		str	r1, [r4, #8]
 1685 0076 8868     		ldr	r0, [r1, #8]
 1686 0078 E060     		str	r0, [r4, #12]
 1687 007a 8868     		ldr	r0, [r1, #8]
 1688 007c 4760     		str	r7, [r0, #4]
 1689 007e 8F60     		str	r7, [r1, #8]
 1690 0080 E16A     		ldr	r1, [r4, #44]
 1691              	.LVL149:
 1692 0082 03FB01F3 		mul	r3, r3, r1
 1693 0086 D118     		adds	r1, r2, r3
 1694 0088 6161     		str	r1, [r4, #20]
 1695 008a D158     		ldr	r1, [r2, r3]
 1696 008c 0131     		adds	r1, r1, #1
 1697 008e D150     		str	r1, [r2, r3]
 1698              	.LVL150:
 1699              	.L137:
 1700              	.LBE178:
 1701              	.LBB179:
 1702              	.LBB180:
 1703              		.loc 2 234 0
 1704              		.syntax unified
 1705              	@ 234 "FreeRTOS/ARM_CM3/portmacro.h" 1
 1706 0090 86F31188 			msr basepri, r6	
 1707              	@ 0 "" 2
 1708              	.LVL151:
 1709              		.thumb
 1710              		.syntax unified
 1711              	.LBE180:
 1712              	.LBE179:
1992:FreeRTOS/tasks.c **** 
 1713              		.loc 1 1992 0
 1714 0094 2846     		mov	r0, r5
ARM GAS  /tmp/ccrgBt0i.s 			page 133


 1715 0096 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1716              	.LVL152:
 1717              	.L141:
1924:FreeRTOS/tasks.c ****         TCB_t * const pxTCB = xTaskToResume;
 1718              		.loc 1 1924 0
 1719 0098 0025     		movs	r5, #0
 1720 009a DBE7     		b	.L139
 1721              	.L138:
1981:FreeRTOS/tasks.c ****                 }
 1722              		.loc 1 1981 0
 1723 009c 04F11801 		add	r1, r4, #24
 1724 00a0 0848     		ldr	r0, .L143+20
 1725 00a2 FFF7FEFF 		bl	vListInsertEnd
 1726              	.LVL153:
1924:FreeRTOS/tasks.c ****         TCB_t * const pxTCB = xTaskToResume;
 1727              		.loc 1 1924 0
 1728 00a6 0025     		movs	r5, #0
 1729 00a8 F2E7     		b	.L137
 1730              	.L140:
 1731 00aa 0025     		movs	r5, #0
 1732 00ac F0E7     		b	.L137
 1733              	.L144:
 1734 00ae 00BF     		.align	2
 1735              	.L143:
 1736 00b0 00000000 		.word	.LANCHOR16
 1737 00b4 00000000 		.word	.LANCHOR10
 1738 00b8 00000000 		.word	.LANCHOR17
 1739 00bc 00000000 		.word	.LANCHOR13
 1740 00c0 00000000 		.word	.LANCHOR4
 1741 00c4 00000000 		.word	.LANCHOR1
 1742              		.cfi_endproc
 1743              	.LFE17:
 1745              		.section	.text.vTaskStartScheduler,"ax",%progbits
 1746              		.align	1
 1747              		.global	vTaskStartScheduler
 1748              		.syntax unified
 1749              		.thumb
 1750              		.thumb_func
 1751              		.fpu softvfp
 1753              	vTaskStartScheduler:
 1754              	.LFB18:
1998:FreeRTOS/tasks.c ****     BaseType_t xReturn;
 1755              		.loc 1 1998 0
 1756              		.cfi_startproc
 1757              		@ args = 0, pretend = 0, frame = 0
 1758              		@ frame_needed = 0, uses_anonymous_args = 0
 1759 0000 00B5     		push	{lr}
 1760              	.LCFI18:
 1761              		.cfi_def_cfa_offset 4
 1762              		.cfi_offset 14, -4
 1763 0002 83B0     		sub	sp, sp, #12
 1764              	.LCFI19:
 1765              		.cfi_def_cfa_offset 16
2031:FreeRTOS/tasks.c ****                                    configIDLE_TASK_NAME,
 1766              		.loc 1 2031 0
 1767 0004 1A4B     		ldr	r3, .L154
 1768 0006 0193     		str	r3, [sp, #4]
ARM GAS  /tmp/ccrgBt0i.s 			page 134


 1769 0008 0023     		movs	r3, #0
 1770 000a 0093     		str	r3, [sp]
 1771 000c 8022     		movs	r2, #128
 1772 000e 1949     		ldr	r1, .L154+4
 1773 0010 1948     		ldr	r0, .L154+8
 1774 0012 FFF7FEFF 		bl	xTaskCreate
 1775              	.LVL154:
2042:FreeRTOS/tasks.c ****             {
 1776              		.loc 1 2042 0
 1777 0016 0128     		cmp	r0, #1
 1778 0018 09D0     		beq	.L151
 1779              	.L146:
2053:FreeRTOS/tasks.c ****     {
 1780              		.loc 1 2053 0
 1781 001a 0128     		cmp	r0, #1
 1782 001c 0AD0     		beq	.L152
2112:FreeRTOS/tasks.c ****     }
 1783              		.loc 1 2112 0
 1784 001e B0F1FF3F 		cmp	r0, #-1
 1785 0022 1CD0     		beq	.L153
 1786              	.LVL155:
 1787              	.L148:
2121:FreeRTOS/tasks.c **** }
 1788              		.loc 1 2121 0
 1789 0024 154B     		ldr	r3, .L154+12
 1790 0026 1B68     		ldr	r3, [r3]
2122:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 1791              		.loc 1 2122 0
 1792 0028 03B0     		add	sp, sp, #12
 1793              	.LCFI20:
 1794              		.cfi_remember_state
 1795              		.cfi_def_cfa_offset 4
 1796              		@ sp needed
 1797 002a 5DF804FB 		ldr	pc, [sp], #4
 1798              	.LVL156:
 1799              	.L151:
 1800              	.LCFI21:
 1801              		.cfi_restore_state
2044:FreeRTOS/tasks.c ****             }
 1802              		.loc 1 2044 0
 1803 002e FFF7FEFF 		bl	xTimerCreateTimerTask
 1804              	.LVL157:
 1805 0032 F2E7     		b	.L146
 1806              	.L152:
 1807              	.LBB181:
 1808              	.LBB182:
 200:FreeRTOS/ARM_CM3/portmacro.h ****         (
 1809              		.loc 2 200 0
 1810              		.syntax unified
 1811              	@ 200 "FreeRTOS/ARM_CM3/portmacro.h" 1
 1812 0034 4FF05003 			mov r3, #80												
 1813 0038 83F31188 		msr basepri, r3											
 1814 003c BFF36F8F 		isb														
 1815 0040 BFF34F8F 		dsb														
 1816              	
 1817              	@ 0 "" 2
 1818              		.thumb
ARM GAS  /tmp/ccrgBt0i.s 			page 135


 1819              		.syntax unified
 1820              	.LBE182:
 1821              	.LBE181:
2081:FreeRTOS/tasks.c ****         xSchedulerRunning = pdTRUE;
 1822              		.loc 1 2081 0
 1823 0044 0E4B     		ldr	r3, .L154+16
 1824 0046 4FF0FF32 		mov	r2, #-1
 1825 004a 1A60     		str	r2, [r3]
2082:FreeRTOS/tasks.c ****         xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
 1826              		.loc 1 2082 0
 1827 004c 0D4B     		ldr	r3, .L154+20
 1828 004e 0122     		movs	r2, #1
 1829 0050 1A60     		str	r2, [r3]
2083:FreeRTOS/tasks.c **** 
 1830              		.loc 1 2083 0
 1831 0052 0D4B     		ldr	r3, .L154+24
 1832 0054 0022     		movs	r2, #0
 1833 0056 1A60     		str	r2, [r3]
2097:FreeRTOS/tasks.c ****         {
 1834              		.loc 1 2097 0
 1835 0058 FFF7FEFF 		bl	xPortStartScheduler
 1836              	.LVL158:
 1837 005c E2E7     		b	.L148
 1838              	.LVL159:
 1839              	.L153:
 1840              	.LBB183:
 1841              	.LBB184:
 200:FreeRTOS/ARM_CM3/portmacro.h ****         (
 1842              		.loc 2 200 0
 1843              		.syntax unified
 1844              	@ 200 "FreeRTOS/ARM_CM3/portmacro.h" 1
 1845 005e 4FF05003 			mov r3, #80												
 1846 0062 83F31188 		msr basepri, r3											
 1847 0066 BFF36F8F 		isb														
 1848 006a BFF34F8F 		dsb														
 1849              	
 1850              	@ 0 "" 2
 1851              	.LVL160:
 1852              		.thumb
 1853              		.syntax unified
 1854              	.L149:
 1855 006e FEE7     		b	.L149
 1856              	.L155:
 1857              		.align	2
 1858              	.L154:
 1859 0070 00000000 		.word	.LANCHOR18
 1860 0074 00000000 		.word	.LC0
 1861 0078 00000000 		.word	prvIdleTask
 1862 007c 00000000 		.word	.LANCHOR19
 1863 0080 00000000 		.word	.LANCHOR3
 1864 0084 00000000 		.word	.LANCHOR11
 1865 0088 00000000 		.word	.LANCHOR15
 1866              	.LBE184:
 1867              	.LBE183:
 1868              		.cfi_endproc
 1869              	.LFE18:
 1871              		.section	.text.vTaskEndScheduler,"ax",%progbits
ARM GAS  /tmp/ccrgBt0i.s 			page 136


 1872              		.align	1
 1873              		.global	vTaskEndScheduler
 1874              		.syntax unified
 1875              		.thumb
 1876              		.thumb_func
 1877              		.fpu softvfp
 1879              	vTaskEndScheduler:
 1880              	.LFB19:
2126:FreeRTOS/tasks.c ****     /* Stop the scheduler interrupts and call the portable scheduler end
 1881              		.loc 1 2126 0
 1882              		.cfi_startproc
 1883              		@ args = 0, pretend = 0, frame = 0
 1884              		@ frame_needed = 0, uses_anonymous_args = 0
 1885 0000 08B5     		push	{r3, lr}
 1886              	.LCFI22:
 1887              		.cfi_def_cfa_offset 8
 1888              		.cfi_offset 3, -8
 1889              		.cfi_offset 14, -4
 1890              	.LBB185:
 1891              	.LBB186:
 200:FreeRTOS/ARM_CM3/portmacro.h ****         (
 1892              		.loc 2 200 0
 1893              		.syntax unified
 1894              	@ 200 "FreeRTOS/ARM_CM3/portmacro.h" 1
 1895 0002 4FF05003 			mov r3, #80												
 1896 0006 83F31188 		msr basepri, r3											
 1897 000a BFF36F8F 		isb														
 1898 000e BFF34F8F 		dsb														
 1899              	
 1900              	@ 0 "" 2
 1901              		.thumb
 1902              		.syntax unified
 1903              	.LBE186:
 1904              	.LBE185:
2131:FreeRTOS/tasks.c ****     vPortEndScheduler();
 1905              		.loc 1 2131 0
 1906 0012 034B     		ldr	r3, .L158
 1907 0014 0022     		movs	r2, #0
 1908 0016 1A60     		str	r2, [r3]
2132:FreeRTOS/tasks.c **** }
 1909              		.loc 1 2132 0
 1910 0018 FFF7FEFF 		bl	vPortEndScheduler
 1911              	.LVL161:
2133:FreeRTOS/tasks.c **** /*----------------------------------------------------------*/
 1912              		.loc 1 2133 0
 1913 001c 08BD     		pop	{r3, pc}
 1914              	.L159:
 1915 001e 00BF     		.align	2
 1916              	.L158:
 1917 0020 00000000 		.word	.LANCHOR11
 1918              		.cfi_endproc
 1919              	.LFE19:
 1921              		.section	.text.vTaskSuspendAll,"ax",%progbits
 1922              		.align	1
 1923              		.global	vTaskSuspendAll
 1924              		.syntax unified
 1925              		.thumb
ARM GAS  /tmp/ccrgBt0i.s 			page 137


 1926              		.thumb_func
 1927              		.fpu softvfp
 1929              	vTaskSuspendAll:
 1930              	.LFB20:
2137:FreeRTOS/tasks.c ****     /* A critical section is not required as the variable is of type
 1931              		.loc 1 2137 0
 1932              		.cfi_startproc
 1933              		@ args = 0, pretend = 0, frame = 0
 1934              		@ frame_needed = 0, uses_anonymous_args = 0
 1935              		@ link register save eliminated.
2149:FreeRTOS/tasks.c **** 
 1936              		.loc 1 2149 0
 1937 0000 024A     		ldr	r2, .L161
 1938 0002 1368     		ldr	r3, [r2]
 1939 0004 0133     		adds	r3, r3, #1
 1940 0006 1360     		str	r3, [r2]
2153:FreeRTOS/tasks.c **** }
 1941              		.loc 1 2153 0
2154:FreeRTOS/tasks.c **** /*----------------------------------------------------------*/
 1942              		.loc 1 2154 0
 1943 0008 7047     		bx	lr
 1944              	.L162:
 1945 000a 00BF     		.align	2
 1946              	.L161:
 1947 000c 00000000 		.word	.LANCHOR16
 1948              		.cfi_endproc
 1949              	.LFE20:
 1951              		.section	.text.xTaskGetTickCount,"ax",%progbits
 1952              		.align	1
 1953              		.global	xTaskGetTickCount
 1954              		.syntax unified
 1955              		.thumb
 1956              		.thumb_func
 1957              		.fpu softvfp
 1959              	xTaskGetTickCount:
 1960              	.LFB22:
2333:FreeRTOS/tasks.c ****     TickType_t xTicks;
 1961              		.loc 1 2333 0
 1962              		.cfi_startproc
 1963              		@ args = 0, pretend = 0, frame = 0
 1964              		@ frame_needed = 0, uses_anonymous_args = 0
 1965              		@ link register save eliminated.
2339:FreeRTOS/tasks.c ****     }
 1966              		.loc 1 2339 0
 1967 0000 014B     		ldr	r3, .L164
 1968 0002 1868     		ldr	r0, [r3]
 1969              	.LVL162:
2344:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 1970              		.loc 1 2344 0
 1971 0004 7047     		bx	lr
 1972              	.L165:
 1973 0006 00BF     		.align	2
 1974              	.L164:
 1975 0008 00000000 		.word	.LANCHOR15
 1976              		.cfi_endproc
 1977              	.LFE22:
 1979              		.section	.text.xTaskGetTickCountFromISR,"ax",%progbits
ARM GAS  /tmp/ccrgBt0i.s 			page 138


 1980              		.align	1
 1981              		.global	xTaskGetTickCountFromISR
 1982              		.syntax unified
 1983              		.thumb
 1984              		.thumb_func
 1985              		.fpu softvfp
 1987              	xTaskGetTickCountFromISR:
 1988              	.LFB23:
2348:FreeRTOS/tasks.c ****     TickType_t xReturn;
 1989              		.loc 1 2348 0
 1990              		.cfi_startproc
 1991              		@ args = 0, pretend = 0, frame = 0
 1992              		@ frame_needed = 0, uses_anonymous_args = 0
 1993 0000 08B5     		push	{r3, lr}
 1994              	.LCFI23:
 1995              		.cfi_def_cfa_offset 8
 1996              		.cfi_offset 3, -8
 1997              		.cfi_offset 14, -4
2366:FreeRTOS/tasks.c **** 
 1998              		.loc 1 2366 0
 1999 0002 FFF7FEFF 		bl	vPortValidateInterruptPriority
 2000              	.LVL163:
2370:FreeRTOS/tasks.c ****     }
 2001              		.loc 1 2370 0
 2002 0006 014B     		ldr	r3, .L168
 2003 0008 1868     		ldr	r0, [r3]
 2004              	.LVL164:
2375:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 2005              		.loc 1 2375 0
 2006 000a 08BD     		pop	{r3, pc}
 2007              	.L169:
 2008              		.align	2
 2009              	.L168:
 2010 000c 00000000 		.word	.LANCHOR15
 2011              		.cfi_endproc
 2012              	.LFE23:
 2014              		.section	.text.uxTaskGetNumberOfTasks,"ax",%progbits
 2015              		.align	1
 2016              		.global	uxTaskGetNumberOfTasks
 2017              		.syntax unified
 2018              		.thumb
 2019              		.thumb_func
 2020              		.fpu softvfp
 2022              	uxTaskGetNumberOfTasks:
 2023              	.LFB24:
2379:FreeRTOS/tasks.c ****     /* A critical section is not required because the variables are of type
 2024              		.loc 1 2379 0
 2025              		.cfi_startproc
 2026              		@ args = 0, pretend = 0, frame = 0
 2027              		@ frame_needed = 0, uses_anonymous_args = 0
 2028              		@ link register save eliminated.
2382:FreeRTOS/tasks.c **** }
 2029              		.loc 1 2382 0
 2030 0000 014B     		ldr	r3, .L171
 2031 0002 1868     		ldr	r0, [r3]
2383:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 2032              		.loc 1 2383 0
ARM GAS  /tmp/ccrgBt0i.s 			page 139


 2033 0004 7047     		bx	lr
 2034              	.L172:
 2035 0006 00BF     		.align	2
 2036              	.L171:
 2037 0008 00000000 		.word	.LANCHOR9
 2038              		.cfi_endproc
 2039              	.LFE24:
 2041              		.section	.text.pcTaskGetName,"ax",%progbits
 2042              		.align	1
 2043              		.global	pcTaskGetName
 2044              		.syntax unified
 2045              		.thumb
 2046              		.thumb_func
 2047              		.fpu softvfp
 2049              	pcTaskGetName:
 2050              	.LFB25:
2387:FreeRTOS/tasks.c ****     TCB_t * pxTCB;
 2051              		.loc 1 2387 0
 2052              		.cfi_startproc
 2053              		@ args = 0, pretend = 0, frame = 0
 2054              		@ frame_needed = 0, uses_anonymous_args = 0
 2055              		@ link register save eliminated.
 2056              	.LVL165:
2392:FreeRTOS/tasks.c ****     configASSERT( pxTCB );
 2057              		.loc 1 2392 0
 2058 0000 0346     		mov	r3, r0
 2059 0002 18B1     		cbz	r0, .L177
 2060              	.LVL166:
 2061              	.L174:
2393:FreeRTOS/tasks.c ****     return &( pxTCB->pcTaskName[ 0 ] );
 2062              		.loc 1 2393 0 discriminator 4
 2063 0004 2BB1     		cbz	r3, .L178
2395:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 2064              		.loc 1 2395 0
 2065 0006 03F13400 		add	r0, r3, #52
 2066 000a 7047     		bx	lr
 2067              	.LVL167:
 2068              	.L177:
2392:FreeRTOS/tasks.c ****     configASSERT( pxTCB );
 2069              		.loc 1 2392 0 discriminator 1
 2070 000c 054B     		ldr	r3, .L179
 2071 000e 1B68     		ldr	r3, [r3]
 2072              	.LVL168:
 2073 0010 F8E7     		b	.L174
 2074              	.LVL169:
 2075              	.L178:
 2076              	.LBB187:
 2077              	.LBB188:
 200:FreeRTOS/ARM_CM3/portmacro.h ****         (
 2078              		.loc 2 200 0
 2079              		.syntax unified
 2080              	@ 200 "FreeRTOS/ARM_CM3/portmacro.h" 1
 2081 0012 4FF05003 			mov r3, #80												
 2082 0016 83F31188 		msr basepri, r3											
 2083 001a BFF36F8F 		isb														
 2084 001e BFF34F8F 		dsb														
 2085              	
ARM GAS  /tmp/ccrgBt0i.s 			page 140


 2086              	@ 0 "" 2
 2087              	.LVL170:
 2088              		.thumb
 2089              		.syntax unified
 2090              	.L176:
 2091 0022 FEE7     		b	.L176
 2092              	.L180:
 2093              		.align	2
 2094              	.L179:
 2095 0024 00000000 		.word	.LANCHOR10
 2096              	.LBE188:
 2097              	.LBE187:
 2098              		.cfi_endproc
 2099              	.LFE25:
 2101              		.section	.text.xTaskIncrementTick,"ax",%progbits
 2102              		.align	1
 2103              		.global	xTaskIncrementTick
 2104              		.syntax unified
 2105              		.thumb
 2106              		.thumb_func
 2107              		.fpu softvfp
 2109              	xTaskIncrementTick:
 2110              	.LFB27:
2737:FreeRTOS/tasks.c ****     TCB_t * pxTCB;
 2111              		.loc 1 2737 0
 2112              		.cfi_startproc
 2113              		@ args = 0, pretend = 0, frame = 0
 2114              		@ frame_needed = 0, uses_anonymous_args = 0
 2115 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 2116              	.LCFI24:
 2117              		.cfi_def_cfa_offset 24
 2118              		.cfi_offset 3, -24
 2119              		.cfi_offset 4, -20
 2120              		.cfi_offset 5, -16
 2121              		.cfi_offset 6, -12
 2122              		.cfi_offset 7, -8
 2123              		.cfi_offset 14, -4
 2124              	.LVL171:
2747:FreeRTOS/tasks.c ****     {
 2125              		.loc 1 2747 0
 2126 0002 514B     		ldr	r3, .L206
 2127 0004 1B68     		ldr	r3, [r3]
 2128 0006 002B     		cmp	r3, #0
 2129 0008 40F09880 		bne	.L182
 2130              	.LBB189:
2751:FreeRTOS/tasks.c **** 
 2131              		.loc 1 2751 0
 2132 000c 4F4B     		ldr	r3, .L206+4
 2133 000e 1C68     		ldr	r4, [r3]
 2134 0010 0134     		adds	r4, r4, #1
 2135              	.LVL172:
2755:FreeRTOS/tasks.c **** 
 2136              		.loc 1 2755 0
 2137 0012 1C60     		str	r4, [r3]
2757:FreeRTOS/tasks.c ****         {
 2138              		.loc 1 2757 0
 2139 0014 C4B9     		cbnz	r4, .L183
ARM GAS  /tmp/ccrgBt0i.s 			page 141


 2140              	.LBB190:
2759:FreeRTOS/tasks.c ****         }
 2141              		.loc 1 2759 0
 2142 0016 4E4B     		ldr	r3, .L206+8
 2143 0018 1B68     		ldr	r3, [r3]
 2144 001a 1B68     		ldr	r3, [r3]
 2145 001c 43B1     		cbz	r3, .L184
 2146              	.LBB191:
 2147              	.LBB192:
 200:FreeRTOS/ARM_CM3/portmacro.h ****         (
 2148              		.loc 2 200 0
 2149              		.syntax unified
 2150              	@ 200 "FreeRTOS/ARM_CM3/portmacro.h" 1
 2151 001e 4FF05003 			mov r3, #80												
 2152 0022 83F31188 		msr basepri, r3											
 2153 0026 BFF36F8F 		isb														
 2154 002a BFF34F8F 		dsb														
 2155              	
 2156              	@ 0 "" 2
 2157              	.LVL173:
 2158              		.thumb
 2159              		.syntax unified
 2160              	.L185:
 2161 002e FEE7     		b	.L185
 2162              	.L184:
 2163              	.LBE192:
 2164              	.LBE191:
2759:FreeRTOS/tasks.c ****         }
 2165              		.loc 1 2759 0 discriminator 2
 2166 0030 474A     		ldr	r2, .L206+8
 2167 0032 1168     		ldr	r1, [r2]
 2168              	.LVL174:
 2169 0034 474B     		ldr	r3, .L206+12
 2170 0036 1868     		ldr	r0, [r3]
 2171 0038 1060     		str	r0, [r2]
 2172 003a 1960     		str	r1, [r3]
 2173 003c 464A     		ldr	r2, .L206+16
 2174 003e 1368     		ldr	r3, [r2]
 2175 0040 0133     		adds	r3, r3, #1
 2176 0042 1360     		str	r3, [r2]
 2177 0044 FFF7FEFF 		bl	prvResetNextTaskUnblockTime
 2178              	.LVL175:
 2179              	.L183:
 2180              	.LBE190:
2770:FreeRTOS/tasks.c ****         {
 2181              		.loc 1 2770 0
 2182 0048 444B     		ldr	r3, .L206+20
 2183 004a 1B68     		ldr	r3, [r3]
 2184 004c A342     		cmp	r3, r4
 2185 004e 65D9     		bls	.L197
 2186              	.LBE189:
2740:FreeRTOS/tasks.c **** 
 2187              		.loc 1 2740 0
 2188 0050 0020     		movs	r0, #0
 2189              	.LVL176:
 2190              	.L187:
 2191              	.LBB198:
ARM GAS  /tmp/ccrgBt0i.s 			page 142


2853:FreeRTOS/tasks.c ****                 {
 2192              		.loc 1 2853 0
 2193 0052 434B     		ldr	r3, .L206+24
 2194 0054 1B68     		ldr	r3, [r3]
 2195 0056 DB6A     		ldr	r3, [r3, #44]
 2196 0058 03EB8303 		add	r3, r3, r3, lsl #2
 2197 005c 9A00     		lsls	r2, r3, #2
 2198 005e 414B     		ldr	r3, .L206+28
 2199 0060 9B58     		ldr	r3, [r3, r2]
 2200 0062 012B     		cmp	r3, #1
 2201 0064 00D9     		bls	.L195
2855:FreeRTOS/tasks.c ****                 }
 2202              		.loc 1 2855 0
 2203 0066 0120     		movs	r0, #1
 2204              	.LVL177:
 2205              	.L195:
2881:FreeRTOS/tasks.c ****                 {
 2206              		.loc 1 2881 0
 2207 0068 3F4B     		ldr	r3, .L206+32
 2208 006a 1B68     		ldr	r3, [r3]
 2209 006c 002B     		cmp	r3, #0
 2210 006e 6AD0     		beq	.L181
2883:FreeRTOS/tasks.c ****                 }
 2211              		.loc 1 2883 0
 2212 0070 0120     		movs	r0, #1
 2213              	.LVL178:
 2214              	.LBE198:
2905:FreeRTOS/tasks.c **** }
 2215              		.loc 1 2905 0
 2216 0072 68E0     		b	.L181
 2217              	.LVL179:
 2218              	.L198:
 2219              	.LBB199:
2836:FreeRTOS/tasks.c ****                             }
 2220              		.loc 1 2836 0
 2221 0074 0120     		movs	r0, #1
 2222              	.LVL180:
 2223              	.L186:
2774:FreeRTOS/tasks.c ****                 {
 2224              		.loc 1 2774 0
 2225 0076 364B     		ldr	r3, .L206+8
 2226 0078 1B68     		ldr	r3, [r3]
 2227 007a 1B68     		ldr	r3, [r3]
 2228 007c 002B     		cmp	r3, #0
 2229 007e 4FD0     		beq	.L202
2790:FreeRTOS/tasks.c ****                     xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 2230              		.loc 1 2790 0
 2231 0080 334B     		ldr	r3, .L206+8
 2232 0082 1B68     		ldr	r3, [r3]
 2233 0084 DB68     		ldr	r3, [r3, #12]
 2234 0086 DB68     		ldr	r3, [r3, #12]
 2235              	.LVL181:
2791:FreeRTOS/tasks.c **** 
 2236              		.loc 1 2791 0
 2237 0088 5A68     		ldr	r2, [r3, #4]
 2238              	.LVL182:
2793:FreeRTOS/tasks.c ****                     {
ARM GAS  /tmp/ccrgBt0i.s 			page 143


 2239              		.loc 1 2793 0
 2240 008a 9442     		cmp	r4, r2
 2241 008c 4DD3     		bcc	.L203
 2242              	.LBB193:
2809:FreeRTOS/tasks.c **** 
 2243              		.loc 1 2809 0
 2244 008e 5A69     		ldr	r2, [r3, #20]
 2245              	.LVL183:
 2246 0090 9968     		ldr	r1, [r3, #8]
 2247 0092 DD68     		ldr	r5, [r3, #12]
 2248 0094 8D60     		str	r5, [r1, #8]
 2249              	.LVL184:
 2250 0096 D968     		ldr	r1, [r3, #12]
 2251 0098 9D68     		ldr	r5, [r3, #8]
 2252 009a 4D60     		str	r5, [r1, #4]
 2253 009c 5168     		ldr	r1, [r2, #4]
 2254 009e 1E1D     		adds	r6, r3, #4
 2255 00a0 B142     		cmp	r1, r6
 2256 00a2 45D0     		beq	.L204
 2257              	.L190:
2809:FreeRTOS/tasks.c **** 
 2258              		.loc 1 2809 0 is_stmt 0 discriminator 3
 2259 00a4 0021     		movs	r1, #0
 2260 00a6 5961     		str	r1, [r3, #20]
 2261 00a8 1168     		ldr	r1, [r2]
 2262 00aa 0139     		subs	r1, r1, #1
 2263 00ac 1160     		str	r1, [r2]
 2264              	.LBE193:
2813:FreeRTOS/tasks.c ****                     {
 2265              		.loc 1 2813 0 is_stmt 1 discriminator 3
 2266 00ae 9A6A     		ldr	r2, [r3, #40]
 2267              	.LVL185:
 2268 00b0 7AB1     		cbz	r2, .L191
 2269              	.LVL186:
 2270              	.LBB194:
2815:FreeRTOS/tasks.c ****                     }
 2271              		.loc 1 2815 0
 2272 00b2 D969     		ldr	r1, [r3, #28]
 2273 00b4 1D6A     		ldr	r5, [r3, #32]
 2274 00b6 8D60     		str	r5, [r1, #8]
 2275 00b8 196A     		ldr	r1, [r3, #32]
 2276 00ba DD69     		ldr	r5, [r3, #28]
 2277 00bc 4D60     		str	r5, [r1, #4]
 2278 00be 5568     		ldr	r5, [r2, #4]
 2279 00c0 03F11801 		add	r1, r3, #24
 2280 00c4 8D42     		cmp	r5, r1
 2281 00c6 36D0     		beq	.L205
 2282              	.L192:
2815:FreeRTOS/tasks.c ****                     }
 2283              		.loc 1 2815 0 is_stmt 0 discriminator 3
 2284 00c8 0021     		movs	r1, #0
 2285 00ca 9962     		str	r1, [r3, #40]
 2286 00cc 1168     		ldr	r1, [r2]
 2287 00ce 0139     		subs	r1, r1, #1
 2288 00d0 1160     		str	r1, [r2]
 2289              	.LVL187:
 2290              	.L191:
ARM GAS  /tmp/ccrgBt0i.s 			page 144


 2291              	.LBE194:
2824:FreeRTOS/tasks.c **** 
 2292              		.loc 1 2824 0 is_stmt 1
 2293 00d2 DA6A     		ldr	r2, [r3, #44]
 2294 00d4 0121     		movs	r1, #1
 2295 00d6 9140     		lsls	r1, r1, r2
 2296 00d8 244D     		ldr	r5, .L206+36
 2297 00da 2F68     		ldr	r7, [r5]
 2298 00dc 3943     		orrs	r1, r1, r7
 2299 00de 2960     		str	r1, [r5]
 2300              	.LBB195:
 2301 00e0 2049     		ldr	r1, .L206+28
 2302 00e2 02EB8202 		add	r2, r2, r2, lsl #2
 2303 00e6 9500     		lsls	r5, r2, #2
 2304 00e8 0D44     		add	r5, r5, r1
 2305 00ea 6A68     		ldr	r2, [r5, #4]
 2306              	.LVL188:
 2307 00ec 9A60     		str	r2, [r3, #8]
 2308 00ee 9568     		ldr	r5, [r2, #8]
 2309 00f0 DD60     		str	r5, [r3, #12]
 2310 00f2 9568     		ldr	r5, [r2, #8]
 2311 00f4 6E60     		str	r6, [r5, #4]
 2312 00f6 9660     		str	r6, [r2, #8]
 2313 00f8 DE6A     		ldr	r6, [r3, #44]
 2314 00fa B200     		lsls	r2, r6, #2
 2315              	.LVL189:
 2316 00fc 9719     		adds	r7, r2, r6
 2317 00fe BD00     		lsls	r5, r7, #2
 2318 0100 4F19     		adds	r7, r1, r5
 2319 0102 5F61     		str	r7, [r3, #20]
 2320 0104 4D59     		ldr	r5, [r1, r5]
 2321 0106 0135     		adds	r5, r5, #1
 2322 0108 3244     		add	r2, r2, r6
 2323 010a 9600     		lsls	r6, r2, #2
 2324 010c 8D51     		str	r5, [r1, r6]
 2325              	.LBE195:
2834:FreeRTOS/tasks.c ****                             {
 2326              		.loc 1 2834 0
 2327 010e DA6A     		ldr	r2, [r3, #44]
 2328 0110 134B     		ldr	r3, .L206+24
 2329              	.LVL190:
 2330 0112 1B68     		ldr	r3, [r3]
 2331 0114 DB6A     		ldr	r3, [r3, #44]
 2332 0116 9A42     		cmp	r2, r3
 2333 0118 ACD2     		bcs	.L198
 2334 011a ACE7     		b	.L186
 2335              	.LVL191:
 2336              	.L197:
 2337              	.LBE199:
2740:FreeRTOS/tasks.c **** 
 2338              		.loc 1 2740 0
 2339 011c 0020     		movs	r0, #0
 2340 011e AAE7     		b	.L186
 2341              	.LVL192:
 2342              	.L202:
 2343              	.LBB200:
2781:FreeRTOS/tasks.c ****                     break;
ARM GAS  /tmp/ccrgBt0i.s 			page 145


 2344              		.loc 1 2781 0
 2345 0120 0E4B     		ldr	r3, .L206+20
 2346 0122 4FF0FF32 		mov	r2, #-1
 2347 0126 1A60     		str	r2, [r3]
2782:FreeRTOS/tasks.c ****                 }
 2348              		.loc 1 2782 0
 2349 0128 93E7     		b	.L187
 2350              	.LVL193:
 2351              	.L203:
2800:FreeRTOS/tasks.c ****                         break; /*lint !e9011 Code structure here is deemed easier to understand wit
 2352              		.loc 1 2800 0
 2353 012a 0C4B     		ldr	r3, .L206+20
 2354              	.LVL194:
 2355 012c 1A60     		str	r2, [r3]
2801:FreeRTOS/tasks.c ****                     }
 2356              		.loc 1 2801 0
 2357 012e 90E7     		b	.L187
 2358              	.LVL195:
 2359              	.L204:
 2360              	.LBB196:
2809:FreeRTOS/tasks.c **** 
 2361              		.loc 1 2809 0 discriminator 1
 2362 0130 D968     		ldr	r1, [r3, #12]
 2363 0132 5160     		str	r1, [r2, #4]
 2364 0134 B6E7     		b	.L190
 2365              	.LVL196:
 2366              	.L205:
 2367              	.LBE196:
 2368              	.LBB197:
2815:FreeRTOS/tasks.c ****                     }
 2369              		.loc 1 2815 0 discriminator 1
 2370 0136 196A     		ldr	r1, [r3, #32]
 2371 0138 5160     		str	r1, [r2, #4]
 2372 013a C5E7     		b	.L192
 2373              	.LVL197:
 2374              	.L182:
 2375              	.LBE197:
 2376              	.LBE200:
2894:FreeRTOS/tasks.c **** 
 2377              		.loc 1 2894 0
 2378 013c 0C4A     		ldr	r2, .L206+40
 2379 013e 1368     		ldr	r3, [r2]
 2380 0140 0133     		adds	r3, r3, #1
 2381 0142 1360     		str	r3, [r2]
2740:FreeRTOS/tasks.c **** 
 2382              		.loc 1 2740 0
 2383 0144 0020     		movs	r0, #0
 2384              	.LVL198:
 2385              	.L181:
2906:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 2386              		.loc 1 2906 0
 2387 0146 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 2388              	.L207:
 2389              		.align	2
 2390              	.L206:
 2391 0148 00000000 		.word	.LANCHOR16
 2392 014c 00000000 		.word	.LANCHOR15
ARM GAS  /tmp/ccrgBt0i.s 			page 146


 2393 0150 00000000 		.word	.LANCHOR2
 2394 0154 00000000 		.word	.LANCHOR8
 2395 0158 00000000 		.word	.LANCHOR20
 2396 015c 00000000 		.word	.LANCHOR3
 2397 0160 00000000 		.word	.LANCHOR10
 2398 0164 00000000 		.word	.LANCHOR4
 2399 0168 00000000 		.word	.LANCHOR17
 2400 016c 00000000 		.word	.LANCHOR13
 2401 0170 00000000 		.word	.LANCHOR21
 2402              		.cfi_endproc
 2403              	.LFE27:
 2405              		.section	.text.xTaskResumeAll,"ax",%progbits
 2406              		.align	1
 2407              		.global	xTaskResumeAll
 2408              		.syntax unified
 2409              		.thumb
 2410              		.thumb_func
 2411              		.fpu softvfp
 2413              	xTaskResumeAll:
 2414              	.LFB21:
2221:FreeRTOS/tasks.c ****     TCB_t * pxTCB = NULL;
 2415              		.loc 1 2221 0
 2416              		.cfi_startproc
 2417              		@ args = 0, pretend = 0, frame = 0
 2418              		@ frame_needed = 0, uses_anonymous_args = 0
 2419 0000 38B5     		push	{r3, r4, r5, lr}
 2420              	.LCFI25:
 2421              		.cfi_def_cfa_offset 16
 2422              		.cfi_offset 3, -16
 2423              		.cfi_offset 4, -12
 2424              		.cfi_offset 5, -8
 2425              		.cfi_offset 14, -4
 2426              	.LVL199:
2227:FreeRTOS/tasks.c **** 
 2427              		.loc 1 2227 0
 2428 0002 4B4B     		ldr	r3, .L228
 2429 0004 1B68     		ldr	r3, [r3]
 2430 0006 43B9     		cbnz	r3, .L209
 2431              	.LBB201:
 2432              	.LBB202:
 200:FreeRTOS/ARM_CM3/portmacro.h ****         (
 2433              		.loc 2 200 0
 2434              		.syntax unified
 2435              	@ 200 "FreeRTOS/ARM_CM3/portmacro.h" 1
 2436 0008 4FF05003 			mov r3, #80												
 2437 000c 83F31188 		msr basepri, r3											
 2438 0010 BFF36F8F 		isb														
 2439 0014 BFF34F8F 		dsb														
 2440              	
 2441              	@ 0 "" 2
 2442              	.LVL200:
 2443              		.thumb
 2444              		.syntax unified
 2445              	.L210:
 2446 0018 FEE7     		b	.L210
 2447              	.L209:
 2448              	.LBE202:
ARM GAS  /tmp/ccrgBt0i.s 			page 147


 2449              	.LBE201:
2234:FreeRTOS/tasks.c ****     {
 2450              		.loc 1 2234 0
 2451 001a FFF7FEFF 		bl	vPortEnterCritical
 2452              	.LVL201:
2236:FreeRTOS/tasks.c **** 
 2453              		.loc 1 2236 0
 2454 001e 444B     		ldr	r3, .L228
 2455 0020 1A68     		ldr	r2, [r3]
 2456 0022 013A     		subs	r2, r2, #1
 2457 0024 1A60     		str	r2, [r3]
2238:FreeRTOS/tasks.c ****         {
 2458              		.loc 1 2238 0
 2459 0026 1B68     		ldr	r3, [r3]
 2460 0028 002B     		cmp	r3, #0
 2461 002a 7CD1     		bne	.L221
2240:FreeRTOS/tasks.c ****             {
 2462              		.loc 1 2240 0
 2463 002c 414B     		ldr	r3, .L228+4
 2464 002e 1B68     		ldr	r3, [r3]
 2465 0030 53B9     		cbnz	r3, .L222
2223:FreeRTOS/tasks.c **** 
 2466              		.loc 1 2223 0
 2467 0032 0024     		movs	r4, #0
 2468              	.LVL202:
 2469              	.L211:
2326:FreeRTOS/tasks.c **** 
 2470              		.loc 1 2326 0
 2471 0034 FFF7FEFF 		bl	vPortExitCritical
 2472              	.LVL203:
2329:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 2473              		.loc 1 2329 0
 2474 0038 2046     		mov	r0, r4
 2475 003a 38BD     		pop	{r3, r4, r5, pc}
 2476              	.LVL204:
 2477              	.L226:
 2478              	.LBB203:
2247:FreeRTOS/tasks.c ****                     portMEMORY_BARRIER();
 2479              		.loc 1 2247 0 discriminator 1
 2480 003c 196A     		ldr	r1, [r3, #32]
 2481 003e 5160     		str	r1, [r2, #4]
 2482 0040 16E0     		b	.L213
 2483              	.LVL205:
 2484              	.L227:
 2485              	.LBE203:
 2486              	.LBB204:
2249:FreeRTOS/tasks.c ****                     prvAddTaskToReadyList( pxTCB );
 2487              		.loc 1 2249 0 discriminator 1
 2488 0042 D968     		ldr	r1, [r3, #12]
 2489 0044 5160     		str	r1, [r2, #4]
 2490 0046 23E0     		b	.L214
 2491              	.LVL206:
 2492              	.L222:
 2493              	.LBE204:
2222:FreeRTOS/tasks.c ****     BaseType_t xAlreadyYielded = pdFALSE;
 2494              		.loc 1 2222 0
 2495 0048 0023     		movs	r3, #0
ARM GAS  /tmp/ccrgBt0i.s 			page 148


 2496              	.LVL207:
 2497              	.L212:
2244:FreeRTOS/tasks.c ****                 {
 2498              		.loc 1 2244 0
 2499 004a 3B4A     		ldr	r2, .L228+8
 2500 004c 1268     		ldr	r2, [r2]
 2501 004e 002A     		cmp	r2, #0
 2502 0050 4BD0     		beq	.L225
2246:FreeRTOS/tasks.c ****                     listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
 2503              		.loc 1 2246 0
 2504 0052 394B     		ldr	r3, .L228+8
 2505              	.LVL208:
 2506 0054 DB68     		ldr	r3, [r3, #12]
 2507 0056 DB68     		ldr	r3, [r3, #12]
 2508              	.LVL209:
 2509              	.LBB205:
2247:FreeRTOS/tasks.c ****                     portMEMORY_BARRIER();
 2510              		.loc 1 2247 0
 2511 0058 9A6A     		ldr	r2, [r3, #40]
 2512              	.LVL210:
 2513 005a D969     		ldr	r1, [r3, #28]
 2514 005c 186A     		ldr	r0, [r3, #32]
 2515 005e 8860     		str	r0, [r1, #8]
 2516 0060 196A     		ldr	r1, [r3, #32]
 2517 0062 D869     		ldr	r0, [r3, #28]
 2518 0064 4860     		str	r0, [r1, #4]
 2519 0066 5068     		ldr	r0, [r2, #4]
 2520 0068 03F11801 		add	r1, r3, #24
 2521 006c 8842     		cmp	r0, r1
 2522 006e E5D0     		beq	.L226
 2523              	.L213:
2247:FreeRTOS/tasks.c ****                     portMEMORY_BARRIER();
 2524              		.loc 1 2247 0 is_stmt 0 discriminator 3
 2525 0070 0021     		movs	r1, #0
 2526 0072 9962     		str	r1, [r3, #40]
 2527 0074 1168     		ldr	r1, [r2]
 2528 0076 0139     		subs	r1, r1, #1
 2529 0078 1160     		str	r1, [r2]
 2530              	.LBE205:
2248:FreeRTOS/tasks.c ****                     listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
 2531              		.loc 1 2248 0 is_stmt 1 discriminator 3
 2532              	.LBB206:
2249:FreeRTOS/tasks.c ****                     prvAddTaskToReadyList( pxTCB );
 2533              		.loc 1 2249 0 discriminator 3
 2534 007a 5A69     		ldr	r2, [r3, #20]
 2535              	.LVL211:
 2536 007c 9968     		ldr	r1, [r3, #8]
 2537 007e D868     		ldr	r0, [r3, #12]
 2538 0080 8860     		str	r0, [r1, #8]
 2539 0082 D968     		ldr	r1, [r3, #12]
 2540 0084 9868     		ldr	r0, [r3, #8]
 2541 0086 4860     		str	r0, [r1, #4]
 2542 0088 5168     		ldr	r1, [r2, #4]
 2543 008a 1C1D     		adds	r4, r3, #4
 2544 008c A142     		cmp	r1, r4
 2545 008e D8D0     		beq	.L227
 2546              	.L214:
ARM GAS  /tmp/ccrgBt0i.s 			page 149


 2547 0090 0021     		movs	r1, #0
 2548 0092 5961     		str	r1, [r3, #20]
 2549 0094 1168     		ldr	r1, [r2]
 2550 0096 0139     		subs	r1, r1, #1
 2551 0098 1160     		str	r1, [r2]
 2552              	.LBE206:
2250:FreeRTOS/tasks.c **** 
 2553              		.loc 1 2250 0 discriminator 3
 2554 009a DA6A     		ldr	r2, [r3, #44]
 2555              	.LVL212:
 2556 009c 0121     		movs	r1, #1
 2557 009e 9140     		lsls	r1, r1, r2
 2558 00a0 2648     		ldr	r0, .L228+12
 2559 00a2 0568     		ldr	r5, [r0]
 2560 00a4 2943     		orrs	r1, r1, r5
 2561 00a6 0160     		str	r1, [r0]
 2562              	.LBB207:
 2563 00a8 2549     		ldr	r1, .L228+16
 2564 00aa 02EB8202 		add	r2, r2, r2, lsl #2
 2565 00ae 9000     		lsls	r0, r2, #2
 2566 00b0 0844     		add	r0, r0, r1
 2567 00b2 4268     		ldr	r2, [r0, #4]
 2568              	.LVL213:
 2569 00b4 9A60     		str	r2, [r3, #8]
 2570 00b6 9068     		ldr	r0, [r2, #8]
 2571 00b8 D860     		str	r0, [r3, #12]
 2572 00ba 9068     		ldr	r0, [r2, #8]
 2573 00bc 4460     		str	r4, [r0, #4]
 2574 00be 9460     		str	r4, [r2, #8]
 2575 00c0 DC6A     		ldr	r4, [r3, #44]
 2576 00c2 A200     		lsls	r2, r4, #2
 2577              	.LVL214:
 2578 00c4 1519     		adds	r5, r2, r4
 2579 00c6 A800     		lsls	r0, r5, #2
 2580 00c8 0D18     		adds	r5, r1, r0
 2581 00ca 5D61     		str	r5, [r3, #20]
 2582 00cc 0858     		ldr	r0, [r1, r0]
 2583 00ce 0130     		adds	r0, r0, #1
 2584 00d0 2244     		add	r2, r2, r4
 2585 00d2 9400     		lsls	r4, r2, #2
 2586 00d4 0851     		str	r0, [r1, r4]
 2587              	.LBE207:
2254:FreeRTOS/tasks.c ****                     {
 2588              		.loc 1 2254 0 discriminator 3
 2589 00d6 D96A     		ldr	r1, [r3, #44]
 2590 00d8 1A4A     		ldr	r2, .L228+20
 2591 00da 1268     		ldr	r2, [r2]
 2592 00dc D26A     		ldr	r2, [r2, #44]
 2593 00de 9142     		cmp	r1, r2
 2594 00e0 B3D3     		bcc	.L212
2256:FreeRTOS/tasks.c ****                     }
 2595              		.loc 1 2256 0
 2596 00e2 194A     		ldr	r2, .L228+24
 2597 00e4 0121     		movs	r1, #1
 2598 00e6 1160     		str	r1, [r2]
 2599 00e8 AFE7     		b	.L212
 2600              	.L225:
ARM GAS  /tmp/ccrgBt0i.s 			page 150


2264:FreeRTOS/tasks.c ****                 {
 2601              		.loc 1 2264 0
 2602 00ea 0BB1     		cbz	r3, .L217
2272:FreeRTOS/tasks.c ****                 }
 2603              		.loc 1 2272 0
 2604 00ec FFF7FEFF 		bl	prvResetNextTaskUnblockTime
 2605              	.LVL215:
 2606              	.L217:
 2607              	.LBB208:
2280:FreeRTOS/tasks.c **** 
 2608              		.loc 1 2280 0
 2609 00f0 164B     		ldr	r3, .L228+28
 2610 00f2 1C68     		ldr	r4, [r3]
 2611              	.LVL216:
2282:FreeRTOS/tasks.c ****                     {
 2612              		.loc 1 2282 0
 2613 00f4 54B1     		cbz	r4, .L218
 2614              	.L220:
2286:FreeRTOS/tasks.c ****                             {
 2615              		.loc 1 2286 0
 2616 00f6 FFF7FEFF 		bl	xTaskIncrementTick
 2617              	.LVL217:
 2618 00fa 10B1     		cbz	r0, .L219
2288:FreeRTOS/tasks.c ****                             }
 2619              		.loc 1 2288 0
 2620 00fc 124B     		ldr	r3, .L228+24
 2621 00fe 0122     		movs	r2, #1
 2622 0100 1A60     		str	r2, [r3]
 2623              	.L219:
 2624              	.LVL218:
2296:FreeRTOS/tasks.c **** 
 2625              		.loc 1 2296 0
 2626 0102 013C     		subs	r4, r4, #1
 2627              	.LVL219:
 2628 0104 F7D1     		bne	.L220
2298:FreeRTOS/tasks.c ****                     }
 2629              		.loc 1 2298 0
 2630 0106 114B     		ldr	r3, .L228+28
 2631 0108 0022     		movs	r2, #0
 2632 010a 1A60     		str	r2, [r3]
 2633              	.L218:
 2634              	.LBE208:
2306:FreeRTOS/tasks.c ****                 {
 2635              		.loc 1 2306 0
 2636 010c 0E4B     		ldr	r3, .L228+24
 2637 010e 1B68     		ldr	r3, [r3]
 2638 0110 5BB1     		cbz	r3, .L223
 2639              	.LVL220:
2313:FreeRTOS/tasks.c ****                 }
 2640              		.loc 1 2313 0
 2641 0112 0F4B     		ldr	r3, .L228+32
 2642 0114 4FF08052 		mov	r2, #268435456
 2643 0118 1A60     		str	r2, [r3]
 2644              		.syntax unified
 2645              	@ 2313 "FreeRTOS/tasks.c" 1
 2646 011a BFF34F8F 		dsb
 2647              	@ 0 "" 2
ARM GAS  /tmp/ccrgBt0i.s 			page 151


 2648              	@ 2313 "FreeRTOS/tasks.c" 1
 2649 011e BFF36F8F 		isb
 2650              	@ 0 "" 2
2310:FreeRTOS/tasks.c ****                         }
 2651              		.loc 1 2310 0
 2652              		.thumb
 2653              		.syntax unified
 2654 0122 0124     		movs	r4, #1
 2655              	.LVL221:
 2656 0124 86E7     		b	.L211
 2657              	.LVL222:
 2658              	.L221:
2223:FreeRTOS/tasks.c **** 
 2659              		.loc 1 2223 0
 2660 0126 0024     		movs	r4, #0
 2661 0128 84E7     		b	.L211
 2662              	.LVL223:
 2663              	.L223:
 2664 012a 0024     		movs	r4, #0
 2665              	.LVL224:
 2666 012c 82E7     		b	.L211
 2667              	.L229:
 2668 012e 00BF     		.align	2
 2669              	.L228:
 2670 0130 00000000 		.word	.LANCHOR16
 2671 0134 00000000 		.word	.LANCHOR9
 2672 0138 00000000 		.word	.LANCHOR1
 2673 013c 00000000 		.word	.LANCHOR13
 2674 0140 00000000 		.word	.LANCHOR4
 2675 0144 00000000 		.word	.LANCHOR10
 2676 0148 00000000 		.word	.LANCHOR17
 2677 014c 00000000 		.word	.LANCHOR21
 2678 0150 04ED00E0 		.word	-536810236
 2679              		.cfi_endproc
 2680              	.LFE21:
 2682              		.section	.text.xTaskDelayUntil,"ax",%progbits
 2683              		.align	1
 2684              		.global	xTaskDelayUntil
 2685              		.syntax unified
 2686              		.thumb
 2687              		.thumb_func
 2688              		.fpu softvfp
 2690              	xTaskDelayUntil:
 2691              	.LFB9:
1261:FreeRTOS/tasks.c ****         TickType_t xTimeToWake;
 2692              		.loc 1 1261 0
 2693              		.cfi_startproc
 2694              		@ args = 0, pretend = 0, frame = 0
 2695              		@ frame_needed = 0, uses_anonymous_args = 0
 2696              	.LVL225:
 2697 0000 38B5     		push	{r3, r4, r5, lr}
 2698              	.LCFI26:
 2699              		.cfi_def_cfa_offset 16
 2700              		.cfi_offset 3, -16
 2701              		.cfi_offset 4, -12
 2702              		.cfi_offset 5, -8
 2703              		.cfi_offset 14, -4
ARM GAS  /tmp/ccrgBt0i.s 			page 152


 2704              	.LVL226:
1265:FreeRTOS/tasks.c ****         configASSERT( ( xTimeIncrement > 0U ) );
 2705              		.loc 1 1265 0
 2706 0002 50B1     		cbz	r0, .L246
 2707 0004 0546     		mov	r5, r0
1266:FreeRTOS/tasks.c ****         configASSERT( uxSchedulerSuspended == 0 );
 2708              		.loc 1 1266 0
 2709 0006 89B9     		cbnz	r1, .L233
 2710              	.LBB209:
 2711              	.LBB210:
 200:FreeRTOS/ARM_CM3/portmacro.h ****         (
 2712              		.loc 2 200 0
 2713              		.syntax unified
 2714              	@ 200 "FreeRTOS/ARM_CM3/portmacro.h" 1
 2715 0008 4FF05003 			mov r3, #80												
 2716 000c 83F31188 		msr basepri, r3											
 2717 0010 BFF36F8F 		isb														
 2718 0014 BFF34F8F 		dsb														
 2719              	
 2720              	@ 0 "" 2
 2721              	.LVL227:
 2722              		.thumb
 2723              		.syntax unified
 2724              	.L234:
 2725 0018 FEE7     		b	.L234
 2726              	.L246:
 2727              	.LBE210:
 2728              	.LBE209:
 2729              	.LBB211:
 2730              	.LBB212:
 2731              		.syntax unified
 2732              	@ 200 "FreeRTOS/ARM_CM3/portmacro.h" 1
 2733 001a 4FF05003 			mov r3, #80												
 2734 001e 83F31188 		msr basepri, r3											
 2735 0022 BFF36F8F 		isb														
 2736 0026 BFF34F8F 		dsb														
 2737              	
 2738              	@ 0 "" 2
 2739              	.LVL228:
 2740              		.thumb
 2741              		.syntax unified
 2742              	.L232:
 2743 002a FEE7     		b	.L232
 2744              	.L233:
 2745              	.LBE212:
 2746              	.LBE211:
1267:FreeRTOS/tasks.c **** 
 2747              		.loc 1 1267 0
 2748 002c 1D4B     		ldr	r3, .L247
 2749 002e 1B68     		ldr	r3, [r3]
 2750 0030 43B1     		cbz	r3, .L235
 2751              	.LBB213:
 2752              	.LBB214:
 200:FreeRTOS/ARM_CM3/portmacro.h ****         (
 2753              		.loc 2 200 0
 2754              		.syntax unified
 2755              	@ 200 "FreeRTOS/ARM_CM3/portmacro.h" 1
ARM GAS  /tmp/ccrgBt0i.s 			page 153


 2756 0032 4FF05003 			mov r3, #80												
 2757 0036 83F31188 		msr basepri, r3											
 2758 003a BFF36F8F 		isb														
 2759 003e BFF34F8F 		dsb														
 2760              	
 2761              	@ 0 "" 2
 2762              	.LVL229:
 2763              		.thumb
 2764              		.syntax unified
 2765              	.L236:
 2766 0042 FEE7     		b	.L236
 2767              	.L235:
 2768 0044 0C46     		mov	r4, r1
 2769              	.LBE214:
 2770              	.LBE213:
1269:FreeRTOS/tasks.c ****         {
 2771              		.loc 1 1269 0
 2772 0046 FFF7FEFF 		bl	vTaskSuspendAll
 2773              	.LVL230:
 2774              	.LBB215:
1273:FreeRTOS/tasks.c **** 
 2775              		.loc 1 1273 0
 2776 004a 174B     		ldr	r3, .L247+4
 2777 004c 1868     		ldr	r0, [r3]
 2778              	.LVL231:
1276:FreeRTOS/tasks.c **** 
 2779              		.loc 1 1276 0
 2780 004e 2A68     		ldr	r2, [r5]
 2781 0050 1444     		add	r4, r4, r2
 2782              	.LVL232:
1278:FreeRTOS/tasks.c ****             {
 2783              		.loc 1 1278 0
 2784 0052 8242     		cmp	r2, r0
 2785 0054 1CD9     		bls	.L237
1285:FreeRTOS/tasks.c ****                 {
 2786              		.loc 1 1285 0
 2787 0056 A242     		cmp	r2, r4
 2788 0058 0ED8     		bhi	.L238
1310:FreeRTOS/tasks.c **** 
 2789              		.loc 1 1310 0
 2790 005a 2C60     		str	r4, [r5]
 2791              	.LBE215:
1263:FreeRTOS/tasks.c **** 
 2792              		.loc 1 1263 0
 2793 005c 0024     		movs	r4, #0
 2794              	.LVL233:
 2795              	.L239:
1325:FreeRTOS/tasks.c **** 
 2796              		.loc 1 1325 0
 2797 005e FFF7FEFF 		bl	xTaskResumeAll
 2798              	.LVL234:
1329:FreeRTOS/tasks.c ****         {
 2799              		.loc 1 1329 0
 2800 0062 38B9     		cbnz	r0, .L230
1331:FreeRTOS/tasks.c ****         }
 2801              		.loc 1 1331 0
 2802 0064 114B     		ldr	r3, .L247+8
ARM GAS  /tmp/ccrgBt0i.s 			page 154


 2803 0066 4FF08052 		mov	r2, #268435456
 2804 006a 1A60     		str	r2, [r3]
 2805              		.syntax unified
 2806              	@ 1331 "FreeRTOS/tasks.c" 1
 2807 006c BFF34F8F 		dsb
 2808              	@ 0 "" 2
 2809              	@ 1331 "FreeRTOS/tasks.c" 1
 2810 0070 BFF36F8F 		isb
 2811              	@ 0 "" 2
 2812              		.thumb
 2813              		.syntax unified
 2814              	.L230:
1339:FreeRTOS/tasks.c **** 
 2815              		.loc 1 1339 0
 2816 0074 2046     		mov	r0, r4
 2817              	.LVL235:
 2818 0076 38BD     		pop	{r3, r4, r5, pc}
 2819              	.LVL236:
 2820              	.L238:
 2821              	.LBB216:
1285:FreeRTOS/tasks.c ****                 {
 2822              		.loc 1 1285 0 discriminator 1
 2823 0078 A042     		cmp	r0, r4
 2824 007a 02D3     		bcc	.L240
1310:FreeRTOS/tasks.c **** 
 2825              		.loc 1 1310 0
 2826 007c 2C60     		str	r4, [r5]
 2827              	.LBE216:
1263:FreeRTOS/tasks.c **** 
 2828              		.loc 1 1263 0
 2829 007e 0024     		movs	r4, #0
 2830              	.LVL237:
 2831 0080 EDE7     		b	.L239
 2832              	.LVL238:
 2833              	.L240:
 2834              	.LBB217:
1310:FreeRTOS/tasks.c **** 
 2835              		.loc 1 1310 0
 2836 0082 2C60     		str	r4, [r5]
 2837              	.L241:
1318:FreeRTOS/tasks.c ****             }
 2838              		.loc 1 1318 0
 2839 0084 0021     		movs	r1, #0
 2840 0086 201A     		subs	r0, r4, r0
 2841              	.LVL239:
 2842 0088 FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
 2843              	.LVL240:
 2844 008c 0124     		movs	r4, #1
 2845              	.LVL241:
 2846 008e E6E7     		b	.L239
 2847              	.LVL242:
 2848              	.L237:
1299:FreeRTOS/tasks.c ****                 {
 2849              		.loc 1 1299 0
 2850 0090 A242     		cmp	r2, r4
 2851 0092 01D8     		bhi	.L242
1299:FreeRTOS/tasks.c ****                 {
ARM GAS  /tmp/ccrgBt0i.s 			page 155


 2852              		.loc 1 1299 0 is_stmt 0 discriminator 1
 2853 0094 A042     		cmp	r0, r4
 2854 0096 01D2     		bcs	.L243
 2855              	.L242:
 2856              	.LVL243:
1310:FreeRTOS/tasks.c **** 
 2857              		.loc 1 1310 0 is_stmt 1
 2858 0098 2C60     		str	r4, [r5]
 2859 009a F3E7     		b	.L241
 2860              	.LVL244:
 2861              	.L243:
 2862 009c 2C60     		str	r4, [r5]
 2863              	.LBE217:
1263:FreeRTOS/tasks.c **** 
 2864              		.loc 1 1263 0
 2865 009e 0024     		movs	r4, #0
 2866              	.LVL245:
 2867 00a0 DDE7     		b	.L239
 2868              	.L248:
 2869 00a2 00BF     		.align	2
 2870              	.L247:
 2871 00a4 00000000 		.word	.LANCHOR16
 2872 00a8 00000000 		.word	.LANCHOR15
 2873 00ac 04ED00E0 		.word	-536810236
 2874              		.cfi_endproc
 2875              	.LFE9:
 2877              		.section	.text.vTaskDelay,"ax",%progbits
 2878              		.align	1
 2879              		.global	vTaskDelay
 2880              		.syntax unified
 2881              		.thumb
 2882              		.thumb_func
 2883              		.fpu softvfp
 2885              	vTaskDelay:
 2886              	.LFB10:
1347:FreeRTOS/tasks.c ****         BaseType_t xAlreadyYielded = pdFALSE;
 2887              		.loc 1 1347 0
 2888              		.cfi_startproc
 2889              		@ args = 0, pretend = 0, frame = 0
 2890              		@ frame_needed = 0, uses_anonymous_args = 0
 2891              	.LVL246:
 2892 0000 10B5     		push	{r4, lr}
 2893              	.LCFI27:
 2894              		.cfi_def_cfa_offset 8
 2895              		.cfi_offset 4, -8
 2896              		.cfi_offset 14, -4
 2897              	.LVL247:
1351:FreeRTOS/tasks.c ****         {
 2898              		.loc 1 1351 0
 2899 0002 A8B1     		cbz	r0, .L250
 2900 0004 0446     		mov	r4, r0
1353:FreeRTOS/tasks.c ****             vTaskSuspendAll();
 2901              		.loc 1 1353 0
 2902 0006 0F4B     		ldr	r3, .L255
 2903 0008 1B68     		ldr	r3, [r3]
 2904 000a 43B1     		cbz	r3, .L251
 2905              	.LBB218:
ARM GAS  /tmp/ccrgBt0i.s 			page 156


 2906              	.LBB219:
 200:FreeRTOS/ARM_CM3/portmacro.h ****         (
 2907              		.loc 2 200 0
 2908              		.syntax unified
 2909              	@ 200 "FreeRTOS/ARM_CM3/portmacro.h" 1
 2910 000c 4FF05003 			mov r3, #80												
 2911 0010 83F31188 		msr basepri, r3											
 2912 0014 BFF36F8F 		isb														
 2913 0018 BFF34F8F 		dsb														
 2914              	
 2915              	@ 0 "" 2
 2916              	.LVL248:
 2917              		.thumb
 2918              		.syntax unified
 2919              	.L252:
 2920 001c FEE7     		b	.L252
 2921              	.L251:
 2922              	.LBE219:
 2923              	.LBE218:
1354:FreeRTOS/tasks.c ****             {
 2924              		.loc 1 1354 0
 2925 001e FFF7FEFF 		bl	vTaskSuspendAll
 2926              	.LVL249:
1365:FreeRTOS/tasks.c ****             }
 2927              		.loc 1 1365 0
 2928 0022 0021     		movs	r1, #0
 2929 0024 2046     		mov	r0, r4
 2930 0026 FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
 2931              	.LVL250:
1367:FreeRTOS/tasks.c ****         }
 2932              		.loc 1 1367 0
 2933 002a FFF7FEFF 		bl	xTaskResumeAll
 2934              	.LVL251:
1376:FreeRTOS/tasks.c ****         {
 2935              		.loc 1 1376 0
 2936 002e 38B9     		cbnz	r0, .L249
 2937              	.LVL252:
 2938              	.L250:
1378:FreeRTOS/tasks.c ****         }
 2939              		.loc 1 1378 0
 2940 0030 054B     		ldr	r3, .L255+4
 2941 0032 4FF08052 		mov	r2, #268435456
 2942 0036 1A60     		str	r2, [r3]
 2943              		.syntax unified
 2944              	@ 1378 "FreeRTOS/tasks.c" 1
 2945 0038 BFF34F8F 		dsb
 2946              	@ 0 "" 2
 2947              	@ 1378 "FreeRTOS/tasks.c" 1
 2948 003c BFF36F8F 		isb
 2949              	@ 0 "" 2
 2950              		.thumb
 2951              		.syntax unified
 2952              	.L249:
1384:FreeRTOS/tasks.c **** 
 2953              		.loc 1 1384 0
 2954 0040 10BD     		pop	{r4, pc}
 2955              	.L256:
ARM GAS  /tmp/ccrgBt0i.s 			page 157


 2956 0042 00BF     		.align	2
 2957              	.L255:
 2958 0044 00000000 		.word	.LANCHOR16
 2959 0048 04ED00E0 		.word	-536810236
 2960              		.cfi_endproc
 2961              	.LFE10:
 2963              		.section	.text.xTaskCatchUpTicks,"ax",%progbits
 2964              		.align	1
 2965              		.global	xTaskCatchUpTicks
 2966              		.syntax unified
 2967              		.thumb
 2968              		.thumb_func
 2969              		.fpu softvfp
 2971              	xTaskCatchUpTicks:
 2972              	.LFB26:
2639:FreeRTOS/tasks.c ****     BaseType_t xYieldOccurred;
 2973              		.loc 1 2639 0
 2974              		.cfi_startproc
 2975              		@ args = 0, pretend = 0, frame = 0
 2976              		@ frame_needed = 0, uses_anonymous_args = 0
 2977              	.LVL253:
2644:FreeRTOS/tasks.c **** 
 2978              		.loc 1 2644 0
 2979 0000 0B4B     		ldr	r3, .L262
 2980 0002 1B68     		ldr	r3, [r3]
 2981 0004 43B1     		cbz	r3, .L258
 2982              	.LBB220:
 2983              	.LBB221:
 200:FreeRTOS/ARM_CM3/portmacro.h ****         (
 2984              		.loc 2 200 0
 2985              		.syntax unified
 2986              	@ 200 "FreeRTOS/ARM_CM3/portmacro.h" 1
 2987 0006 4FF05003 			mov r3, #80												
 2988 000a 83F31188 		msr basepri, r3											
 2989 000e BFF36F8F 		isb														
 2990 0012 BFF34F8F 		dsb														
 2991              	
 2992              	@ 0 "" 2
 2993              	.LVL254:
 2994              		.thumb
 2995              		.syntax unified
 2996              	.L259:
 2997 0016 FEE7     		b	.L259
 2998              	.L258:
 2999              	.LBE221:
 3000              	.LBE220:
2639:FreeRTOS/tasks.c ****     BaseType_t xYieldOccurred;
 3001              		.loc 1 2639 0
 3002 0018 10B5     		push	{r4, lr}
 3003              	.LCFI28:
 3004              		.cfi_def_cfa_offset 8
 3005              		.cfi_offset 4, -8
 3006              		.cfi_offset 14, -4
 3007 001a 0446     		mov	r4, r0
2648:FreeRTOS/tasks.c ****     xPendedTicks += xTicksToCatchUp;
 3008              		.loc 1 2648 0
 3009 001c FFF7FEFF 		bl	vTaskSuspendAll
ARM GAS  /tmp/ccrgBt0i.s 			page 158


 3010              	.LVL255:
2649:FreeRTOS/tasks.c ****     xYieldOccurred = xTaskResumeAll();
 3011              		.loc 1 2649 0
 3012 0020 044A     		ldr	r2, .L262+4
 3013 0022 1368     		ldr	r3, [r2]
 3014 0024 2344     		add	r3, r3, r4
 3015 0026 1360     		str	r3, [r2]
2650:FreeRTOS/tasks.c **** 
 3016              		.loc 1 2650 0
 3017 0028 FFF7FEFF 		bl	xTaskResumeAll
 3018              	.LVL256:
2653:FreeRTOS/tasks.c **** /*----------------------------------------------------------*/
 3019              		.loc 1 2653 0
 3020 002c 10BD     		pop	{r4, pc}
 3021              	.LVL257:
 3022              	.L263:
 3023 002e 00BF     		.align	2
 3024              	.L262:
 3025 0030 00000000 		.word	.LANCHOR16
 3026 0034 00000000 		.word	.LANCHOR21
 3027              		.cfi_endproc
 3028              	.LFE26:
 3030              		.section	.text.vTaskSwitchContext,"ax",%progbits
 3031              		.align	1
 3032              		.global	vTaskSwitchContext
 3033              		.syntax unified
 3034              		.thumb
 3035              		.thumb_func
 3036              		.fpu softvfp
 3038              	vTaskSwitchContext:
 3039              	.LFB28:
3022:FreeRTOS/tasks.c ****     if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 3040              		.loc 1 3022 0
 3041              		.cfi_startproc
 3042              		@ args = 0, pretend = 0, frame = 0
 3043              		@ frame_needed = 0, uses_anonymous_args = 0
 3044              		@ link register save eliminated.
3023:FreeRTOS/tasks.c ****     {
 3045              		.loc 1 3023 0
 3046 0000 204B     		ldr	r3, .L274
 3047 0002 1B68     		ldr	r3, [r3]
 3048 0004 1BB1     		cbz	r3, .L265
3027:FreeRTOS/tasks.c ****     }
 3049              		.loc 1 3027 0
 3050 0006 204B     		ldr	r3, .L274+4
 3051 0008 0122     		movs	r2, #1
 3052 000a 1A60     		str	r2, [r3]
 3053 000c 7047     		bx	lr
 3054              	.L265:
3031:FreeRTOS/tasks.c ****         traceTASK_SWITCHED_OUT();
 3055              		.loc 1 3031 0
 3056 000e 1E4B     		ldr	r3, .L274+4
 3057 0010 0022     		movs	r2, #0
 3058 0012 1A60     		str	r2, [r3]
 3059              	.LBB222:
3074:FreeRTOS/tasks.c ****         traceTASK_SWITCHED_IN();
 3060              		.loc 1 3074 0
ARM GAS  /tmp/ccrgBt0i.s 			page 159


 3061 0014 1D4B     		ldr	r3, .L274+8
 3062 0016 1B68     		ldr	r3, [r3]
 3063              	.LVL258:
 3064              	.LBB223:
 3065              	.LBB224:
 136:FreeRTOS/ARM_CM3/portmacro.h **** 
 3066              		.loc 2 136 0
 3067              		.syntax unified
 3068              	@ 136 "FreeRTOS/ARM_CM3/portmacro.h" 1
 3069 0018 B3FA83F3 		clz r3, r3
 3070              	@ 0 "" 2
 3071              	.LVL259:
 3072              		.thumb
 3073              		.syntax unified
 3074 001c DBB2     		uxtb	r3, r3
 3075              	.LBE224:
 3076              	.LBE223:
3074:FreeRTOS/tasks.c ****         traceTASK_SWITCHED_IN();
 3077              		.loc 1 3074 0
 3078 001e C3F11F03 		rsb	r3, r3, #31
 3079              	.LVL260:
 3080 0022 03EB8301 		add	r1, r3, r3, lsl #2
 3081 0026 8A00     		lsls	r2, r1, #2
 3082 0028 1949     		ldr	r1, .L274+12
 3083 002a 8A58     		ldr	r2, [r1, r2]
 3084 002c 42B9     		cbnz	r2, .L267
 3085              	.LBB225:
 3086              	.LBB226:
 200:FreeRTOS/ARM_CM3/portmacro.h ****         (
 3087              		.loc 2 200 0
 3088              		.syntax unified
 3089              	@ 200 "FreeRTOS/ARM_CM3/portmacro.h" 1
 3090 002e 4FF05003 			mov r3, #80												
 3091 0032 83F31188 		msr basepri, r3											
 3092 0036 BFF36F8F 		isb														
 3093 003a BFF34F8F 		dsb														
 3094              	
 3095              	@ 0 "" 2
 3096              	.LVL261:
 3097              		.thumb
 3098              		.syntax unified
 3099              	.L268:
 3100 003e FEE7     		b	.L268
 3101              	.LVL262:
 3102              	.L267:
 3103              	.LBE226:
 3104              	.LBE225:
 3105              	.LBE222:
3022:FreeRTOS/tasks.c ****     if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 3106              		.loc 1 3022 0 discriminator 2
 3107 0040 10B4     		push	{r4}
 3108              	.LCFI29:
 3109              		.cfi_def_cfa_offset 4
 3110              		.cfi_offset 4, -4
 3111              	.LVL263:
 3112              	.LBB229:
 3113              	.LBB227:
ARM GAS  /tmp/ccrgBt0i.s 			page 160


3074:FreeRTOS/tasks.c ****         traceTASK_SWITCHED_IN();
 3114              		.loc 1 3074 0 discriminator 2
 3115 0042 1348     		ldr	r0, .L274+12
 3116 0044 9A00     		lsls	r2, r3, #2
 3117 0046 D418     		adds	r4, r2, r3
 3118 0048 A100     		lsls	r1, r4, #2
 3119 004a 0144     		add	r1, r1, r0
 3120 004c 4C68     		ldr	r4, [r1, #4]
 3121 004e 6468     		ldr	r4, [r4, #4]
 3122 0050 4C60     		str	r4, [r1, #4]
 3123 0052 1A44     		add	r2, r2, r3
 3124 0054 9100     		lsls	r1, r2, #2
 3125 0056 0831     		adds	r1, r1, #8
 3126 0058 0844     		add	r0, r0, r1
 3127 005a 8442     		cmp	r4, r0
 3128 005c 0AD0     		beq	.L273
 3129              	.L269:
3074:FreeRTOS/tasks.c ****         traceTASK_SWITCHED_IN();
 3130              		.loc 1 3074 0 is_stmt 0 discriminator 5
 3131 005e 03EB8303 		add	r3, r3, r3, lsl #2
 3132              	.LVL264:
 3133 0062 9A00     		lsls	r2, r3, #2
 3134 0064 0A4B     		ldr	r3, .L274+12
 3135 0066 1344     		add	r3, r3, r2
 3136 0068 5B68     		ldr	r3, [r3, #4]
 3137 006a DA68     		ldr	r2, [r3, #12]
 3138 006c 094B     		ldr	r3, .L274+16
 3139 006e 1A60     		str	r2, [r3]
 3140              	.LBE227:
 3141              	.LBE229:
3094:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 3142              		.loc 1 3094 0 is_stmt 1 discriminator 5
 3143 0070 10BC     		pop	{r4}
 3144              	.LCFI30:
 3145              		.cfi_remember_state
 3146              		.cfi_restore 4
 3147              		.cfi_def_cfa_offset 0
 3148 0072 7047     		bx	lr
 3149              	.LVL265:
 3150              	.L273:
 3151              	.LCFI31:
 3152              		.cfi_restore_state
 3153              	.LBB230:
 3154              	.LBB228:
3074:FreeRTOS/tasks.c ****         traceTASK_SWITCHED_IN();
 3155              		.loc 1 3074 0 discriminator 3
 3156 0074 6168     		ldr	r1, [r4, #4]
 3157 0076 0648     		ldr	r0, .L274+12
 3158 0078 1422     		movs	r2, #20
 3159 007a 02FB0302 		mla	r2, r2, r3, r0
 3160 007e 5160     		str	r1, [r2, #4]
 3161 0080 EDE7     		b	.L269
 3162              	.L275:
 3163 0082 00BF     		.align	2
 3164              	.L274:
 3165 0084 00000000 		.word	.LANCHOR16
 3166 0088 00000000 		.word	.LANCHOR17
ARM GAS  /tmp/ccrgBt0i.s 			page 161


 3167 008c 00000000 		.word	.LANCHOR13
 3168 0090 00000000 		.word	.LANCHOR4
 3169 0094 00000000 		.word	.LANCHOR10
 3170              	.LBE228:
 3171              	.LBE230:
 3172              		.cfi_endproc
 3173              	.LFE28:
 3175              		.section	.text.vTaskSuspend,"ax",%progbits
 3176              		.align	1
 3177              		.global	vTaskSuspend
 3178              		.syntax unified
 3179              		.thumb
 3180              		.thumb_func
 3181              		.fpu softvfp
 3183              	vTaskSuspend:
 3184              	.LFB14:
1717:FreeRTOS/tasks.c ****         TCB_t * pxTCB;
 3185              		.loc 1 1717 0
 3186              		.cfi_startproc
 3187              		@ args = 0, pretend = 0, frame = 0
 3188              		@ frame_needed = 0, uses_anonymous_args = 0
 3189              	.LVL266:
 3190 0000 38B5     		push	{r3, r4, r5, lr}
 3191              	.LCFI32:
 3192              		.cfi_def_cfa_offset 16
 3193              		.cfi_offset 3, -16
 3194              		.cfi_offset 4, -12
 3195              		.cfi_offset 5, -8
 3196              		.cfi_offset 14, -4
 3197 0002 0446     		mov	r4, r0
1720:FreeRTOS/tasks.c ****         {
 3198              		.loc 1 1720 0
 3199 0004 FFF7FEFF 		bl	vPortEnterCritical
 3200              	.LVL267:
1724:FreeRTOS/tasks.c **** 
 3201              		.loc 1 1724 0
 3202 0008 54B3     		cbz	r4, .L290
 3203              	.LVL268:
 3204              	.L277:
1730:FreeRTOS/tasks.c ****             {
 3205              		.loc 1 1730 0 discriminator 4
 3206 000a 251D     		adds	r5, r4, #4
 3207 000c 2846     		mov	r0, r5
 3208 000e FFF7FEFF 		bl	uxListRemove
 3209              	.LVL269:
 3210 0012 70B9     		cbnz	r0, .L278
1732:FreeRTOS/tasks.c ****             }
 3211              		.loc 1 1732 0
 3212 0014 E26A     		ldr	r2, [r4, #44]
 3213 0016 02EB8201 		add	r1, r2, r2, lsl #2
 3214 001a 8B00     		lsls	r3, r1, #2
 3215 001c 2E49     		ldr	r1, .L294
 3216 001e CB58     		ldr	r3, [r1, r3]
 3217 0020 3BB9     		cbnz	r3, .L278
1732:FreeRTOS/tasks.c ****             }
 3218              		.loc 1 1732 0 is_stmt 0 discriminator 1
 3219 0022 0123     		movs	r3, #1
ARM GAS  /tmp/ccrgBt0i.s 			page 162


 3220 0024 03FA02F2 		lsl	r2, r3, r2
 3221 0028 2C49     		ldr	r1, .L294+4
 3222 002a 0B68     		ldr	r3, [r1]
 3223 002c 23EA0203 		bic	r3, r3, r2
 3224 0030 0B60     		str	r3, [r1]
 3225              	.L278:
1740:FreeRTOS/tasks.c ****             {
 3226              		.loc 1 1740 0 is_stmt 1
 3227 0032 A36A     		ldr	r3, [r4, #40]
 3228 0034 1BB1     		cbz	r3, .L279
1742:FreeRTOS/tasks.c ****             }
 3229              		.loc 1 1742 0
 3230 0036 04F11800 		add	r0, r4, #24
 3231 003a FFF7FEFF 		bl	uxListRemove
 3232              	.LVL270:
 3233              	.L279:
1749:FreeRTOS/tasks.c **** 
 3234              		.loc 1 1749 0
 3235 003e 2946     		mov	r1, r5
 3236 0040 2748     		ldr	r0, .L294+8
 3237 0042 FFF7FEFF 		bl	vListInsertEnd
 3238              	.LVL271:
 3239              	.LBB231:
1755:FreeRTOS/tasks.c ****                     {
 3240              		.loc 1 1755 0
 3241 0046 0023     		movs	r3, #0
 3242              	.LVL272:
 3243              	.L280:
1755:FreeRTOS/tasks.c ****                     {
 3244              		.loc 1 1755 0 is_stmt 0 discriminator 1
 3245 0048 002B     		cmp	r3, #0
 3246 004a 0CDD     		ble	.L282
 3247              	.LBE231:
1767:FreeRTOS/tasks.c **** 
 3248              		.loc 1 1767 0 is_stmt 1
 3249 004c FFF7FEFF 		bl	vPortExitCritical
 3250              	.LVL273:
1769:FreeRTOS/tasks.c ****         {
 3251              		.loc 1 1769 0
 3252 0050 244B     		ldr	r3, .L294+12
 3253 0052 1B68     		ldr	r3, [r3]
 3254 0054 A3B9     		cbnz	r3, .L291
 3255              	.L283:
1784:FreeRTOS/tasks.c ****         {
 3256              		.loc 1 1784 0
 3257 0056 244B     		ldr	r3, .L294+16
 3258 0058 1B68     		ldr	r3, [r3]
 3259 005a A342     		cmp	r3, r4
 3260 005c 17D0     		beq	.L292
 3261              	.L276:
1815:FreeRTOS/tasks.c **** 
 3262              		.loc 1 1815 0
 3263 005e 38BD     		pop	{r3, r4, r5, pc}
 3264              	.LVL274:
 3265              	.L290:
1724:FreeRTOS/tasks.c **** 
 3266              		.loc 1 1724 0 discriminator 1
ARM GAS  /tmp/ccrgBt0i.s 			page 163


 3267 0060 214B     		ldr	r3, .L294+16
 3268 0062 1C68     		ldr	r4, [r3]
 3269              	.LVL275:
 3270 0064 D1E7     		b	.L277
 3271              	.LVL276:
 3272              	.L282:
 3273              	.LBB232:
1757:FreeRTOS/tasks.c ****                         {
 3274              		.loc 1 1757 0
 3275 0066 E218     		adds	r2, r4, r3
 3276 0068 92F85020 		ldrb	r2, [r2, #80]	@ zero_extendqisi2
 3277 006c D2B2     		uxtb	r2, r2
 3278 006e 012A     		cmp	r2, #1
 3279 0070 01D0     		beq	.L293
 3280              	.L281:
1755:FreeRTOS/tasks.c ****                     {
 3281              		.loc 1 1755 0 discriminator 2
 3282 0072 0133     		adds	r3, r3, #1
 3283              	.LVL277:
 3284 0074 E8E7     		b	.L280
 3285              	.L293:
1761:FreeRTOS/tasks.c ****                         }
 3286              		.loc 1 1761 0
 3287 0076 E218     		adds	r2, r4, r3
 3288 0078 0021     		movs	r1, #0
 3289 007a 82F85010 		strb	r1, [r2, #80]
 3290 007e F8E7     		b	.L281
 3291              	.LVL278:
 3292              	.L291:
 3293              	.LBE232:
1773:FreeRTOS/tasks.c ****             {
 3294              		.loc 1 1773 0
 3295 0080 FFF7FEFF 		bl	vPortEnterCritical
 3296              	.LVL279:
1775:FreeRTOS/tasks.c ****             }
 3297              		.loc 1 1775 0
 3298 0084 FFF7FEFF 		bl	prvResetNextTaskUnblockTime
 3299              	.LVL280:
1777:FreeRTOS/tasks.c ****         }
 3300              		.loc 1 1777 0
 3301 0088 FFF7FEFF 		bl	vPortExitCritical
 3302              	.LVL281:
 3303 008c E3E7     		b	.L283
 3304              	.L292:
1786:FreeRTOS/tasks.c ****             {
 3305              		.loc 1 1786 0
 3306 008e 154B     		ldr	r3, .L294+12
 3307 0090 1B68     		ldr	r3, [r3]
 3308 0092 A3B1     		cbz	r3, .L285
1789:FreeRTOS/tasks.c ****                 portYIELD_WITHIN_API();
 3309              		.loc 1 1789 0
 3310 0094 154B     		ldr	r3, .L294+20
 3311 0096 1B68     		ldr	r3, [r3]
 3312 0098 43B1     		cbz	r3, .L286
 3313              	.LBB233:
 3314              	.LBB234:
 200:FreeRTOS/ARM_CM3/portmacro.h ****         (
ARM GAS  /tmp/ccrgBt0i.s 			page 164


 3315              		.loc 2 200 0
 3316              		.syntax unified
 3317              	@ 200 "FreeRTOS/ARM_CM3/portmacro.h" 1
 3318 009a 4FF05003 			mov r3, #80												
 3319 009e 83F31188 		msr basepri, r3											
 3320 00a2 BFF36F8F 		isb														
 3321 00a6 BFF34F8F 		dsb														
 3322              	
 3323              	@ 0 "" 2
 3324              	.LVL282:
 3325              		.thumb
 3326              		.syntax unified
 3327              	.L287:
 3328 00aa FEE7     		b	.L287
 3329              	.L286:
 3330              	.LBE234:
 3331              	.LBE233:
1790:FreeRTOS/tasks.c ****             }
 3332              		.loc 1 1790 0
 3333 00ac 104B     		ldr	r3, .L294+24
 3334 00ae 4FF08052 		mov	r2, #268435456
 3335 00b2 1A60     		str	r2, [r3]
 3336              		.syntax unified
 3337              	@ 1790 "FreeRTOS/tasks.c" 1
 3338 00b4 BFF34F8F 		dsb
 3339              	@ 0 "" 2
 3340              	@ 1790 "FreeRTOS/tasks.c" 1
 3341 00b8 BFF36F8F 		isb
 3342              	@ 0 "" 2
 3343              		.thumb
 3344              		.syntax unified
 3345 00bc CFE7     		b	.L276
 3346              	.L285:
1797:FreeRTOS/tasks.c ****                 {
 3347              		.loc 1 1797 0
 3348 00be 084B     		ldr	r3, .L294+8
 3349 00c0 1A68     		ldr	r2, [r3]
 3350 00c2 0C4B     		ldr	r3, .L294+28
 3351 00c4 1B68     		ldr	r3, [r3]
 3352 00c6 9A42     		cmp	r2, r3
 3353 00c8 03D1     		bne	.L288
1803:FreeRTOS/tasks.c ****                 }
 3354              		.loc 1 1803 0
 3355 00ca 074B     		ldr	r3, .L294+16
 3356 00cc 0022     		movs	r2, #0
 3357 00ce 1A60     		str	r2, [r3]
 3358 00d0 C5E7     		b	.L276
 3359              	.L288:
1807:FreeRTOS/tasks.c ****                 }
 3360              		.loc 1 1807 0
 3361 00d2 FFF7FEFF 		bl	vTaskSwitchContext
 3362              	.LVL283:
1815:FreeRTOS/tasks.c **** 
 3363              		.loc 1 1815 0
 3364 00d6 C2E7     		b	.L276
 3365              	.L295:
 3366              		.align	2
ARM GAS  /tmp/ccrgBt0i.s 			page 165


 3367              	.L294:
 3368 00d8 00000000 		.word	.LANCHOR4
 3369 00dc 00000000 		.word	.LANCHOR13
 3370 00e0 00000000 		.word	.LANCHOR0
 3371 00e4 00000000 		.word	.LANCHOR11
 3372 00e8 00000000 		.word	.LANCHOR10
 3373 00ec 00000000 		.word	.LANCHOR16
 3374 00f0 04ED00E0 		.word	-536810236
 3375 00f4 00000000 		.word	.LANCHOR9
 3376              		.cfi_endproc
 3377              	.LFE14:
 3379              		.section	.text.vTaskPlaceOnEventList,"ax",%progbits
 3380              		.align	1
 3381              		.global	vTaskPlaceOnEventList
 3382              		.syntax unified
 3383              		.thumb
 3384              		.thumb_func
 3385              		.fpu softvfp
 3387              	vTaskPlaceOnEventList:
 3388              	.LFB29:
3099:FreeRTOS/tasks.c ****     configASSERT( pxEventList );
 3389              		.loc 1 3099 0
 3390              		.cfi_startproc
 3391              		@ args = 0, pretend = 0, frame = 0
 3392              		@ frame_needed = 0, uses_anonymous_args = 0
 3393              	.LVL284:
3100:FreeRTOS/tasks.c **** 
 3394              		.loc 1 3100 0
 3395 0000 40B9     		cbnz	r0, .L297
 3396              	.LBB235:
 3397              	.LBB236:
 200:FreeRTOS/ARM_CM3/portmacro.h ****         (
 3398              		.loc 2 200 0
 3399              		.syntax unified
 3400              	@ 200 "FreeRTOS/ARM_CM3/portmacro.h" 1
 3401 0002 4FF05003 			mov r3, #80												
 3402 0006 83F31188 		msr basepri, r3											
 3403 000a BFF36F8F 		isb														
 3404 000e BFF34F8F 		dsb														
 3405              	
 3406              	@ 0 "" 2
 3407              	.LVL285:
 3408              		.thumb
 3409              		.syntax unified
 3410              	.L298:
 3411 0012 FEE7     		b	.L298
 3412              	.L297:
 3413              	.LBE236:
 3414              	.LBE235:
3099:FreeRTOS/tasks.c ****     configASSERT( pxEventList );
 3415              		.loc 1 3099 0
 3416 0014 10B5     		push	{r4, lr}
 3417              	.LCFI33:
 3418              		.cfi_def_cfa_offset 8
 3419              		.cfi_offset 4, -8
 3420              		.cfi_offset 14, -4
 3421 0016 0C46     		mov	r4, r1
ARM GAS  /tmp/ccrgBt0i.s 			page 166


3116:FreeRTOS/tasks.c **** 
 3422              		.loc 1 3116 0
 3423 0018 044B     		ldr	r3, .L301
 3424 001a 1968     		ldr	r1, [r3]
 3425              	.LVL286:
 3426 001c 1831     		adds	r1, r1, #24
 3427 001e FFF7FEFF 		bl	vListInsert
 3428              	.LVL287:
3118:FreeRTOS/tasks.c **** }
 3429              		.loc 1 3118 0
 3430 0022 0121     		movs	r1, #1
 3431 0024 2046     		mov	r0, r4
 3432 0026 FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
 3433              	.LVL288:
3119:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 3434              		.loc 1 3119 0
 3435 002a 10BD     		pop	{r4, pc}
 3436              	.LVL289:
 3437              	.L302:
 3438              		.align	2
 3439              	.L301:
 3440 002c 00000000 		.word	.LANCHOR10
 3441              		.cfi_endproc
 3442              	.LFE29:
 3444              		.section	.text.vTaskPlaceOnUnorderedEventList,"ax",%progbits
 3445              		.align	1
 3446              		.global	vTaskPlaceOnUnorderedEventList
 3447              		.syntax unified
 3448              		.thumb
 3449              		.thumb_func
 3450              		.fpu softvfp
 3452              	vTaskPlaceOnUnorderedEventList:
 3453              	.LFB30:
3125:FreeRTOS/tasks.c ****     configASSERT( pxEventList );
 3454              		.loc 1 3125 0
 3455              		.cfi_startproc
 3456              		@ args = 0, pretend = 0, frame = 0
 3457              		@ frame_needed = 0, uses_anonymous_args = 0
 3458              	.LVL290:
 3459 0000 38B5     		push	{r3, r4, r5, lr}
 3460              	.LCFI34:
 3461              		.cfi_def_cfa_offset 16
 3462              		.cfi_offset 3, -16
 3463              		.cfi_offset 4, -12
 3464              		.cfi_offset 5, -8
 3465              		.cfi_offset 14, -4
3126:FreeRTOS/tasks.c **** 
 3466              		.loc 1 3126 0
 3467 0002 40B9     		cbnz	r0, .L304
 3468              	.LBB237:
 3469              	.LBB238:
 200:FreeRTOS/ARM_CM3/portmacro.h ****         (
 3470              		.loc 2 200 0
 3471              		.syntax unified
 3472              	@ 200 "FreeRTOS/ARM_CM3/portmacro.h" 1
 3473 0004 4FF05003 			mov r3, #80												
 3474 0008 83F31188 		msr basepri, r3											
ARM GAS  /tmp/ccrgBt0i.s 			page 167


 3475 000c BFF36F8F 		isb														
 3476 0010 BFF34F8F 		dsb														
 3477              	
 3478              	@ 0 "" 2
 3479              	.LVL291:
 3480              		.thumb
 3481              		.syntax unified
 3482              	.L305:
 3483 0014 FEE7     		b	.L305
 3484              	.L304:
 3485 0016 0346     		mov	r3, r0
 3486              	.LBE238:
 3487              	.LBE237:
3130:FreeRTOS/tasks.c **** 
 3488              		.loc 1 3130 0
 3489 0018 1348     		ldr	r0, .L309
 3490              	.LVL292:
 3491 001a 0068     		ldr	r0, [r0]
 3492 001c 40B9     		cbnz	r0, .L306
 3493              	.LBB239:
 3494              	.LBB240:
 200:FreeRTOS/ARM_CM3/portmacro.h ****         (
 3495              		.loc 2 200 0
 3496              		.syntax unified
 3497              	@ 200 "FreeRTOS/ARM_CM3/portmacro.h" 1
 3498 001e 4FF05003 			mov r3, #80												
 3499 0022 83F31188 		msr basepri, r3											
 3500 0026 BFF36F8F 		isb														
 3501 002a BFF34F8F 		dsb														
 3502              	
 3503              	@ 0 "" 2
 3504              	.LVL293:
 3505              		.thumb
 3506              		.syntax unified
 3507              	.L307:
 3508 002e FEE7     		b	.L307
 3509              	.LVL294:
 3510              	.L306:
 3511 0030 1046     		mov	r0, r2
 3512              	.LBE240:
 3513              	.LBE239:
3135:FreeRTOS/tasks.c **** 
 3514              		.loc 1 3135 0
 3515 0032 0E4A     		ldr	r2, .L309+4
 3516              	.LVL295:
 3517 0034 1468     		ldr	r4, [r2]
 3518 0036 41F00041 		orr	r1, r1, #-2147483648
 3519              	.LVL296:
 3520 003a A161     		str	r1, [r4, #24]
 3521              	.LBB241:
3142:FreeRTOS/tasks.c **** 
 3522              		.loc 1 3142 0
 3523 003c 5968     		ldr	r1, [r3, #4]
 3524              	.LVL297:
 3525 003e 1468     		ldr	r4, [r2]
 3526 0040 E161     		str	r1, [r4, #28]
 3527 0042 1468     		ldr	r4, [r2]
ARM GAS  /tmp/ccrgBt0i.s 			page 168


 3528 0044 8D68     		ldr	r5, [r1, #8]
 3529 0046 2562     		str	r5, [r4, #32]
 3530 0048 1468     		ldr	r4, [r2]
 3531 004a 8D68     		ldr	r5, [r1, #8]
 3532 004c 1834     		adds	r4, r4, #24
 3533 004e 6C60     		str	r4, [r5, #4]
 3534 0050 1468     		ldr	r4, [r2]
 3535 0052 1834     		adds	r4, r4, #24
 3536 0054 8C60     		str	r4, [r1, #8]
 3537 0056 1268     		ldr	r2, [r2]
 3538 0058 9362     		str	r3, [r2, #40]
 3539 005a 1A68     		ldr	r2, [r3]
 3540 005c 0132     		adds	r2, r2, #1
 3541 005e 1A60     		str	r2, [r3]
 3542              	.LBE241:
3144:FreeRTOS/tasks.c **** }
 3543              		.loc 1 3144 0
 3544 0060 0121     		movs	r1, #1
 3545              	.LVL298:
 3546 0062 FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
 3547              	.LVL299:
3145:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 3548              		.loc 1 3145 0
 3549 0066 38BD     		pop	{r3, r4, r5, pc}
 3550              	.L310:
 3551              		.align	2
 3552              	.L309:
 3553 0068 00000000 		.word	.LANCHOR16
 3554 006c 00000000 		.word	.LANCHOR10
 3555              		.cfi_endproc
 3556              	.LFE30:
 3558              		.section	.text.vTaskPlaceOnEventListRestricted,"ax",%progbits
 3559              		.align	1
 3560              		.global	vTaskPlaceOnEventListRestricted
 3561              		.syntax unified
 3562              		.thumb
 3563              		.thumb_func
 3564              		.fpu softvfp
 3566              	vTaskPlaceOnEventListRestricted:
 3567              	.LFB31:
3153:FreeRTOS/tasks.c ****         configASSERT( pxEventList );
 3568              		.loc 1 3153 0
 3569              		.cfi_startproc
 3570              		@ args = 0, pretend = 0, frame = 0
 3571              		@ frame_needed = 0, uses_anonymous_args = 0
 3572              	.LVL300:
3154:FreeRTOS/tasks.c **** 
 3573              		.loc 1 3154 0
 3574 0000 E8B1     		cbz	r0, .L318
3153:FreeRTOS/tasks.c ****         configASSERT( pxEventList );
 3575              		.loc 1 3153 0
 3576 0002 70B5     		push	{r4, r5, r6, lr}
 3577              	.LCFI35:
 3578              		.cfi_def_cfa_offset 16
 3579              		.cfi_offset 4, -16
 3580              		.cfi_offset 5, -12
 3581              		.cfi_offset 6, -8
ARM GAS  /tmp/ccrgBt0i.s 			page 169


 3582              		.cfi_offset 14, -4
 3583 0004 0E46     		mov	r6, r1
 3584 0006 0446     		mov	r4, r0
 3585              	.LBB242:
3166:FreeRTOS/tasks.c **** 
 3586              		.loc 1 3166 0
 3587 0008 4068     		ldr	r0, [r0, #4]
 3588              	.LVL301:
 3589 000a 114B     		ldr	r3, .L319
 3590 000c 1968     		ldr	r1, [r3]
 3591              	.LVL302:
 3592 000e C861     		str	r0, [r1, #28]
 3593 0010 1968     		ldr	r1, [r3]
 3594 0012 8568     		ldr	r5, [r0, #8]
 3595 0014 0D62     		str	r5, [r1, #32]
 3596 0016 1D68     		ldr	r5, [r3]
 3597 0018 8168     		ldr	r1, [r0, #8]
 3598 001a 1835     		adds	r5, r5, #24
 3599 001c 4D60     		str	r5, [r1, #4]
 3600 001e 1D68     		ldr	r5, [r3]
 3601 0020 1835     		adds	r5, r5, #24
 3602 0022 8560     		str	r5, [r0, #8]
 3603 0024 1B68     		ldr	r3, [r3]
 3604 0026 9C62     		str	r4, [r3, #40]
 3605 0028 2368     		ldr	r3, [r4]
 3606 002a 0133     		adds	r3, r3, #1
 3607 002c 2360     		str	r3, [r4]
 3608              	.LBE242:
3171:FreeRTOS/tasks.c ****         {
 3609              		.loc 1 3171 0
 3610 002e 0AB1     		cbz	r2, .L314
3173:FreeRTOS/tasks.c ****         }
 3611              		.loc 1 3173 0
 3612 0030 4FF0FF36 		mov	r6, #-1
 3613              	.LVL303:
 3614              	.L314:
3177:FreeRTOS/tasks.c ****     }
 3615              		.loc 1 3177 0
 3616 0034 1146     		mov	r1, r2
 3617 0036 3046     		mov	r0, r6
 3618              	.LVL304:
 3619 0038 FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
 3620              	.LVL305:
3178:FreeRTOS/tasks.c **** 
 3621              		.loc 1 3178 0
 3622 003c 70BD     		pop	{r4, r5, r6, pc}
 3623              	.LVL306:
 3624              	.L318:
 3625              	.LCFI36:
 3626              		.cfi_def_cfa_offset 0
 3627              		.cfi_restore 4
 3628              		.cfi_restore 5
 3629              		.cfi_restore 6
 3630              		.cfi_restore 14
 3631              	.LBB243:
 3632              	.LBB244:
 200:FreeRTOS/ARM_CM3/portmacro.h ****         (
ARM GAS  /tmp/ccrgBt0i.s 			page 170


 3633              		.loc 2 200 0
 3634              		.syntax unified
 3635              	@ 200 "FreeRTOS/ARM_CM3/portmacro.h" 1
 3636 003e 4FF05003 			mov r3, #80												
 3637 0042 83F31188 		msr basepri, r3											
 3638 0046 BFF36F8F 		isb														
 3639 004a BFF34F8F 		dsb														
 3640              	
 3641              	@ 0 "" 2
 3642              	.LVL307:
 3643              		.thumb
 3644              		.syntax unified
 3645              	.L313:
 3646 004e FEE7     		b	.L313
 3647              	.L320:
 3648              		.align	2
 3649              	.L319:
 3650 0050 00000000 		.word	.LANCHOR10
 3651              	.LBE244:
 3652              	.LBE243:
 3653              		.cfi_endproc
 3654              	.LFE31:
 3656              		.section	.text.xTaskRemoveFromEventList,"ax",%progbits
 3657              		.align	1
 3658              		.global	xTaskRemoveFromEventList
 3659              		.syntax unified
 3660              		.thumb
 3661              		.thumb_func
 3662              		.fpu softvfp
 3664              	xTaskRemoveFromEventList:
 3665              	.LFB32:
3184:FreeRTOS/tasks.c ****     TCB_t * pxUnblockedTCB;
 3666              		.loc 1 3184 0
 3667              		.cfi_startproc
 3668              		@ args = 0, pretend = 0, frame = 0
 3669              		@ frame_needed = 0, uses_anonymous_args = 0
 3670              		@ link register save eliminated.
 3671              	.LVL308:
3201:FreeRTOS/tasks.c ****     configASSERT( pxUnblockedTCB );
 3672              		.loc 1 3201 0
 3673 0000 C368     		ldr	r3, [r0, #12]
 3674 0002 DB68     		ldr	r3, [r3, #12]
 3675              	.LVL309:
3202:FreeRTOS/tasks.c ****     listREMOVE_ITEM( &( pxUnblockedTCB->xEventListItem ) );
 3676              		.loc 1 3202 0
 3677 0004 002B     		cmp	r3, #0
 3678 0006 50D0     		beq	.L332
3184:FreeRTOS/tasks.c ****     TCB_t * pxUnblockedTCB;
 3679              		.loc 1 3184 0
 3680 0008 30B4     		push	{r4, r5}
 3681              	.LCFI37:
 3682              		.cfi_def_cfa_offset 8
 3683              		.cfi_offset 4, -8
 3684              		.cfi_offset 5, -4
 3685              	.LBB245:
3203:FreeRTOS/tasks.c **** 
 3686              		.loc 1 3203 0
ARM GAS  /tmp/ccrgBt0i.s 			page 171


 3687 000a 9A6A     		ldr	r2, [r3, #40]
 3688              	.LVL310:
 3689 000c D969     		ldr	r1, [r3, #28]
 3690 000e 186A     		ldr	r0, [r3, #32]
 3691              	.LVL311:
 3692 0010 8860     		str	r0, [r1, #8]
 3693 0012 196A     		ldr	r1, [r3, #32]
 3694 0014 D869     		ldr	r0, [r3, #28]
 3695 0016 4860     		str	r0, [r1, #4]
 3696 0018 5168     		ldr	r1, [r2, #4]
 3697 001a 03F11800 		add	r0, r3, #24
 3698 001e 8142     		cmp	r1, r0
 3699 0020 01D1     		bne	.L324
3203:FreeRTOS/tasks.c **** 
 3700              		.loc 1 3203 0 is_stmt 0 discriminator 1
 3701 0022 196A     		ldr	r1, [r3, #32]
 3702 0024 5160     		str	r1, [r2, #4]
 3703              	.L324:
3203:FreeRTOS/tasks.c **** 
 3704              		.loc 1 3203 0 discriminator 3
 3705 0026 0021     		movs	r1, #0
 3706 0028 9962     		str	r1, [r3, #40]
 3707 002a 1168     		ldr	r1, [r2]
 3708 002c 0139     		subs	r1, r1, #1
 3709 002e 1160     		str	r1, [r2]
 3710              	.LBE245:
3205:FreeRTOS/tasks.c ****     {
 3711              		.loc 1 3205 0 is_stmt 1 discriminator 3
 3712 0030 2B4A     		ldr	r2, .L334
 3713              	.LVL312:
 3714 0032 1268     		ldr	r2, [r2]
 3715 0034 002A     		cmp	r2, #0
 3716 0036 44D1     		bne	.L325
 3717              	.LBB246:
3207:FreeRTOS/tasks.c ****         prvAddTaskToReadyList( pxUnblockedTCB );
 3718              		.loc 1 3207 0
 3719 0038 5A69     		ldr	r2, [r3, #20]
 3720              	.LVL313:
 3721 003a 9968     		ldr	r1, [r3, #8]
 3722 003c D868     		ldr	r0, [r3, #12]
 3723 003e 8860     		str	r0, [r1, #8]
 3724 0040 D968     		ldr	r1, [r3, #12]
 3725 0042 9868     		ldr	r0, [r3, #8]
 3726 0044 4860     		str	r0, [r1, #4]
 3727 0046 5168     		ldr	r1, [r2, #4]
 3728 0048 1C1D     		adds	r4, r3, #4
 3729 004a A142     		cmp	r1, r4
 3730 004c 36D0     		beq	.L333
 3731              	.L326:
3207:FreeRTOS/tasks.c ****         prvAddTaskToReadyList( pxUnblockedTCB );
 3732              		.loc 1 3207 0 is_stmt 0 discriminator 3
 3733 004e 0021     		movs	r1, #0
 3734 0050 5961     		str	r1, [r3, #20]
 3735 0052 1168     		ldr	r1, [r2]
 3736 0054 0139     		subs	r1, r1, #1
 3737 0056 1160     		str	r1, [r2]
 3738              	.LBE246:
ARM GAS  /tmp/ccrgBt0i.s 			page 172


3208:FreeRTOS/tasks.c **** 
 3739              		.loc 1 3208 0 is_stmt 1 discriminator 3
 3740 0058 DA6A     		ldr	r2, [r3, #44]
 3741              	.LVL314:
 3742 005a 0121     		movs	r1, #1
 3743 005c 9140     		lsls	r1, r1, r2
 3744 005e 2148     		ldr	r0, .L334+4
 3745 0060 0568     		ldr	r5, [r0]
 3746 0062 2943     		orrs	r1, r1, r5
 3747 0064 0160     		str	r1, [r0]
 3748              	.LBB247:
 3749 0066 2049     		ldr	r1, .L334+8
 3750 0068 02EB8202 		add	r2, r2, r2, lsl #2
 3751 006c 9000     		lsls	r0, r2, #2
 3752 006e 0844     		add	r0, r0, r1
 3753 0070 4268     		ldr	r2, [r0, #4]
 3754              	.LVL315:
 3755 0072 9A60     		str	r2, [r3, #8]
 3756 0074 9068     		ldr	r0, [r2, #8]
 3757 0076 D860     		str	r0, [r3, #12]
 3758 0078 9068     		ldr	r0, [r2, #8]
 3759 007a 4460     		str	r4, [r0, #4]
 3760 007c 9460     		str	r4, [r2, #8]
 3761 007e DC6A     		ldr	r4, [r3, #44]
 3762 0080 A200     		lsls	r2, r4, #2
 3763              	.LVL316:
 3764 0082 1519     		adds	r5, r2, r4
 3765 0084 A800     		lsls	r0, r5, #2
 3766 0086 0D18     		adds	r5, r1, r0
 3767 0088 5D61     		str	r5, [r3, #20]
 3768 008a 0858     		ldr	r0, [r1, r0]
 3769 008c 0130     		adds	r0, r0, #1
 3770 008e 2244     		add	r2, r2, r4
 3771 0090 9400     		lsls	r4, r2, #2
 3772 0092 0851     		str	r0, [r1, r4]
 3773              	.L327:
 3774              	.LBE247:
3231:FreeRTOS/tasks.c ****     {
 3775              		.loc 1 3231 0
 3776 0094 DA6A     		ldr	r2, [r3, #44]
 3777 0096 154B     		ldr	r3, .L334+12
 3778              	.LVL317:
 3779 0098 1B68     		ldr	r3, [r3]
 3780 009a DB6A     		ldr	r3, [r3, #44]
 3781 009c 9A42     		cmp	r2, r3
 3782 009e 1DD9     		bls	.L329
 3783              	.LVL318:
3240:FreeRTOS/tasks.c ****     }
 3784              		.loc 1 3240 0
 3785 00a0 0120     		movs	r0, #1
 3786 00a2 134B     		ldr	r3, .L334+16
 3787 00a4 1860     		str	r0, [r3]
 3788              	.LVL319:
 3789              	.L321:
3248:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 3790              		.loc 1 3248 0
 3791 00a6 30BC     		pop	{r4, r5}
ARM GAS  /tmp/ccrgBt0i.s 			page 173


 3792              	.LCFI38:
 3793              		.cfi_restore 5
 3794              		.cfi_restore 4
 3795              		.cfi_def_cfa_offset 0
 3796 00a8 7047     		bx	lr
 3797              	.LVL320:
 3798              	.L332:
 3799              	.LBB248:
 3800              	.LBB249:
 200:FreeRTOS/ARM_CM3/portmacro.h ****         (
 3801              		.loc 2 200 0
 3802              		.syntax unified
 3803              	@ 200 "FreeRTOS/ARM_CM3/portmacro.h" 1
 3804 00aa 4FF05003 			mov r3, #80												
 3805 00ae 83F31188 		msr basepri, r3											
 3806 00b2 BFF36F8F 		isb														
 3807 00b6 BFF34F8F 		dsb														
 3808              	
 3809              	@ 0 "" 2
 3810              	.LVL321:
 3811              		.thumb
 3812              		.syntax unified
 3813              	.L323:
 3814 00ba FEE7     		b	.L323
 3815              	.LVL322:
 3816              	.L333:
 3817              	.LCFI39:
 3818              		.cfi_def_cfa_offset 8
 3819              		.cfi_offset 4, -8
 3820              		.cfi_offset 5, -4
 3821              	.LBE249:
 3822              	.LBE248:
 3823              	.LBB250:
3207:FreeRTOS/tasks.c ****         prvAddTaskToReadyList( pxUnblockedTCB );
 3824              		.loc 1 3207 0 discriminator 1
 3825 00bc D968     		ldr	r1, [r3, #12]
 3826 00be 5160     		str	r1, [r2, #4]
 3827 00c0 C5E7     		b	.L326
 3828              	.LVL323:
 3829              	.L325:
 3830              	.LBE250:
 3831              	.LBB251:
3228:FreeRTOS/tasks.c ****     }
 3832              		.loc 1 3228 0
 3833 00c2 0C4A     		ldr	r2, .L334+20
 3834 00c4 5168     		ldr	r1, [r2, #4]
 3835              	.LVL324:
 3836 00c6 D961     		str	r1, [r3, #28]
 3837 00c8 8C68     		ldr	r4, [r1, #8]
 3838 00ca 1C62     		str	r4, [r3, #32]
 3839 00cc 8C68     		ldr	r4, [r1, #8]
 3840 00ce 6060     		str	r0, [r4, #4]
 3841 00d0 8860     		str	r0, [r1, #8]
 3842 00d2 9A62     		str	r2, [r3, #40]
 3843 00d4 1168     		ldr	r1, [r2]
 3844              	.LVL325:
 3845 00d6 0131     		adds	r1, r1, #1
ARM GAS  /tmp/ccrgBt0i.s 			page 174


 3846 00d8 1160     		str	r1, [r2]
 3847 00da DBE7     		b	.L327
 3848              	.LVL326:
 3849              	.L329:
 3850              	.LBE251:
3244:FreeRTOS/tasks.c ****     }
 3851              		.loc 1 3244 0
 3852 00dc 0020     		movs	r0, #0
 3853              	.LVL327:
3247:FreeRTOS/tasks.c **** }
 3854              		.loc 1 3247 0
 3855 00de E2E7     		b	.L321
 3856              	.L335:
 3857              		.align	2
 3858              	.L334:
 3859 00e0 00000000 		.word	.LANCHOR16
 3860 00e4 00000000 		.word	.LANCHOR13
 3861 00e8 00000000 		.word	.LANCHOR4
 3862 00ec 00000000 		.word	.LANCHOR10
 3863 00f0 00000000 		.word	.LANCHOR17
 3864 00f4 00000000 		.word	.LANCHOR1
 3865              		.cfi_endproc
 3866              	.LFE32:
 3868              		.section	.text.vTaskRemoveFromUnorderedEventList,"ax",%progbits
 3869              		.align	1
 3870              		.global	vTaskRemoveFromUnorderedEventList
 3871              		.syntax unified
 3872              		.thumb
 3873              		.thumb_func
 3874              		.fpu softvfp
 3876              	vTaskRemoveFromUnorderedEventList:
 3877              	.LFB33:
3253:FreeRTOS/tasks.c ****     TCB_t * pxUnblockedTCB;
 3878              		.loc 1 3253 0
 3879              		.cfi_startproc
 3880              		@ args = 0, pretend = 0, frame = 0
 3881              		@ frame_needed = 0, uses_anonymous_args = 0
 3882              		@ link register save eliminated.
 3883              	.LVL328:
3258:FreeRTOS/tasks.c **** 
 3884              		.loc 1 3258 0
 3885 0000 344B     		ldr	r3, .L349
 3886 0002 1B68     		ldr	r3, [r3]
 3887 0004 43B9     		cbnz	r3, .L337
 3888              	.LBB252:
 3889              	.LBB253:
 200:FreeRTOS/ARM_CM3/portmacro.h ****         (
 3890              		.loc 2 200 0
 3891              		.syntax unified
 3892              	@ 200 "FreeRTOS/ARM_CM3/portmacro.h" 1
 3893 0006 4FF05003 			mov r3, #80												
 3894 000a 83F31188 		msr basepri, r3											
 3895 000e BFF36F8F 		isb														
 3896 0012 BFF34F8F 		dsb														
 3897              	
 3898              	@ 0 "" 2
 3899              	.LVL329:
ARM GAS  /tmp/ccrgBt0i.s 			page 175


 3900              		.thumb
 3901              		.syntax unified
 3902              	.L338:
 3903 0016 FEE7     		b	.L338
 3904              	.L337:
 3905              	.LBE253:
 3906              	.LBE252:
3261:FreeRTOS/tasks.c **** 
 3907              		.loc 1 3261 0
 3908 0018 41F00041 		orr	r1, r1, #-2147483648
 3909              	.LVL330:
 3910 001c 0160     		str	r1, [r0]
3265:FreeRTOS/tasks.c ****     configASSERT( pxUnblockedTCB );
 3911              		.loc 1 3265 0
 3912 001e C368     		ldr	r3, [r0, #12]
 3913              	.LVL331:
3266:FreeRTOS/tasks.c ****     listREMOVE_ITEM( pxEventListItem );
 3914              		.loc 1 3266 0
 3915 0020 002B     		cmp	r3, #0
 3916 0022 48D0     		beq	.L346
3253:FreeRTOS/tasks.c ****     TCB_t * pxUnblockedTCB;
 3917              		.loc 1 3253 0
 3918 0024 30B4     		push	{r4, r5}
 3919              	.LCFI40:
 3920              		.cfi_def_cfa_offset 8
 3921              		.cfi_offset 4, -8
 3922              		.cfi_offset 5, -4
 3923              	.LBB254:
3267:FreeRTOS/tasks.c **** 
 3924              		.loc 1 3267 0
 3925 0026 0269     		ldr	r2, [r0, #16]
 3926              	.LVL332:
 3927 0028 4168     		ldr	r1, [r0, #4]
 3928 002a 8468     		ldr	r4, [r0, #8]
 3929 002c 8C60     		str	r4, [r1, #8]
 3930 002e 8168     		ldr	r1, [r0, #8]
 3931 0030 4468     		ldr	r4, [r0, #4]
 3932 0032 4C60     		str	r4, [r1, #4]
 3933 0034 5168     		ldr	r1, [r2, #4]
 3934 0036 8142     		cmp	r1, r0
 3935 0038 46D0     		beq	.L347
 3936              	.L341:
3267:FreeRTOS/tasks.c **** 
 3937              		.loc 1 3267 0 is_stmt 0 discriminator 3
 3938 003a 0021     		movs	r1, #0
 3939 003c 0161     		str	r1, [r0, #16]
 3940 003e 1168     		ldr	r1, [r2]
 3941 0040 0139     		subs	r1, r1, #1
 3942 0042 1160     		str	r1, [r2]
 3943              	.LBE254:
 3944              	.LBB255:
3286:FreeRTOS/tasks.c ****     prvAddTaskToReadyList( pxUnblockedTCB );
 3945              		.loc 1 3286 0 is_stmt 1 discriminator 3
 3946 0044 5A69     		ldr	r2, [r3, #20]
 3947              	.LVL333:
 3948 0046 9968     		ldr	r1, [r3, #8]
 3949 0048 D868     		ldr	r0, [r3, #12]
ARM GAS  /tmp/ccrgBt0i.s 			page 176


 3950              	.LVL334:
 3951 004a 8860     		str	r0, [r1, #8]
 3952 004c D968     		ldr	r1, [r3, #12]
 3953 004e 9868     		ldr	r0, [r3, #8]
 3954 0050 4860     		str	r0, [r1, #4]
 3955 0052 5168     		ldr	r1, [r2, #4]
 3956 0054 1C1D     		adds	r4, r3, #4
 3957 0056 A142     		cmp	r1, r4
 3958 0058 39D0     		beq	.L348
 3959              	.L342:
 3960 005a 0021     		movs	r1, #0
 3961 005c 5961     		str	r1, [r3, #20]
 3962 005e 1168     		ldr	r1, [r2]
 3963 0060 0139     		subs	r1, r1, #1
 3964 0062 1160     		str	r1, [r2]
 3965              	.LBE255:
3287:FreeRTOS/tasks.c **** 
 3966              		.loc 1 3287 0 discriminator 3
 3967 0064 DA6A     		ldr	r2, [r3, #44]
 3968              	.LVL335:
 3969 0066 0121     		movs	r1, #1
 3970 0068 9140     		lsls	r1, r1, r2
 3971 006a 1B48     		ldr	r0, .L349+4
 3972 006c 0568     		ldr	r5, [r0]
 3973 006e 2943     		orrs	r1, r1, r5
 3974 0070 0160     		str	r1, [r0]
 3975              	.LBB256:
 3976 0072 1A49     		ldr	r1, .L349+8
 3977 0074 02EB8202 		add	r2, r2, r2, lsl #2
 3978 0078 9000     		lsls	r0, r2, #2
 3979 007a 0844     		add	r0, r0, r1
 3980 007c 4268     		ldr	r2, [r0, #4]
 3981              	.LVL336:
 3982 007e 9A60     		str	r2, [r3, #8]
 3983 0080 9068     		ldr	r0, [r2, #8]
 3984 0082 D860     		str	r0, [r3, #12]
 3985 0084 9068     		ldr	r0, [r2, #8]
 3986 0086 4460     		str	r4, [r0, #4]
 3987 0088 9460     		str	r4, [r2, #8]
 3988 008a DC6A     		ldr	r4, [r3, #44]
 3989 008c A200     		lsls	r2, r4, #2
 3990              	.LVL337:
 3991 008e 1519     		adds	r5, r2, r4
 3992 0090 A800     		lsls	r0, r5, #2
 3993 0092 0D18     		adds	r5, r1, r0
 3994 0094 5D61     		str	r5, [r3, #20]
 3995 0096 0858     		ldr	r0, [r1, r0]
 3996 0098 0130     		adds	r0, r0, #1
 3997 009a 2244     		add	r2, r2, r4
 3998 009c 9400     		lsls	r4, r2, #2
 3999 009e 0851     		str	r0, [r1, r4]
 4000              	.LBE256:
3289:FreeRTOS/tasks.c ****     {
 4001              		.loc 1 3289 0 discriminator 3
 4002 00a0 DA6A     		ldr	r2, [r3, #44]
 4003 00a2 0F4B     		ldr	r3, .L349+12
 4004              	.LVL338:
ARM GAS  /tmp/ccrgBt0i.s 			page 177


 4005 00a4 1B68     		ldr	r3, [r3]
 4006 00a6 DB6A     		ldr	r3, [r3, #44]
 4007 00a8 9A42     		cmp	r2, r3
 4008 00aa 02D9     		bls	.L336
3295:FreeRTOS/tasks.c ****     }
 4009              		.loc 1 3295 0
 4010 00ac 0D4B     		ldr	r3, .L349+16
 4011 00ae 0122     		movs	r2, #1
 4012 00b0 1A60     		str	r2, [r3]
 4013              	.L336:
3297:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 4014              		.loc 1 3297 0
 4015 00b2 30BC     		pop	{r4, r5}
 4016              	.LCFI41:
 4017              		.cfi_restore 5
 4018              		.cfi_restore 4
 4019              		.cfi_def_cfa_offset 0
 4020 00b4 7047     		bx	lr
 4021              	.LVL339:
 4022              	.L346:
 4023              	.LBB257:
 4024              	.LBB258:
 200:FreeRTOS/ARM_CM3/portmacro.h ****         (
 4025              		.loc 2 200 0
 4026              		.syntax unified
 4027              	@ 200 "FreeRTOS/ARM_CM3/portmacro.h" 1
 4028 00b6 4FF05003 			mov r3, #80												
 4029 00ba 83F31188 		msr basepri, r3											
 4030 00be BFF36F8F 		isb														
 4031 00c2 BFF34F8F 		dsb														
 4032              	
 4033              	@ 0 "" 2
 4034              	.LVL340:
 4035              		.thumb
 4036              		.syntax unified
 4037              	.L340:
 4038 00c6 FEE7     		b	.L340
 4039              	.LVL341:
 4040              	.L347:
 4041              	.LCFI42:
 4042              		.cfi_def_cfa_offset 8
 4043              		.cfi_offset 4, -8
 4044              		.cfi_offset 5, -4
 4045              	.LBE258:
 4046              	.LBE257:
 4047              	.LBB259:
3267:FreeRTOS/tasks.c **** 
 4048              		.loc 1 3267 0 discriminator 1
 4049 00c8 8168     		ldr	r1, [r0, #8]
 4050 00ca 5160     		str	r1, [r2, #4]
 4051 00cc B5E7     		b	.L341
 4052              	.LVL342:
 4053              	.L348:
 4054              	.LBE259:
 4055              	.LBB260:
3286:FreeRTOS/tasks.c ****     prvAddTaskToReadyList( pxUnblockedTCB );
 4056              		.loc 1 3286 0 discriminator 1
ARM GAS  /tmp/ccrgBt0i.s 			page 178


 4057 00ce D968     		ldr	r1, [r3, #12]
 4058 00d0 5160     		str	r1, [r2, #4]
 4059 00d2 C2E7     		b	.L342
 4060              	.L350:
 4061              		.align	2
 4062              	.L349:
 4063 00d4 00000000 		.word	.LANCHOR16
 4064 00d8 00000000 		.word	.LANCHOR13
 4065 00dc 00000000 		.word	.LANCHOR4
 4066 00e0 00000000 		.word	.LANCHOR10
 4067 00e4 00000000 		.word	.LANCHOR17
 4068              	.LBE260:
 4069              		.cfi_endproc
 4070              	.LFE33:
 4072              		.section	.text.vTaskSetTimeOutState,"ax",%progbits
 4073              		.align	1
 4074              		.global	vTaskSetTimeOutState
 4075              		.syntax unified
 4076              		.thumb
 4077              		.thumb_func
 4078              		.fpu softvfp
 4080              	vTaskSetTimeOutState:
 4081              	.LFB34:
3301:FreeRTOS/tasks.c ****     configASSERT( pxTimeOut );
 4082              		.loc 1 3301 0
 4083              		.cfi_startproc
 4084              		@ args = 0, pretend = 0, frame = 0
 4085              		@ frame_needed = 0, uses_anonymous_args = 0
 4086              	.LVL343:
3302:FreeRTOS/tasks.c ****     taskENTER_CRITICAL();
 4087              		.loc 1 3302 0
 4088 0000 40B9     		cbnz	r0, .L352
 4089              	.LBB261:
 4090              	.LBB262:
 200:FreeRTOS/ARM_CM3/portmacro.h ****         (
 4091              		.loc 2 200 0
 4092              		.syntax unified
 4093              	@ 200 "FreeRTOS/ARM_CM3/portmacro.h" 1
 4094 0002 4FF05003 			mov r3, #80												
 4095 0006 83F31188 		msr basepri, r3											
 4096 000a BFF36F8F 		isb														
 4097 000e BFF34F8F 		dsb														
 4098              	
 4099              	@ 0 "" 2
 4100              	.LVL344:
 4101              		.thumb
 4102              		.syntax unified
 4103              	.L353:
 4104 0012 FEE7     		b	.L353
 4105              	.L352:
 4106              	.LBE262:
 4107              	.LBE261:
3301:FreeRTOS/tasks.c ****     configASSERT( pxTimeOut );
 4108              		.loc 1 3301 0
 4109 0014 10B5     		push	{r4, lr}
 4110              	.LCFI43:
 4111              		.cfi_def_cfa_offset 8
ARM GAS  /tmp/ccrgBt0i.s 			page 179


 4112              		.cfi_offset 4, -8
 4113              		.cfi_offset 14, -4
 4114 0016 0446     		mov	r4, r0
3303:FreeRTOS/tasks.c ****     {
 4115              		.loc 1 3303 0
 4116 0018 FFF7FEFF 		bl	vPortEnterCritical
 4117              	.LVL345:
3305:FreeRTOS/tasks.c ****         pxTimeOut->xTimeOnEntering = xTickCount;
 4118              		.loc 1 3305 0
 4119 001c 044B     		ldr	r3, .L356
 4120 001e 1B68     		ldr	r3, [r3]
 4121 0020 2360     		str	r3, [r4]
3306:FreeRTOS/tasks.c ****     }
 4122              		.loc 1 3306 0
 4123 0022 044B     		ldr	r3, .L356+4
 4124 0024 1B68     		ldr	r3, [r3]
 4125 0026 6360     		str	r3, [r4, #4]
3308:FreeRTOS/tasks.c **** }
 4126              		.loc 1 3308 0
 4127 0028 FFF7FEFF 		bl	vPortExitCritical
 4128              	.LVL346:
3309:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 4129              		.loc 1 3309 0
 4130 002c 10BD     		pop	{r4, pc}
 4131              	.LVL347:
 4132              	.L357:
 4133 002e 00BF     		.align	2
 4134              	.L356:
 4135 0030 00000000 		.word	.LANCHOR20
 4136 0034 00000000 		.word	.LANCHOR15
 4137              		.cfi_endproc
 4138              	.LFE34:
 4140              		.section	.text.vTaskInternalSetTimeOutState,"ax",%progbits
 4141              		.align	1
 4142              		.global	vTaskInternalSetTimeOutState
 4143              		.syntax unified
 4144              		.thumb
 4145              		.thumb_func
 4146              		.fpu softvfp
 4148              	vTaskInternalSetTimeOutState:
 4149              	.LFB35:
3313:FreeRTOS/tasks.c ****     /* For internal use only as it does not use a critical section. */
 4150              		.loc 1 3313 0
 4151              		.cfi_startproc
 4152              		@ args = 0, pretend = 0, frame = 0
 4153              		@ frame_needed = 0, uses_anonymous_args = 0
 4154              		@ link register save eliminated.
 4155              	.LVL348:
3315:FreeRTOS/tasks.c ****     pxTimeOut->xTimeOnEntering = xTickCount;
 4156              		.loc 1 3315 0
 4157 0000 034B     		ldr	r3, .L359
 4158 0002 1B68     		ldr	r3, [r3]
 4159 0004 0360     		str	r3, [r0]
3316:FreeRTOS/tasks.c **** }
 4160              		.loc 1 3316 0
 4161 0006 034B     		ldr	r3, .L359+4
 4162 0008 1B68     		ldr	r3, [r3]
ARM GAS  /tmp/ccrgBt0i.s 			page 180


 4163 000a 4360     		str	r3, [r0, #4]
3317:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 4164              		.loc 1 3317 0
 4165 000c 7047     		bx	lr
 4166              	.L360:
 4167 000e 00BF     		.align	2
 4168              	.L359:
 4169 0010 00000000 		.word	.LANCHOR20
 4170 0014 00000000 		.word	.LANCHOR15
 4171              		.cfi_endproc
 4172              	.LFE35:
 4174              		.section	.text.xTaskCheckForTimeOut,"ax",%progbits
 4175              		.align	1
 4176              		.global	xTaskCheckForTimeOut
 4177              		.syntax unified
 4178              		.thumb
 4179              		.thumb_func
 4180              		.fpu softvfp
 4182              	xTaskCheckForTimeOut:
 4183              	.LFB36:
3322:FreeRTOS/tasks.c ****     BaseType_t xReturn;
 4184              		.loc 1 3322 0
 4185              		.cfi_startproc
 4186              		@ args = 0, pretend = 0, frame = 0
 4187              		@ frame_needed = 0, uses_anonymous_args = 0
 4188              	.LVL349:
 4189 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 4190              	.LCFI44:
 4191              		.cfi_def_cfa_offset 24
 4192              		.cfi_offset 3, -24
 4193              		.cfi_offset 4, -20
 4194              		.cfi_offset 5, -16
 4195              		.cfi_offset 6, -12
 4196              		.cfi_offset 7, -8
 4197              		.cfi_offset 14, -4
3325:FreeRTOS/tasks.c ****     configASSERT( pxTicksToWait );
 4198              		.loc 1 3325 0
 4199 0002 50B1     		cbz	r0, .L371
 4200 0004 0546     		mov	r5, r0
3326:FreeRTOS/tasks.c **** 
 4201              		.loc 1 3326 0
 4202 0006 89B9     		cbnz	r1, .L364
 4203              	.LBB263:
 4204              	.LBB264:
 200:FreeRTOS/ARM_CM3/portmacro.h ****         (
 4205              		.loc 2 200 0
 4206              		.syntax unified
 4207              	@ 200 "FreeRTOS/ARM_CM3/portmacro.h" 1
 4208 0008 4FF05003 			mov r3, #80												
 4209 000c 83F31188 		msr basepri, r3											
 4210 0010 BFF36F8F 		isb														
 4211 0014 BFF34F8F 		dsb														
 4212              	
 4213              	@ 0 "" 2
 4214              	.LVL350:
 4215              		.thumb
 4216              		.syntax unified
ARM GAS  /tmp/ccrgBt0i.s 			page 181


 4217              	.L365:
 4218 0018 FEE7     		b	.L365
 4219              	.L371:
 4220              	.LBE264:
 4221              	.LBE263:
 4222              	.LBB265:
 4223              	.LBB266:
 4224              		.syntax unified
 4225              	@ 200 "FreeRTOS/ARM_CM3/portmacro.h" 1
 4226 001a 4FF05003 			mov r3, #80												
 4227 001e 83F31188 		msr basepri, r3											
 4228 0022 BFF36F8F 		isb														
 4229 0026 BFF34F8F 		dsb														
 4230              	
 4231              	@ 0 "" 2
 4232              	.LVL351:
 4233              		.thumb
 4234              		.syntax unified
 4235              	.L363:
 4236 002a FEE7     		b	.L363
 4237              	.L364:
 4238 002c 0C46     		mov	r4, r1
 4239              	.LBE266:
 4240              	.LBE265:
3328:FreeRTOS/tasks.c ****     {
 4241              		.loc 1 3328 0
 4242 002e FFF7FEFF 		bl	vPortEnterCritical
 4243              	.LVL352:
 4244              	.LBB267:
3331:FreeRTOS/tasks.c ****         const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
 4245              		.loc 1 3331 0
 4246 0032 124B     		ldr	r3, .L374
 4247 0034 1968     		ldr	r1, [r3]
 4248              	.LVL353:
3332:FreeRTOS/tasks.c **** 
 4249              		.loc 1 3332 0
 4250 0036 6868     		ldr	r0, [r5, #4]
 4251 0038 0A1A     		subs	r2, r1, r0
 4252              	.LVL354:
3346:FreeRTOS/tasks.c ****             {
 4253              		.loc 1 3346 0
 4254 003a 2368     		ldr	r3, [r4]
 4255 003c B3F1FF3F 		cmp	r3, #-1
 4256 0040 1AD0     		beq	.L369
3356:FreeRTOS/tasks.c ****         {
 4257              		.loc 1 3356 0
 4258 0042 2F68     		ldr	r7, [r5]
 4259 0044 0E4E     		ldr	r6, .L374+4
 4260 0046 3668     		ldr	r6, [r6]
 4261 0048 B742     		cmp	r7, r6
 4262 004a 01D0     		beq	.L367
3356:FreeRTOS/tasks.c ****         {
 4263              		.loc 1 3356 0 is_stmt 0 discriminator 1
 4264 004c 8842     		cmp	r0, r1
 4265 004e 05D9     		bls	.L372
 4266              	.L367:
3366:FreeRTOS/tasks.c ****         {
ARM GAS  /tmp/ccrgBt0i.s 			page 182


 4267              		.loc 1 3366 0 is_stmt 1
 4268 0050 9342     		cmp	r3, r2
 4269 0052 0AD8     		bhi	.L373
3375:FreeRTOS/tasks.c ****             xReturn = pdTRUE;
 4270              		.loc 1 3375 0
 4271 0054 0023     		movs	r3, #0
 4272 0056 2360     		str	r3, [r4]
 4273              	.LVL355:
3376:FreeRTOS/tasks.c ****         }
 4274              		.loc 1 3376 0
 4275 0058 0124     		movs	r4, #1
 4276              	.LVL356:
 4277 005a 02E0     		b	.L366
 4278              	.LVL357:
 4279              	.L372:
3364:FreeRTOS/tasks.c ****         }
 4280              		.loc 1 3364 0
 4281 005c 0023     		movs	r3, #0
 4282 005e 2360     		str	r3, [r4]
3363:FreeRTOS/tasks.c ****             *pxTicksToWait = ( TickType_t ) 0;
 4283              		.loc 1 3363 0
 4284 0060 0124     		movs	r4, #1
 4285              	.LVL358:
 4286              	.L366:
 4287              	.LBE267:
3379:FreeRTOS/tasks.c **** 
 4288              		.loc 1 3379 0
 4289 0062 FFF7FEFF 		bl	vPortExitCritical
 4290              	.LVL359:
3382:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 4291              		.loc 1 3382 0
 4292 0066 2046     		mov	r0, r4
 4293 0068 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 4294              	.LVL360:
 4295              	.L373:
 4296              	.LBB268:
3369:FreeRTOS/tasks.c ****             vTaskInternalSetTimeOutState( pxTimeOut );
 4297              		.loc 1 3369 0
 4298 006a 9B1A     		subs	r3, r3, r2
 4299 006c 2360     		str	r3, [r4]
3370:FreeRTOS/tasks.c ****             xReturn = pdFALSE;
 4300              		.loc 1 3370 0
 4301 006e 2846     		mov	r0, r5
 4302 0070 FFF7FEFF 		bl	vTaskInternalSetTimeOutState
 4303              	.LVL361:
3371:FreeRTOS/tasks.c ****         }
 4304              		.loc 1 3371 0
 4305 0074 0024     		movs	r4, #0
 4306              	.LVL362:
 4307 0076 F4E7     		b	.L366
 4308              	.LVL363:
 4309              	.L369:
3351:FreeRTOS/tasks.c ****             }
 4310              		.loc 1 3351 0
 4311 0078 0024     		movs	r4, #0
 4312              	.LVL364:
 4313 007a F2E7     		b	.L366
ARM GAS  /tmp/ccrgBt0i.s 			page 183


 4314              	.L375:
 4315              		.align	2
 4316              	.L374:
 4317 007c 00000000 		.word	.LANCHOR15
 4318 0080 00000000 		.word	.LANCHOR20
 4319              	.LBE268:
 4320              		.cfi_endproc
 4321              	.LFE36:
 4323              		.section	.text.vTaskMissedYield,"ax",%progbits
 4324              		.align	1
 4325              		.global	vTaskMissedYield
 4326              		.syntax unified
 4327              		.thumb
 4328              		.thumb_func
 4329              		.fpu softvfp
 4331              	vTaskMissedYield:
 4332              	.LFB37:
3386:FreeRTOS/tasks.c ****     xYieldPending = pdTRUE;
 4333              		.loc 1 3386 0
 4334              		.cfi_startproc
 4335              		@ args = 0, pretend = 0, frame = 0
 4336              		@ frame_needed = 0, uses_anonymous_args = 0
 4337              		@ link register save eliminated.
3387:FreeRTOS/tasks.c **** }
 4338              		.loc 1 3387 0
 4339 0000 014B     		ldr	r3, .L377
 4340 0002 0122     		movs	r2, #1
 4341 0004 1A60     		str	r2, [r3]
3388:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 4342              		.loc 1 3388 0
 4343 0006 7047     		bx	lr
 4344              	.L378:
 4345              		.align	2
 4346              	.L377:
 4347 0008 00000000 		.word	.LANCHOR17
 4348              		.cfi_endproc
 4349              	.LFE37:
 4351              		.section	.text.xTaskGetCurrentTaskHandle,"ax",%progbits
 4352              		.align	1
 4353              		.global	xTaskGetCurrentTaskHandle
 4354              		.syntax unified
 4355              		.thumb
 4356              		.thumb_func
 4357              		.fpu softvfp
 4359              	xTaskGetCurrentTaskHandle:
 4360              	.LFB43:
4030:FreeRTOS/tasks.c ****         TaskHandle_t xReturn;
 4361              		.loc 1 4030 0
 4362              		.cfi_startproc
 4363              		@ args = 0, pretend = 0, frame = 0
 4364              		@ frame_needed = 0, uses_anonymous_args = 0
 4365              		@ link register save eliminated.
4036:FreeRTOS/tasks.c **** 
 4366              		.loc 1 4036 0
 4367 0000 014B     		ldr	r3, .L380
 4368 0002 1868     		ldr	r0, [r3]
 4369              	.LVL365:
ARM GAS  /tmp/ccrgBt0i.s 			page 184


4039:FreeRTOS/tasks.c **** 
 4370              		.loc 1 4039 0
 4371 0004 7047     		bx	lr
 4372              	.L381:
 4373 0006 00BF     		.align	2
 4374              	.L380:
 4375 0008 00000000 		.word	.LANCHOR10
 4376              		.cfi_endproc
 4377              	.LFE43:
 4379              		.section	.text.xTaskGetSchedulerState,"ax",%progbits
 4380              		.align	1
 4381              		.global	xTaskGetSchedulerState
 4382              		.syntax unified
 4383              		.thumb
 4384              		.thumb_func
 4385              		.fpu softvfp
 4387              	xTaskGetSchedulerState:
 4388              	.LFB44:
4047:FreeRTOS/tasks.c ****         BaseType_t xReturn;
 4389              		.loc 1 4047 0
 4390              		.cfi_startproc
 4391              		@ args = 0, pretend = 0, frame = 0
 4392              		@ frame_needed = 0, uses_anonymous_args = 0
 4393              		@ link register save eliminated.
4050:FreeRTOS/tasks.c ****         {
 4394              		.loc 1 4050 0
 4395 0000 054B     		ldr	r3, .L387
 4396 0002 1B68     		ldr	r3, [r3]
 4397 0004 33B1     		cbz	r3, .L384
4056:FreeRTOS/tasks.c ****             {
 4398              		.loc 1 4056 0
 4399 0006 054B     		ldr	r3, .L387+4
 4400 0008 1B68     		ldr	r3, [r3]
 4401 000a 0BB1     		cbz	r3, .L386
4062:FreeRTOS/tasks.c ****             }
 4402              		.loc 1 4062 0
 4403 000c 0020     		movs	r0, #0
 4404              	.LVL366:
4067:FreeRTOS/tasks.c **** 
 4405              		.loc 1 4067 0
 4406 000e 7047     		bx	lr
 4407              	.LVL367:
 4408              	.L386:
4058:FreeRTOS/tasks.c ****             }
 4409              		.loc 1 4058 0
 4410 0010 0220     		movs	r0, #2
 4411 0012 7047     		bx	lr
 4412              	.L384:
4052:FreeRTOS/tasks.c ****         }
 4413              		.loc 1 4052 0
 4414 0014 0120     		movs	r0, #1
 4415 0016 7047     		bx	lr
 4416              	.L388:
 4417              		.align	2
 4418              	.L387:
 4419 0018 00000000 		.word	.LANCHOR11
 4420 001c 00000000 		.word	.LANCHOR16
ARM GAS  /tmp/ccrgBt0i.s 			page 185


 4421              		.cfi_endproc
 4422              	.LFE44:
 4424              		.section	.text.xTaskPriorityInherit,"ax",%progbits
 4425              		.align	1
 4426              		.global	xTaskPriorityInherit
 4427              		.syntax unified
 4428              		.thumb
 4429              		.thumb_func
 4430              		.fpu softvfp
 4432              	xTaskPriorityInherit:
 4433              	.LFB45:
4075:FreeRTOS/tasks.c ****         TCB_t * const pxMutexHolderTCB = pxMutexHolder;
 4434              		.loc 1 4075 0
 4435              		.cfi_startproc
 4436              		@ args = 0, pretend = 0, frame = 0
 4437              		@ frame_needed = 0, uses_anonymous_args = 0
 4438              	.LVL368:
4082:FreeRTOS/tasks.c ****         {
 4439              		.loc 1 4082 0
 4440 0000 0028     		cmp	r0, #0
 4441 0002 59D0     		beq	.L395
4075:FreeRTOS/tasks.c ****         TCB_t * const pxMutexHolderTCB = pxMutexHolder;
 4442              		.loc 1 4075 0
 4443 0004 70B5     		push	{r4, r5, r6, lr}
 4444              	.LCFI45:
 4445              		.cfi_def_cfa_offset 16
 4446              		.cfi_offset 4, -16
 4447              		.cfi_offset 5, -12
 4448              		.cfi_offset 6, -8
 4449              		.cfi_offset 14, -4
 4450 0006 0446     		mov	r4, r0
4087:FreeRTOS/tasks.c ****             {
 4451              		.loc 1 4087 0
 4452 0008 C26A     		ldr	r2, [r0, #44]
 4453 000a 2C49     		ldr	r1, .L403
 4454 000c 0968     		ldr	r1, [r1]
 4455 000e C96A     		ldr	r1, [r1, #44]
 4456 0010 8A42     		cmp	r2, r1
 4457 0012 47D2     		bcs	.L391
4092:FreeRTOS/tasks.c ****                 {
 4458              		.loc 1 4092 0
 4459 0014 8169     		ldr	r1, [r0, #24]
 4460 0016 0029     		cmp	r1, #0
 4461 0018 05DB     		blt	.L392
4094:FreeRTOS/tasks.c ****                 }
 4462              		.loc 1 4094 0
 4463 001a 2849     		ldr	r1, .L403
 4464 001c 0968     		ldr	r1, [r1]
 4465 001e C96A     		ldr	r1, [r1, #44]
 4466 0020 C1F10701 		rsb	r1, r1, #7
 4467 0024 8161     		str	r1, [r0, #24]
 4468              	.L392:
4103:FreeRTOS/tasks.c ****                 {
 4469              		.loc 1 4103 0
 4470 0026 6069     		ldr	r0, [r4, #20]
 4471              	.LVL369:
 4472 0028 02EB8202 		add	r2, r2, r2, lsl #2
ARM GAS  /tmp/ccrgBt0i.s 			page 186


 4473 002c 9100     		lsls	r1, r2, #2
 4474 002e 244A     		ldr	r2, .L403+4
 4475 0030 0A44     		add	r2, r2, r1
 4476 0032 9042     		cmp	r0, r2
 4477 0034 05D0     		beq	.L401
4124:FreeRTOS/tasks.c ****                 }
 4478              		.loc 1 4124 0
 4479 0036 214A     		ldr	r2, .L403
 4480 0038 1268     		ldr	r2, [r2]
 4481 003a D26A     		ldr	r2, [r2, #44]
 4482 003c E262     		str	r2, [r4, #44]
4130:FreeRTOS/tasks.c ****             }
 4483              		.loc 1 4130 0
 4484 003e 0120     		movs	r0, #1
 4485              	.LVL370:
 4486              	.L389:
4157:FreeRTOS/tasks.c **** 
 4487              		.loc 1 4157 0
 4488 0040 70BD     		pop	{r4, r5, r6, pc}
 4489              	.LVL371:
 4490              	.L401:
4105:FreeRTOS/tasks.c ****                     {
 4491              		.loc 1 4105 0
 4492 0042 251D     		adds	r5, r4, #4
 4493 0044 2846     		mov	r0, r5
 4494 0046 FFF7FEFF 		bl	uxListRemove
 4495              	.LVL372:
 4496 004a 40B9     		cbnz	r0, .L394
4110:FreeRTOS/tasks.c ****                     }
 4497              		.loc 1 4110 0
 4498 004c E26A     		ldr	r2, [r4, #44]
 4499 004e 0123     		movs	r3, #1
 4500 0050 03FA02F2 		lsl	r2, r3, r2
 4501 0054 1B49     		ldr	r1, .L403+8
 4502 0056 0B68     		ldr	r3, [r1]
 4503 0058 23EA0203 		bic	r3, r3, r2
 4504 005c 0B60     		str	r3, [r1]
 4505              	.L394:
4118:FreeRTOS/tasks.c ****                     prvAddTaskToReadyList( pxMutexHolderTCB );
 4506              		.loc 1 4118 0
 4507 005e 174B     		ldr	r3, .L403
 4508 0060 1B68     		ldr	r3, [r3]
 4509 0062 DB6A     		ldr	r3, [r3, #44]
 4510 0064 E362     		str	r3, [r4, #44]
4119:FreeRTOS/tasks.c ****                 }
 4511              		.loc 1 4119 0
 4512 0066 0120     		movs	r0, #1
 4513 0068 00FA03F2 		lsl	r2, r0, r3
 4514 006c 1549     		ldr	r1, .L403+8
 4515 006e 0E68     		ldr	r6, [r1]
 4516 0070 3243     		orrs	r2, r2, r6
 4517 0072 0A60     		str	r2, [r1]
 4518              	.LBB269:
 4519 0074 124A     		ldr	r2, .L403+4
 4520 0076 03EB8303 		add	r3, r3, r3, lsl #2
 4521 007a 9900     		lsls	r1, r3, #2
 4522 007c 1144     		add	r1, r1, r2
ARM GAS  /tmp/ccrgBt0i.s 			page 187


 4523 007e 4B68     		ldr	r3, [r1, #4]
 4524              	.LVL373:
 4525 0080 A360     		str	r3, [r4, #8]
 4526 0082 9968     		ldr	r1, [r3, #8]
 4527 0084 E160     		str	r1, [r4, #12]
 4528 0086 9968     		ldr	r1, [r3, #8]
 4529 0088 4D60     		str	r5, [r1, #4]
 4530 008a 9D60     		str	r5, [r3, #8]
 4531 008c E56A     		ldr	r5, [r4, #44]
 4532 008e AB00     		lsls	r3, r5, #2
 4533              	.LVL374:
 4534 0090 5E19     		adds	r6, r3, r5
 4535 0092 B100     		lsls	r1, r6, #2
 4536 0094 5618     		adds	r6, r2, r1
 4537 0096 6661     		str	r6, [r4, #20]
 4538 0098 5158     		ldr	r1, [r2, r1]
 4539 009a 0144     		add	r1, r1, r0
 4540 009c 2B44     		add	r3, r3, r5
 4541 009e 9C00     		lsls	r4, r3, #2
 4542              	.LVL375:
 4543 00a0 1151     		str	r1, [r2, r4]
 4544              	.LBE269:
 4545 00a2 CDE7     		b	.L389
 4546              	.LVL376:
 4547              	.L391:
4134:FreeRTOS/tasks.c ****                 {
 4548              		.loc 1 4134 0
 4549 00a4 426C     		ldr	r2, [r0, #68]
 4550 00a6 054B     		ldr	r3, .L403
 4551 00a8 1B68     		ldr	r3, [r3]
 4552 00aa DB6A     		ldr	r3, [r3, #44]
 4553 00ac 9A42     		cmp	r2, r3
 4554 00ae 01D2     		bcs	.L402
4143:FreeRTOS/tasks.c ****                 }
 4555              		.loc 1 4143 0
 4556 00b0 0120     		movs	r0, #1
 4557              	.LVL377:
4156:FreeRTOS/tasks.c ****     }
 4558              		.loc 1 4156 0
 4559 00b2 C5E7     		b	.L389
 4560              	.LVL378:
 4561              	.L402:
4077:FreeRTOS/tasks.c **** 
 4562              		.loc 1 4077 0
 4563 00b4 0020     		movs	r0, #0
 4564              	.LVL379:
 4565 00b6 C3E7     		b	.L389
 4566              	.LVL380:
 4567              	.L395:
 4568              	.LCFI46:
 4569              		.cfi_def_cfa_offset 0
 4570              		.cfi_restore 4
 4571              		.cfi_restore 5
 4572              		.cfi_restore 6
 4573              		.cfi_restore 14
 4574 00b8 0020     		movs	r0, #0
 4575              	.LVL381:
ARM GAS  /tmp/ccrgBt0i.s 			page 188


4157:FreeRTOS/tasks.c **** 
 4576              		.loc 1 4157 0
 4577 00ba 7047     		bx	lr
 4578              	.L404:
 4579              		.align	2
 4580              	.L403:
 4581 00bc 00000000 		.word	.LANCHOR10
 4582 00c0 00000000 		.word	.LANCHOR4
 4583 00c4 00000000 		.word	.LANCHOR13
 4584              		.cfi_endproc
 4585              	.LFE45:
 4587              		.section	.text.xTaskPriorityDisinherit,"ax",%progbits
 4588              		.align	1
 4589              		.global	xTaskPriorityDisinherit
 4590              		.syntax unified
 4591              		.thumb
 4592              		.thumb_func
 4593              		.fpu softvfp
 4595              	xTaskPriorityDisinherit:
 4596              	.LFB46:
4165:FreeRTOS/tasks.c ****         TCB_t * const pxTCB = pxMutexHolder;
 4597              		.loc 1 4165 0
 4598              		.cfi_startproc
 4599              		@ args = 0, pretend = 0, frame = 0
 4600              		@ frame_needed = 0, uses_anonymous_args = 0
 4601              	.LVL382:
4169:FreeRTOS/tasks.c ****         {
 4602              		.loc 1 4169 0
 4603 0000 0028     		cmp	r0, #0
 4604 0002 4FD0     		beq	.L412
4165:FreeRTOS/tasks.c ****         TCB_t * const pxTCB = pxMutexHolder;
 4605              		.loc 1 4165 0
 4606 0004 70B5     		push	{r4, r5, r6, lr}
 4607              	.LCFI47:
 4608              		.cfi_def_cfa_offset 16
 4609              		.cfi_offset 4, -16
 4610              		.cfi_offset 5, -12
 4611              		.cfi_offset 6, -8
 4612              		.cfi_offset 14, -4
 4613 0006 0446     		mov	r4, r0
4175:FreeRTOS/tasks.c ****             configASSERT( pxTCB->uxMutexesHeld );
 4614              		.loc 1 4175 0
 4615 0008 294B     		ldr	r3, .L419
 4616 000a 1B68     		ldr	r3, [r3]
 4617 000c 8342     		cmp	r3, r0
 4618 000e 08D0     		beq	.L407
 4619              	.LBB270:
 4620              	.LBB271:
 200:FreeRTOS/ARM_CM3/portmacro.h ****         (
 4621              		.loc 2 200 0
 4622              		.syntax unified
 4623              	@ 200 "FreeRTOS/ARM_CM3/portmacro.h" 1
 4624 0010 4FF05003 			mov r3, #80												
 4625 0014 83F31188 		msr basepri, r3											
 4626 0018 BFF36F8F 		isb														
 4627 001c BFF34F8F 		dsb														
 4628              	
ARM GAS  /tmp/ccrgBt0i.s 			page 189


 4629              	@ 0 "" 2
 4630              	.LVL383:
 4631              		.thumb
 4632              		.syntax unified
 4633              	.L408:
 4634 0020 FEE7     		b	.L408
 4635              	.L407:
 4636              	.LBE271:
 4637              	.LBE270:
4176:FreeRTOS/tasks.c ****             ( pxTCB->uxMutexesHeld )--;
 4638              		.loc 1 4176 0
 4639 0022 836C     		ldr	r3, [r0, #72]
 4640 0024 43B9     		cbnz	r3, .L409
 4641              	.LBB272:
 4642              	.LBB273:
 200:FreeRTOS/ARM_CM3/portmacro.h ****         (
 4643              		.loc 2 200 0
 4644              		.syntax unified
 4645              	@ 200 "FreeRTOS/ARM_CM3/portmacro.h" 1
 4646 0026 4FF05003 			mov r3, #80												
 4647 002a 83F31188 		msr basepri, r3											
 4648 002e BFF36F8F 		isb														
 4649 0032 BFF34F8F 		dsb														
 4650              	
 4651              	@ 0 "" 2
 4652              	.LVL384:
 4653              		.thumb
 4654              		.syntax unified
 4655              	.L410:
 4656 0036 FEE7     		b	.L410
 4657              	.L409:
 4658              	.LBE273:
 4659              	.LBE272:
4177:FreeRTOS/tasks.c **** 
 4660              		.loc 1 4177 0
 4661 0038 013B     		subs	r3, r3, #1
 4662 003a 8364     		str	r3, [r0, #72]
4181:FreeRTOS/tasks.c ****             {
 4663              		.loc 1 4181 0
 4664 003c C16A     		ldr	r1, [r0, #44]
 4665 003e 426C     		ldr	r2, [r0, #68]
 4666 0040 9142     		cmp	r1, r2
 4667 0042 31D0     		beq	.L413
4184:FreeRTOS/tasks.c ****                 {
 4668              		.loc 1 4184 0
 4669 0044 002B     		cmp	r3, #0
 4670 0046 31D1     		bne	.L414
4191:FreeRTOS/tasks.c ****                     {
 4671              		.loc 1 4191 0
 4672 0048 051D     		adds	r5, r0, #4
 4673 004a 2846     		mov	r0, r5
 4674              	.LVL385:
 4675 004c FFF7FEFF 		bl	uxListRemove
 4676              	.LVL386:
 4677 0050 40B9     		cbnz	r0, .L411
4193:FreeRTOS/tasks.c ****                     }
 4678              		.loc 1 4193 0
ARM GAS  /tmp/ccrgBt0i.s 			page 190


 4679 0052 E26A     		ldr	r2, [r4, #44]
 4680 0054 0123     		movs	r3, #1
 4681 0056 03FA02F2 		lsl	r2, r3, r2
 4682 005a 1649     		ldr	r1, .L419+4
 4683 005c 0B68     		ldr	r3, [r1]
 4684 005e 23EA0203 		bic	r3, r3, r2
 4685 0062 0B60     		str	r3, [r1]
 4686              	.L411:
4203:FreeRTOS/tasks.c **** 
 4687              		.loc 1 4203 0
 4688 0064 626C     		ldr	r2, [r4, #68]
 4689 0066 E262     		str	r2, [r4, #44]
4208:FreeRTOS/tasks.c ****                     prvAddTaskToReadyList( pxTCB );
 4690              		.loc 1 4208 0
 4691 0068 C2F10703 		rsb	r3, r2, #7
 4692 006c A361     		str	r3, [r4, #24]
4209:FreeRTOS/tasks.c **** 
 4693              		.loc 1 4209 0
 4694 006e 0120     		movs	r0, #1
 4695 0070 00FA02F3 		lsl	r3, r0, r2
 4696 0074 0F49     		ldr	r1, .L419+4
 4697 0076 0E68     		ldr	r6, [r1]
 4698 0078 3343     		orrs	r3, r3, r6
 4699 007a 0B60     		str	r3, [r1]
 4700              	.LBB274:
 4701 007c 0E49     		ldr	r1, .L419+8
 4702 007e 1423     		movs	r3, #20
 4703 0080 03FB0212 		mla	r2, r3, r2, r1
 4704 0084 5268     		ldr	r2, [r2, #4]
 4705              	.LVL387:
 4706 0086 A260     		str	r2, [r4, #8]
 4707 0088 9668     		ldr	r6, [r2, #8]
 4708 008a E660     		str	r6, [r4, #12]
 4709 008c 9668     		ldr	r6, [r2, #8]
 4710 008e 7560     		str	r5, [r6, #4]
 4711 0090 9560     		str	r5, [r2, #8]
 4712 0092 E26A     		ldr	r2, [r4, #44]
 4713              	.LVL388:
 4714 0094 03FB02F3 		mul	r3, r3, r2
 4715 0098 CA18     		adds	r2, r1, r3
 4716 009a 6261     		str	r2, [r4, #20]
 4717 009c CA58     		ldr	r2, [r1, r3]
 4718 009e 0244     		add	r2, r2, r0
 4719 00a0 CA50     		str	r2, [r1, r3]
 4720              	.LVL389:
 4721              	.L405:
 4722              	.LBE274:
4237:FreeRTOS/tasks.c **** 
 4723              		.loc 1 4237 0
 4724 00a2 70BD     		pop	{r4, r5, r6, pc}
 4725              	.LVL390:
 4726              	.L412:
 4727              	.LCFI48:
 4728              		.cfi_def_cfa_offset 0
 4729              		.cfi_restore 4
 4730              		.cfi_restore 5
 4731              		.cfi_restore 6
ARM GAS  /tmp/ccrgBt0i.s 			page 191


 4732              		.cfi_restore 14
4167:FreeRTOS/tasks.c **** 
 4733              		.loc 1 4167 0
 4734 00a4 0020     		movs	r0, #0
 4735              	.LVL391:
4237:FreeRTOS/tasks.c **** 
 4736              		.loc 1 4237 0
 4737 00a6 7047     		bx	lr
 4738              	.LVL392:
 4739              	.L413:
 4740              	.LCFI49:
 4741              		.cfi_def_cfa_offset 16
 4742              		.cfi_offset 4, -16
 4743              		.cfi_offset 5, -12
 4744              		.cfi_offset 6, -8
 4745              		.cfi_offset 14, -4
4167:FreeRTOS/tasks.c **** 
 4746              		.loc 1 4167 0
 4747 00a8 0020     		movs	r0, #0
 4748              	.LVL393:
 4749 00aa FAE7     		b	.L405
 4750              	.LVL394:
 4751              	.L414:
 4752 00ac 0020     		movs	r0, #0
 4753              	.LVL395:
4236:FreeRTOS/tasks.c ****     }
 4754              		.loc 1 4236 0
 4755 00ae F8E7     		b	.L405
 4756              	.L420:
 4757              		.align	2
 4758              	.L419:
 4759 00b0 00000000 		.word	.LANCHOR10
 4760 00b4 00000000 		.word	.LANCHOR13
 4761 00b8 00000000 		.word	.LANCHOR4
 4762              		.cfi_endproc
 4763              	.LFE46:
 4765              		.section	.text.vTaskPriorityDisinheritAfterTimeout,"ax",%progbits
 4766              		.align	1
 4767              		.global	vTaskPriorityDisinheritAfterTimeout
 4768              		.syntax unified
 4769              		.thumb
 4770              		.thumb_func
 4771              		.fpu softvfp
 4773              	vTaskPriorityDisinheritAfterTimeout:
 4774              	.LFB47:
4246:FreeRTOS/tasks.c ****         TCB_t * const pxTCB = pxMutexHolder;
 4775              		.loc 1 4246 0
 4776              		.cfi_startproc
 4777              		@ args = 0, pretend = 0, frame = 0
 4778              		@ frame_needed = 0, uses_anonymous_args = 0
 4779              	.LVL396:
4251:FreeRTOS/tasks.c ****         {
 4780              		.loc 1 4251 0
 4781 0000 0028     		cmp	r0, #0
 4782 0002 5BD0     		beq	.L431
4246:FreeRTOS/tasks.c ****         TCB_t * const pxTCB = pxMutexHolder;
 4783              		.loc 1 4246 0
ARM GAS  /tmp/ccrgBt0i.s 			page 192


 4784 0004 38B5     		push	{r3, r4, r5, lr}
 4785              	.LCFI50:
 4786              		.cfi_def_cfa_offset 16
 4787              		.cfi_offset 3, -16
 4788              		.cfi_offset 4, -12
 4789              		.cfi_offset 5, -8
 4790              		.cfi_offset 14, -4
 4791 0006 0346     		mov	r3, r0
4255:FreeRTOS/tasks.c **** 
 4792              		.loc 1 4255 0
 4793 0008 806C     		ldr	r0, [r0, #72]
 4794              	.LVL397:
 4795 000a 40B9     		cbnz	r0, .L423
 4796              	.LBB275:
 4797              	.LBB276:
 200:FreeRTOS/ARM_CM3/portmacro.h ****         (
 4798              		.loc 2 200 0
 4799              		.syntax unified
 4800              	@ 200 "FreeRTOS/ARM_CM3/portmacro.h" 1
 4801 000c 4FF05003 			mov r3, #80												
 4802 0010 83F31188 		msr basepri, r3											
 4803 0014 BFF36F8F 		isb														
 4804 0018 BFF34F8F 		dsb														
 4805              	
 4806              	@ 0 "" 2
 4807              	.LVL398:
 4808              		.thumb
 4809              		.syntax unified
 4810              	.L424:
 4811 001c FEE7     		b	.L424
 4812              	.LVL399:
 4813              	.L423:
 4814              	.LBE276:
 4815              	.LBE275:
4261:FreeRTOS/tasks.c ****             {
 4816              		.loc 1 4261 0
 4817 001e 5A6C     		ldr	r2, [r3, #68]
 4818 0020 8A42     		cmp	r2, r1
 4819 0022 00D2     		bcs	.L425
4263:FreeRTOS/tasks.c ****             }
 4820              		.loc 1 4263 0
 4821 0024 0A46     		mov	r2, r1
 4822              	.L425:
 4823              	.LVL400:
4271:FreeRTOS/tasks.c ****             {
 4824              		.loc 1 4271 0
 4825 0026 D96A     		ldr	r1, [r3, #44]
 4826              	.LVL401:
 4827 0028 9142     		cmp	r1, r2
 4828 002a 01D0     		beq	.L421
4277:FreeRTOS/tasks.c ****                 {
 4829              		.loc 1 4277 0
 4830 002c 0128     		cmp	r0, #1
 4831 002e 00D0     		beq	.L434
 4832              	.LVL402:
 4833              	.L421:
4343:FreeRTOS/tasks.c **** 
ARM GAS  /tmp/ccrgBt0i.s 			page 193


 4834              		.loc 1 4343 0
 4835 0030 38BD     		pop	{r3, r4, r5, pc}
 4836              	.LVL403:
 4837              	.L434:
4282:FreeRTOS/tasks.c **** 
 4838              		.loc 1 4282 0
 4839 0032 2348     		ldr	r0, .L435
 4840 0034 0068     		ldr	r0, [r0]
 4841 0036 9842     		cmp	r0, r3
 4842 0038 08D1     		bne	.L426
 4843              	.LBB277:
 4844              	.LBB278:
 200:FreeRTOS/ARM_CM3/portmacro.h ****         (
 4845              		.loc 2 200 0
 4846              		.syntax unified
 4847              	@ 200 "FreeRTOS/ARM_CM3/portmacro.h" 1
 4848 003a 4FF05003 			mov r3, #80												
 4849 003e 83F31188 		msr basepri, r3											
 4850 0042 BFF36F8F 		isb														
 4851 0046 BFF34F8F 		dsb														
 4852              	
 4853              	@ 0 "" 2
 4854              	.LVL404:
 4855              		.thumb
 4856              		.syntax unified
 4857              	.L427:
 4858 004a FEE7     		b	.L427
 4859              	.LVL405:
 4860              	.L426:
 4861              	.LBE278:
 4862              	.LBE277:
4289:FreeRTOS/tasks.c **** 
 4863              		.loc 1 4289 0
 4864 004c DA62     		str	r2, [r3, #44]
4293:FreeRTOS/tasks.c ****                     {
 4865              		.loc 1 4293 0
 4866 004e 9869     		ldr	r0, [r3, #24]
 4867 0050 0028     		cmp	r0, #0
 4868 0052 02DB     		blt	.L428
4295:FreeRTOS/tasks.c ****                     }
 4869              		.loc 1 4295 0
 4870 0054 C2F10702 		rsb	r2, r2, #7
 4871              	.LVL406:
 4872 0058 9A61     		str	r2, [r3, #24]
 4873              	.L428:
4308:FreeRTOS/tasks.c ****                     {
 4874              		.loc 1 4308 0
 4875 005a 5A69     		ldr	r2, [r3, #20]
 4876 005c 1948     		ldr	r0, .L435+4
 4877 005e 1424     		movs	r4, #20
 4878 0060 04FB0101 		mla	r1, r4, r1, r0
 4879              	.LVL407:
 4880 0064 8A42     		cmp	r2, r1
 4881 0066 E3D1     		bne	.L421
 4882 0068 1C46     		mov	r4, r3
4310:FreeRTOS/tasks.c ****                         {
 4883              		.loc 1 4310 0
ARM GAS  /tmp/ccrgBt0i.s 			page 194


 4884 006a 1D1D     		adds	r5, r3, #4
 4885 006c 2846     		mov	r0, r5
 4886 006e FFF7FEFF 		bl	uxListRemove
 4887              	.LVL408:
 4888 0072 40B9     		cbnz	r0, .L429
4315:FreeRTOS/tasks.c ****                         }
 4889              		.loc 1 4315 0
 4890 0074 E26A     		ldr	r2, [r4, #44]
 4891 0076 0123     		movs	r3, #1
 4892 0078 03FA02F2 		lsl	r2, r3, r2
 4893 007c 1249     		ldr	r1, .L435+8
 4894 007e 0B68     		ldr	r3, [r1]
 4895 0080 23EA0203 		bic	r3, r3, r2
 4896 0084 0B60     		str	r3, [r1]
 4897              	.L429:
4322:FreeRTOS/tasks.c ****                     }
 4898              		.loc 1 4322 0
 4899 0086 E16A     		ldr	r1, [r4, #44]
 4900 0088 0123     		movs	r3, #1
 4901 008a 8B40     		lsls	r3, r3, r1
 4902 008c 0E4A     		ldr	r2, .L435+8
 4903 008e 1068     		ldr	r0, [r2]
 4904 0090 0343     		orrs	r3, r3, r0
 4905 0092 1360     		str	r3, [r2]
 4906              	.LBB279:
 4907 0094 0B4A     		ldr	r2, .L435+4
 4908 0096 1423     		movs	r3, #20
 4909 0098 03FB0121 		mla	r1, r3, r1, r2
 4910 009c 4968     		ldr	r1, [r1, #4]
 4911              	.LVL409:
 4912 009e A160     		str	r1, [r4, #8]
 4913 00a0 8868     		ldr	r0, [r1, #8]
 4914 00a2 E060     		str	r0, [r4, #12]
 4915 00a4 8868     		ldr	r0, [r1, #8]
 4916 00a6 4560     		str	r5, [r0, #4]
 4917 00a8 8D60     		str	r5, [r1, #8]
 4918 00aa E16A     		ldr	r1, [r4, #44]
 4919              	.LVL410:
 4920 00ac 03FB01F3 		mul	r3, r3, r1
 4921 00b0 D118     		adds	r1, r2, r3
 4922 00b2 6161     		str	r1, [r4, #20]
 4923 00b4 D158     		ldr	r1, [r2, r3]
 4924 00b6 0131     		adds	r1, r1, #1
 4925 00b8 D150     		str	r1, [r2, r3]
 4926              	.LBE279:
4343:FreeRTOS/tasks.c **** 
 4927              		.loc 1 4343 0
 4928 00ba B9E7     		b	.L421
 4929              	.LVL411:
 4930              	.L431:
 4931              	.LCFI51:
 4932              		.cfi_def_cfa_offset 0
 4933              		.cfi_restore 3
 4934              		.cfi_restore 4
 4935              		.cfi_restore 5
 4936              		.cfi_restore 14
 4937 00bc 7047     		bx	lr
ARM GAS  /tmp/ccrgBt0i.s 			page 195


 4938              	.L436:
 4939 00be 00BF     		.align	2
 4940              	.L435:
 4941 00c0 00000000 		.word	.LANCHOR10
 4942 00c4 00000000 		.word	.LANCHOR4
 4943 00c8 00000000 		.word	.LANCHOR13
 4944              		.cfi_endproc
 4945              	.LFE47:
 4947              		.section	.text.uxTaskResetEventItemValue,"ax",%progbits
 4948              		.align	1
 4949              		.global	uxTaskResetEventItemValue
 4950              		.syntax unified
 4951              		.thumb
 4952              		.thumb_func
 4953              		.fpu softvfp
 4955              	uxTaskResetEventItemValue:
 4956              	.LFB48:
4672:FreeRTOS/tasks.c ****     TickType_t uxReturn;
 4957              		.loc 1 4672 0
 4958              		.cfi_startproc
 4959              		@ args = 0, pretend = 0, frame = 0
 4960              		@ frame_needed = 0, uses_anonymous_args = 0
 4961              		@ link register save eliminated.
4675:FreeRTOS/tasks.c **** 
 4962              		.loc 1 4675 0
 4963 0000 044A     		ldr	r2, .L438
 4964 0002 1368     		ldr	r3, [r2]
 4965 0004 9869     		ldr	r0, [r3, #24]
 4966              	.LVL412:
4679:FreeRTOS/tasks.c **** 
 4967              		.loc 1 4679 0
 4968 0006 1368     		ldr	r3, [r2]
 4969 0008 DB6A     		ldr	r3, [r3, #44]
 4970 000a 1268     		ldr	r2, [r2]
 4971 000c C3F10703 		rsb	r3, r3, #7
 4972 0010 9361     		str	r3, [r2, #24]
4682:FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 4973              		.loc 1 4682 0
 4974 0012 7047     		bx	lr
 4975              	.L439:
 4976              		.align	2
 4977              	.L438:
 4978 0014 00000000 		.word	.LANCHOR10
 4979              		.cfi_endproc
 4980              	.LFE48:
 4982              		.section	.text.pvTaskIncrementMutexHeldCount,"ax",%progbits
 4983              		.align	1
 4984              		.global	pvTaskIncrementMutexHeldCount
 4985              		.syntax unified
 4986              		.thumb
 4987              		.thumb_func
 4988              		.fpu softvfp
 4990              	pvTaskIncrementMutexHeldCount:
 4991              	.LFB49:
4688:FreeRTOS/tasks.c ****         /* If xSemaphoreCreateMutex() is called before any tasks have been created
 4992              		.loc 1 4688 0
 4993              		.cfi_startproc
ARM GAS  /tmp/ccrgBt0i.s 			page 196


 4994              		@ args = 0, pretend = 0, frame = 0
 4995              		@ frame_needed = 0, uses_anonymous_args = 0
 4996              		@ link register save eliminated.
4691:FreeRTOS/tasks.c ****         {
 4997              		.loc 1 4691 0
 4998 0000 054B     		ldr	r3, .L442
 4999 0002 1B68     		ldr	r3, [r3]
 5000 0004 23B1     		cbz	r3, .L441
4693:FreeRTOS/tasks.c ****         }
 5001              		.loc 1 4693 0
 5002 0006 044B     		ldr	r3, .L442
 5003 0008 1A68     		ldr	r2, [r3]
 5004 000a 936C     		ldr	r3, [r2, #72]
 5005 000c 0133     		adds	r3, r3, #1
 5006 000e 9364     		str	r3, [r2, #72]
 5007              	.L441:
4696:FreeRTOS/tasks.c ****     }
 5008              		.loc 1 4696 0
 5009 0010 014B     		ldr	r3, .L442
 5010 0012 1868     		ldr	r0, [r3]
4697:FreeRTOS/tasks.c **** 
 5011              		.loc 1 4697 0
 5012 0014 7047     		bx	lr
 5013              	.L443:
 5014 0016 00BF     		.align	2
 5015              	.L442:
 5016 0018 00000000 		.word	.LANCHOR10
 5017              		.cfi_endproc
 5018              	.LFE49:
 5020              		.section	.text.ulTaskGenericNotifyTake,"ax",%progbits
 5021              		.align	1
 5022              		.global	ulTaskGenericNotifyTake
 5023              		.syntax unified
 5024              		.thumb
 5025              		.thumb_func
 5026              		.fpu softvfp
 5028              	ulTaskGenericNotifyTake:
 5029              	.LFB50:
4707:FreeRTOS/tasks.c ****         uint32_t ulReturn;
 5030              		.loc 1 4707 0
 5031              		.cfi_startproc
 5032              		@ args = 0, pretend = 0, frame = 0
 5033              		@ frame_needed = 0, uses_anonymous_args = 0
 5034              	.LVL413:
4710:FreeRTOS/tasks.c **** 
 5035              		.loc 1 4710 0
 5036 0000 40B1     		cbz	r0, .L445
 5037              	.LBB280:
 5038              	.LBB281:
 200:FreeRTOS/ARM_CM3/portmacro.h ****         (
 5039              		.loc 2 200 0
 5040              		.syntax unified
 5041              	@ 200 "FreeRTOS/ARM_CM3/portmacro.h" 1
 5042 0002 4FF05003 			mov r3, #80												
 5043 0006 83F31188 		msr basepri, r3											
 5044 000a BFF36F8F 		isb														
 5045 000e BFF34F8F 		dsb														
ARM GAS  /tmp/ccrgBt0i.s 			page 197


 5046              	
 5047              	@ 0 "" 2
 5048              	.LVL414:
 5049              		.thumb
 5050              		.syntax unified
 5051              	.L446:
 5052 0012 FEE7     		b	.L446
 5053              	.L445:
 5054              	.LBE281:
 5055              	.LBE280:
4707:FreeRTOS/tasks.c ****         uint32_t ulReturn;
 5056              		.loc 1 4707 0
 5057 0014 70B5     		push	{r4, r5, r6, lr}
 5058              	.LCFI52:
 5059              		.cfi_def_cfa_offset 16
 5060              		.cfi_offset 4, -16
 5061              		.cfi_offset 5, -12
 5062              		.cfi_offset 6, -8
 5063              		.cfi_offset 14, -4
 5064 0016 0446     		mov	r4, r0
 5065 0018 1546     		mov	r5, r2
 5066 001a 0E46     		mov	r6, r1
4712:FreeRTOS/tasks.c ****         {
 5067              		.loc 1 4712 0
 5068 001c FFF7FEFF 		bl	vPortEnterCritical
 5069              	.LVL415:
4715:FreeRTOS/tasks.c ****             {
 5070              		.loc 1 4715 0
 5071 0020 204B     		ldr	r3, .L452
 5072 0022 1B68     		ldr	r3, [r3]
 5073 0024 04F11202 		add	r2, r4, #18
 5074 0028 03EB8203 		add	r3, r3, r2, lsl #2
 5075 002c 5B68     		ldr	r3, [r3, #4]
 5076 002e 93B9     		cbnz	r3, .L447
4718:FreeRTOS/tasks.c **** 
 5077              		.loc 1 4718 0
 5078 0030 1C4B     		ldr	r3, .L452
 5079 0032 1B68     		ldr	r3, [r3]
 5080 0034 2344     		add	r3, r3, r4
 5081 0036 0122     		movs	r2, #1
 5082 0038 83F85020 		strb	r2, [r3, #80]
4720:FreeRTOS/tasks.c ****                 {
 5083              		.loc 1 4720 0
 5084 003c 5DB1     		cbz	r5, .L447
4722:FreeRTOS/tasks.c ****                     traceTASK_NOTIFY_TAKE_BLOCK( uxIndexToWait );
 5085              		.loc 1 4722 0
 5086 003e 1146     		mov	r1, r2
 5087 0040 2846     		mov	r0, r5
 5088 0042 FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
 5089              	.LVL416:
4729:FreeRTOS/tasks.c ****                 }
 5090              		.loc 1 4729 0
 5091 0046 184B     		ldr	r3, .L452+4
 5092 0048 4FF08052 		mov	r2, #268435456
 5093 004c 1A60     		str	r2, [r3]
 5094              		.syntax unified
 5095              	@ 4729 "FreeRTOS/tasks.c" 1
ARM GAS  /tmp/ccrgBt0i.s 			page 198


 5096 004e BFF34F8F 		dsb
 5097              	@ 0 "" 2
 5098              	@ 4729 "FreeRTOS/tasks.c" 1
 5099 0052 BFF36F8F 		isb
 5100              	@ 0 "" 2
 5101              		.thumb
 5102              		.syntax unified
 5103              	.L447:
4741:FreeRTOS/tasks.c **** 
 5104              		.loc 1 4741 0
 5105 0056 FFF7FEFF 		bl	vPortExitCritical
 5106              	.LVL417:
4743:FreeRTOS/tasks.c ****         {
 5107              		.loc 1 4743 0
 5108 005a FFF7FEFF 		bl	vPortEnterCritical
 5109              	.LVL418:
4746:FreeRTOS/tasks.c **** 
 5110              		.loc 1 4746 0
 5111 005e 114B     		ldr	r3, .L452
 5112 0060 1B68     		ldr	r3, [r3]
 5113 0062 04F11202 		add	r2, r4, #18
 5114 0066 03EB8203 		add	r3, r3, r2, lsl #2
 5115 006a 5D68     		ldr	r5, [r3, #4]
 5116              	.LVL419:
4748:FreeRTOS/tasks.c ****             {
 5117              		.loc 1 4748 0
 5118 006c 35B1     		cbz	r5, .L448
4750:FreeRTOS/tasks.c ****                 {
 5119              		.loc 1 4750 0
 5120 006e 7EB1     		cbz	r6, .L449
4752:FreeRTOS/tasks.c ****                 }
 5121              		.loc 1 4752 0
 5122 0070 0C4B     		ldr	r3, .L452
 5123 0072 1B68     		ldr	r3, [r3]
 5124 0074 03EB8203 		add	r3, r3, r2, lsl #2
 5125 0078 0022     		movs	r2, #0
 5126 007a 5A60     		str	r2, [r3, #4]
 5127              	.L448:
4764:FreeRTOS/tasks.c ****         }
 5128              		.loc 1 4764 0
 5129 007c 094B     		ldr	r3, .L452
 5130 007e 1B68     		ldr	r3, [r3]
 5131 0080 1C44     		add	r4, r4, r3
 5132              	.LVL420:
 5133 0082 0023     		movs	r3, #0
 5134 0084 84F85030 		strb	r3, [r4, #80]
4766:FreeRTOS/tasks.c **** 
 5135              		.loc 1 4766 0
 5136 0088 FFF7FEFF 		bl	vPortExitCritical
 5137              	.LVL421:
4769:FreeRTOS/tasks.c **** 
 5138              		.loc 1 4769 0
 5139 008c 2846     		mov	r0, r5
 5140 008e 70BD     		pop	{r4, r5, r6, pc}
 5141              	.LVL422:
 5142              	.L449:
4756:FreeRTOS/tasks.c ****                 }
ARM GAS  /tmp/ccrgBt0i.s 			page 199


 5143              		.loc 1 4756 0
 5144 0090 044B     		ldr	r3, .L452
 5145 0092 1B68     		ldr	r3, [r3]
 5146 0094 6A1E     		subs	r2, r5, #1
 5147 0096 04F11201 		add	r1, r4, #18
 5148 009a 03EB8103 		add	r3, r3, r1, lsl #2
 5149 009e 5A60     		str	r2, [r3, #4]
 5150 00a0 ECE7     		b	.L448
 5151              	.L453:
 5152 00a2 00BF     		.align	2
 5153              	.L452:
 5154 00a4 00000000 		.word	.LANCHOR10
 5155 00a8 04ED00E0 		.word	-536810236
 5156              		.cfi_endproc
 5157              	.LFE50:
 5159              		.section	.text.xTaskGenericNotifyWait,"ax",%progbits
 5160              		.align	1
 5161              		.global	xTaskGenericNotifyWait
 5162              		.syntax unified
 5163              		.thumb
 5164              		.thumb_func
 5165              		.fpu softvfp
 5167              	xTaskGenericNotifyWait:
 5168              	.LFB51:
4781:FreeRTOS/tasks.c ****         BaseType_t xReturn;
 5169              		.loc 1 4781 0
 5170              		.cfi_startproc
 5171              		@ args = 4, pretend = 0, frame = 0
 5172              		@ frame_needed = 0, uses_anonymous_args = 0
 5173              	.LVL423:
 5174 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 5175              	.LCFI53:
 5176              		.cfi_def_cfa_offset 24
 5177              		.cfi_offset 4, -24
 5178              		.cfi_offset 5, -20
 5179              		.cfi_offset 6, -16
 5180              		.cfi_offset 7, -12
 5181              		.cfi_offset 8, -8
 5182              		.cfi_offset 14, -4
 5183 0004 069E     		ldr	r6, [sp, #24]
4784:FreeRTOS/tasks.c **** 
 5184              		.loc 1 4784 0
 5185 0006 40B1     		cbz	r0, .L455
 5186              	.LBB282:
 5187              	.LBB283:
 200:FreeRTOS/ARM_CM3/portmacro.h ****         (
 5188              		.loc 2 200 0
 5189              		.syntax unified
 5190              	@ 200 "FreeRTOS/ARM_CM3/portmacro.h" 1
 5191 0008 4FF05003 			mov r3, #80												
 5192 000c 83F31188 		msr basepri, r3											
 5193 0010 BFF36F8F 		isb														
 5194 0014 BFF34F8F 		dsb														
 5195              	
 5196              	@ 0 "" 2
 5197              	.LVL424:
 5198              		.thumb
ARM GAS  /tmp/ccrgBt0i.s 			page 200


 5199              		.syntax unified
 5200              	.L456:
 5201 0018 FEE7     		b	.L456
 5202              	.LVL425:
 5203              	.L455:
 5204 001a 0446     		mov	r4, r0
 5205 001c 1D46     		mov	r5, r3
 5206 001e 1746     		mov	r7, r2
 5207 0020 8846     		mov	r8, r1
 5208              	.LBE283:
 5209              	.LBE282:
4786:FreeRTOS/tasks.c ****         {
 5210              		.loc 1 4786 0
 5211 0022 FFF7FEFF 		bl	vPortEnterCritical
 5212              	.LVL426:
4789:FreeRTOS/tasks.c ****             {
 5213              		.loc 1 4789 0
 5214 0026 284B     		ldr	r3, .L462
 5215 0028 1B68     		ldr	r3, [r3]
 5216 002a 2344     		add	r3, r3, r4
 5217 002c 93F85030 		ldrb	r3, [r3, #80]	@ zero_extendqisi2
 5218 0030 DBB2     		uxtb	r3, r3
 5219 0032 022B     		cmp	r3, #2
 5220 0034 1BD0     		beq	.L457
4794:FreeRTOS/tasks.c **** 
 5221              		.loc 1 4794 0
 5222 0036 2449     		ldr	r1, .L462
 5223 0038 0B68     		ldr	r3, [r1]
 5224 003a 04F11202 		add	r2, r4, #18
 5225 003e 03EB8203 		add	r3, r3, r2, lsl #2
 5226 0042 5A68     		ldr	r2, [r3, #4]
 5227 0044 22EA0802 		bic	r2, r2, r8
 5228 0048 5A60     		str	r2, [r3, #4]
4797:FreeRTOS/tasks.c **** 
 5229              		.loc 1 4797 0
 5230 004a 0B68     		ldr	r3, [r1]
 5231 004c 2344     		add	r3, r3, r4
 5232 004e 0122     		movs	r2, #1
 5233 0050 83F85020 		strb	r2, [r3, #80]
4799:FreeRTOS/tasks.c ****                 {
 5234              		.loc 1 4799 0
 5235 0054 5EB1     		cbz	r6, .L457
4801:FreeRTOS/tasks.c ****                     traceTASK_NOTIFY_WAIT_BLOCK( uxIndexToWait );
 5236              		.loc 1 4801 0
 5237 0056 1146     		mov	r1, r2
 5238 0058 3046     		mov	r0, r6
 5239 005a FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
 5240              	.LVL427:
4808:FreeRTOS/tasks.c ****                 }
 5241              		.loc 1 4808 0
 5242 005e 1B4B     		ldr	r3, .L462+4
 5243 0060 4FF08052 		mov	r2, #268435456
 5244 0064 1A60     		str	r2, [r3]
 5245              	.LVL428:
 5246              		.syntax unified
 5247              	@ 4808 "FreeRTOS/tasks.c" 1
 5248 0066 BFF34F8F 		dsb
ARM GAS  /tmp/ccrgBt0i.s 			page 201


 5249              	@ 0 "" 2
 5250              	@ 4808 "FreeRTOS/tasks.c" 1
 5251 006a BFF36F8F 		isb
 5252              	@ 0 "" 2
 5253              		.thumb
 5254              		.syntax unified
 5255              	.L457:
4820:FreeRTOS/tasks.c **** 
 5256              		.loc 1 4820 0
 5257 006e FFF7FEFF 		bl	vPortExitCritical
 5258              	.LVL429:
4822:FreeRTOS/tasks.c ****         {
 5259              		.loc 1 4822 0
 5260 0072 FFF7FEFF 		bl	vPortEnterCritical
 5261              	.LVL430:
4826:FreeRTOS/tasks.c ****             {
 5262              		.loc 1 4826 0
 5263 0076 3DB1     		cbz	r5, .L458
4830:FreeRTOS/tasks.c ****             }
 5264              		.loc 1 4830 0
 5265 0078 134B     		ldr	r3, .L462
 5266 007a 1B68     		ldr	r3, [r3]
 5267 007c 04F11202 		add	r2, r4, #18
 5268 0080 03EB8203 		add	r3, r3, r2, lsl #2
 5269 0084 5B68     		ldr	r3, [r3, #4]
 5270 0086 2B60     		str	r3, [r5]
 5271              	.L458:
4837:FreeRTOS/tasks.c ****             {
 5272              		.loc 1 4837 0
 5273 0088 0F4B     		ldr	r3, .L462
 5274 008a 1B68     		ldr	r3, [r3]
 5275 008c 2344     		add	r3, r3, r4
 5276 008e 93F85030 		ldrb	r3, [r3, #80]	@ zero_extendqisi2
 5277 0092 DBB2     		uxtb	r3, r3
 5278 0094 022B     		cmp	r3, #2
 5279 0096 15D1     		bne	.L460
4846:FreeRTOS/tasks.c ****                 xReturn = pdTRUE;
 5280              		.loc 1 4846 0
 5281 0098 0B4B     		ldr	r3, .L462
 5282 009a 1B68     		ldr	r3, [r3]
 5283 009c 04F11202 		add	r2, r4, #18
 5284 00a0 03EB8203 		add	r3, r3, r2, lsl #2
 5285 00a4 5A68     		ldr	r2, [r3, #4]
 5286 00a6 22EA0702 		bic	r2, r2, r7
 5287 00aa 5A60     		str	r2, [r3, #4]
 5288              	.LVL431:
4847:FreeRTOS/tasks.c ****             }
 5289              		.loc 1 4847 0
 5290 00ac 0125     		movs	r5, #1
 5291              	.LVL432:
 5292              	.L459:
4850:FreeRTOS/tasks.c ****         }
 5293              		.loc 1 4850 0
 5294 00ae 064B     		ldr	r3, .L462
 5295 00b0 1B68     		ldr	r3, [r3]
 5296 00b2 1C44     		add	r4, r4, r3
 5297              	.LVL433:
ARM GAS  /tmp/ccrgBt0i.s 			page 202


 5298 00b4 0023     		movs	r3, #0
 5299 00b6 84F85030 		strb	r3, [r4, #80]
4852:FreeRTOS/tasks.c **** 
 5300              		.loc 1 4852 0
 5301 00ba FFF7FEFF 		bl	vPortExitCritical
 5302              	.LVL434:
4855:FreeRTOS/tasks.c **** 
 5303              		.loc 1 4855 0
 5304 00be 2846     		mov	r0, r5
 5305 00c0 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 5306              	.LVL435:
 5307              	.L460:
4840:FreeRTOS/tasks.c ****             }
 5308              		.loc 1 4840 0
 5309 00c4 0025     		movs	r5, #0
 5310              	.LVL436:
 5311 00c6 F2E7     		b	.L459
 5312              	.L463:
 5313              		.align	2
 5314              	.L462:
 5315 00c8 00000000 		.word	.LANCHOR10
 5316 00cc 04ED00E0 		.word	-536810236
 5317              		.cfi_endproc
 5318              	.LFE51:
 5320              		.section	.text.xTaskGenericNotify,"ax",%progbits
 5321              		.align	1
 5322              		.global	xTaskGenericNotify
 5323              		.syntax unified
 5324              		.thumb
 5325              		.thumb_func
 5326              		.fpu softvfp
 5328              	xTaskGenericNotify:
 5329              	.LFB52:
4867:FreeRTOS/tasks.c ****         TCB_t * pxTCB;
 5330              		.loc 1 4867 0
 5331              		.cfi_startproc
 5332              		@ args = 4, pretend = 0, frame = 0
 5333              		@ frame_needed = 0, uses_anonymous_args = 0
 5334              	.LVL437:
 5335 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 5336              	.LCFI54:
 5337              		.cfi_def_cfa_offset 24
 5338              		.cfi_offset 4, -24
 5339              		.cfi_offset 5, -20
 5340              		.cfi_offset 6, -16
 5341              		.cfi_offset 7, -12
 5342              		.cfi_offset 8, -8
 5343              		.cfi_offset 14, -4
 5344 0004 DDF81880 		ldr	r8, [sp, #24]
 5345              	.LVL438:
4872:FreeRTOS/tasks.c ****         configASSERT( xTaskToNotify );
 5346              		.loc 1 4872 0
 5347 0008 41B1     		cbz	r1, .L465
 5348              	.LBB284:
 5349              	.LBB285:
 200:FreeRTOS/ARM_CM3/portmacro.h ****         (
 5350              		.loc 2 200 0
ARM GAS  /tmp/ccrgBt0i.s 			page 203


 5351              		.syntax unified
 5352              	@ 200 "FreeRTOS/ARM_CM3/portmacro.h" 1
 5353 000a 4FF05003 			mov r3, #80												
 5354 000e 83F31188 		msr basepri, r3											
 5355 0012 BFF36F8F 		isb														
 5356 0016 BFF34F8F 		dsb														
 5357              	
 5358              	@ 0 "" 2
 5359              	.LVL439:
 5360              		.thumb
 5361              		.syntax unified
 5362              	.L466:
 5363 001a FEE7     		b	.L466
 5364              	.LVL440:
 5365              	.L465:
 5366 001c 0C46     		mov	r4, r1
 5367              	.LBE285:
 5368              	.LBE284:
4873:FreeRTOS/tasks.c ****         pxTCB = xTaskToNotify;
 5369              		.loc 1 4873 0
 5370 001e E0B1     		cbz	r0, .L486
 5371 0020 1F46     		mov	r7, r3
 5372 0022 1646     		mov	r6, r2
 5373 0024 0546     		mov	r5, r0
 5374              	.LVL441:
4876:FreeRTOS/tasks.c ****         {
 5375              		.loc 1 4876 0
 5376 0026 FFF7FEFF 		bl	vPortEnterCritical
 5377              	.LVL442:
4878:FreeRTOS/tasks.c ****             {
 5378              		.loc 1 4878 0
 5379 002a B8F1000F 		cmp	r8, #0
 5380 002e 06D0     		beq	.L469
4880:FreeRTOS/tasks.c ****             }
 5381              		.loc 1 4880 0
 5382 0030 04F11203 		add	r3, r4, #18
 5383 0034 05EB8303 		add	r3, r5, r3, lsl #2
 5384 0038 5B68     		ldr	r3, [r3, #4]
 5385 003a C8F80030 		str	r3, [r8]
 5386              	.L469:
4883:FreeRTOS/tasks.c **** 
 5387              		.loc 1 4883 0
 5388 003e 2B19     		adds	r3, r5, r4
 5389 0040 93F85020 		ldrb	r2, [r3, #80]	@ zero_extendqisi2
 5390 0044 D2B2     		uxtb	r2, r2
 5391              	.LVL443:
4885:FreeRTOS/tasks.c **** 
 5392              		.loc 1 4885 0
 5393 0046 0221     		movs	r1, #2
 5394 0048 83F85010 		strb	r1, [r3, #80]
4887:FreeRTOS/tasks.c ****             {
 5395              		.loc 1 4887 0
 5396 004c 042F     		cmp	r7, #4
 5397 004e 67D8     		bhi	.L470
 5398 0050 DFE807F0 		tbb	[pc, r7]
 5399              	.L472:
 5400 0054 72       		.byte	(.L482-.L472)/2
ARM GAS  /tmp/ccrgBt0i.s 			page 204


 5401 0055 0C       		.byte	(.L473-.L472)/2
 5402 0056 4D       		.byte	(.L474-.L472)/2
 5403 0057 56       		.byte	(.L475-.L472)/2
 5404 0058 5D       		.byte	(.L476-.L472)/2
 5405              	.LVL444:
 5406 0059 00       		.p2align 1
 5407              	.L486:
 5408              	.LBB286:
 5409              	.LBB287:
 200:FreeRTOS/ARM_CM3/portmacro.h ****         (
 5410              		.loc 2 200 0
 5411              		.syntax unified
 5412              	@ 200 "FreeRTOS/ARM_CM3/portmacro.h" 1
 5413 005a 4FF05003 			mov r3, #80												
 5414 005e 83F31188 		msr basepri, r3											
 5415 0062 BFF36F8F 		isb														
 5416 0066 BFF34F8F 		dsb														
 5417              	
 5418              	@ 0 "" 2
 5419              	.LVL445:
 5420              		.thumb
 5421              		.syntax unified
 5422              	.L468:
 5423 006a FEE7     		b	.L468
 5424              	.LVL446:
 5425              	.L473:
 5426              	.LBE287:
 5427              	.LBE286:
4890:FreeRTOS/tasks.c ****                     break;
 5428              		.loc 1 4890 0
 5429 006c 04F11203 		add	r3, r4, #18
 5430 0070 05EB8303 		add	r3, r5, r3, lsl #2
 5431 0074 5968     		ldr	r1, [r3, #4]
 5432 0076 0E43     		orrs	r6, r6, r1
 5433              	.LVL447:
 5434 0078 5E60     		str	r6, [r3, #4]
4869:FreeRTOS/tasks.c ****         uint8_t ucOriginalNotifyState;
 5435              		.loc 1 4869 0
 5436 007a 0124     		movs	r4, #1
 5437              	.LVL448:
 5438              	.L471:
4935:FreeRTOS/tasks.c ****             {
 5439              		.loc 1 4935 0
 5440 007c 012A     		cmp	r2, #1
 5441 007e 6FD1     		bne	.L478
 5442              	.LBB288:
4937:FreeRTOS/tasks.c ****                 prvAddTaskToReadyList( pxTCB );
 5443              		.loc 1 4937 0
 5444 0080 6B69     		ldr	r3, [r5, #20]
 5445              	.LVL449:
 5446 0082 AA68     		ldr	r2, [r5, #8]
 5447              	.LVL450:
 5448 0084 E968     		ldr	r1, [r5, #12]
 5449 0086 9160     		str	r1, [r2, #8]
 5450 0088 EA68     		ldr	r2, [r5, #12]
 5451 008a A968     		ldr	r1, [r5, #8]
 5452 008c 5160     		str	r1, [r2, #4]
ARM GAS  /tmp/ccrgBt0i.s 			page 205


 5453 008e 5A68     		ldr	r2, [r3, #4]
 5454 0090 281D     		adds	r0, r5, #4
 5455 0092 8242     		cmp	r2, r0
 5456 0094 01D1     		bne	.L479
4937:FreeRTOS/tasks.c ****                 prvAddTaskToReadyList( pxTCB );
 5457              		.loc 1 4937 0 is_stmt 0 discriminator 1
 5458 0096 EA68     		ldr	r2, [r5, #12]
 5459 0098 5A60     		str	r2, [r3, #4]
 5460              	.L479:
4937:FreeRTOS/tasks.c ****                 prvAddTaskToReadyList( pxTCB );
 5461              		.loc 1 4937 0 discriminator 3
 5462 009a 0022     		movs	r2, #0
 5463 009c 6A61     		str	r2, [r5, #20]
 5464 009e 1A68     		ldr	r2, [r3]
 5465 00a0 013A     		subs	r2, r2, #1
 5466 00a2 1A60     		str	r2, [r3]
 5467              	.LBE288:
4938:FreeRTOS/tasks.c **** 
 5468              		.loc 1 4938 0 is_stmt 1 discriminator 3
 5469 00a4 E96A     		ldr	r1, [r5, #44]
 5470 00a6 0123     		movs	r3, #1
 5471              	.LVL451:
 5472 00a8 8B40     		lsls	r3, r3, r1
 5473 00aa 304A     		ldr	r2, .L487
 5474 00ac 1668     		ldr	r6, [r2]
 5475 00ae 3343     		orrs	r3, r3, r6
 5476 00b0 1360     		str	r3, [r2]
 5477              	.LBB289:
 5478 00b2 2F4A     		ldr	r2, .L487+4
 5479 00b4 1423     		movs	r3, #20
 5480 00b6 03FB0121 		mla	r1, r3, r1, r2
 5481 00ba 4968     		ldr	r1, [r1, #4]
 5482              	.LVL452:
 5483 00bc A960     		str	r1, [r5, #8]
 5484 00be 8E68     		ldr	r6, [r1, #8]
 5485 00c0 EE60     		str	r6, [r5, #12]
 5486 00c2 8E68     		ldr	r6, [r1, #8]
 5487 00c4 7060     		str	r0, [r6, #4]
 5488 00c6 8860     		str	r0, [r1, #8]
 5489 00c8 E96A     		ldr	r1, [r5, #44]
 5490              	.LVL453:
 5491 00ca 03FB01F3 		mul	r3, r3, r1
 5492 00ce D118     		adds	r1, r2, r3
 5493 00d0 6961     		str	r1, [r5, #20]
 5494 00d2 D158     		ldr	r1, [r2, r3]
 5495 00d4 0131     		adds	r1, r1, #1
 5496 00d6 D150     		str	r1, [r2, r3]
 5497              	.LBE289:
4941:FreeRTOS/tasks.c **** 
 5498              		.loc 1 4941 0 discriminator 3
 5499 00d8 AB6A     		ldr	r3, [r5, #40]
 5500 00da 9BB3     		cbz	r3, .L480
 5501              	.LBB290:
 5502              	.LBB291:
 200:FreeRTOS/ARM_CM3/portmacro.h ****         (
 5503              		.loc 2 200 0
 5504              		.syntax unified
ARM GAS  /tmp/ccrgBt0i.s 			page 206


 5505              	@ 200 "FreeRTOS/ARM_CM3/portmacro.h" 1
 5506 00dc 4FF05003 			mov r3, #80												
 5507 00e0 83F31188 		msr basepri, r3											
 5508 00e4 BFF36F8F 		isb														
 5509 00e8 BFF34F8F 		dsb														
 5510              	
 5511              	@ 0 "" 2
 5512              	.LVL454:
 5513              		.thumb
 5514              		.syntax unified
 5515              	.L481:
 5516 00ec FEE7     		b	.L481
 5517              	.LVL455:
 5518              	.L474:
 5519              	.LBE291:
 5520              	.LBE290:
4894:FreeRTOS/tasks.c ****                     break;
 5521              		.loc 1 4894 0
 5522 00ee 04F11203 		add	r3, r4, #18
 5523 00f2 05EB8303 		add	r3, r5, r3, lsl #2
 5524 00f6 5968     		ldr	r1, [r3, #4]
 5525 00f8 0131     		adds	r1, r1, #1
 5526 00fa 5960     		str	r1, [r3, #4]
4869:FreeRTOS/tasks.c ****         uint8_t ucOriginalNotifyState;
 5527              		.loc 1 4869 0
 5528 00fc 0124     		movs	r4, #1
 5529              	.LVL456:
4895:FreeRTOS/tasks.c **** 
 5530              		.loc 1 4895 0
 5531 00fe BDE7     		b	.L471
 5532              	.LVL457:
 5533              	.L475:
4898:FreeRTOS/tasks.c ****                     break;
 5534              		.loc 1 4898 0
 5535 0100 04F11203 		add	r3, r4, #18
 5536 0104 05EB8303 		add	r3, r5, r3, lsl #2
 5537 0108 5E60     		str	r6, [r3, #4]
4869:FreeRTOS/tasks.c ****         uint8_t ucOriginalNotifyState;
 5538              		.loc 1 4869 0
 5539 010a 0124     		movs	r4, #1
 5540              	.LVL458:
4899:FreeRTOS/tasks.c **** 
 5541              		.loc 1 4899 0
 5542 010c B6E7     		b	.L471
 5543              	.LVL459:
 5544              	.L476:
4903:FreeRTOS/tasks.c ****                     {
 5545              		.loc 1 4903 0
 5546 010e 022A     		cmp	r2, #2
 5547 0110 14D0     		beq	.L483
4905:FreeRTOS/tasks.c ****                     }
 5548              		.loc 1 4905 0
 5549 0112 04F11203 		add	r3, r4, #18
 5550 0116 05EB8303 		add	r3, r5, r3, lsl #2
 5551 011a 5E60     		str	r6, [r3, #4]
4869:FreeRTOS/tasks.c ****         uint8_t ucOriginalNotifyState;
 5552              		.loc 1 4869 0
ARM GAS  /tmp/ccrgBt0i.s 			page 207


 5553 011c 0124     		movs	r4, #1
 5554              	.LVL460:
 5555 011e ADE7     		b	.L471
 5556              	.LVL461:
 5557              	.L470:
4926:FreeRTOS/tasks.c **** 
 5558              		.loc 1 4926 0
 5559 0120 144B     		ldr	r3, .L487+8
 5560 0122 1B68     		ldr	r3, [r3]
 5561 0124 63B1     		cbz	r3, .L484
 5562              	.LBB292:
 5563              	.LBB293:
 200:FreeRTOS/ARM_CM3/portmacro.h ****         (
 5564              		.loc 2 200 0
 5565              		.syntax unified
 5566              	@ 200 "FreeRTOS/ARM_CM3/portmacro.h" 1
 5567 0126 4FF05003 			mov r3, #80												
 5568 012a 83F31188 		msr basepri, r3											
 5569 012e BFF36F8F 		isb														
 5570 0132 BFF34F8F 		dsb														
 5571              	
 5572              	@ 0 "" 2
 5573              	.LVL462:
 5574              		.thumb
 5575              		.syntax unified
 5576              	.L477:
 5577 0136 FEE7     		b	.L477
 5578              	.L482:
 5579              	.LBE293:
 5580              	.LBE292:
4869:FreeRTOS/tasks.c ****         uint8_t ucOriginalNotifyState;
 5581              		.loc 1 4869 0
 5582 0138 0124     		movs	r4, #1
 5583              	.LVL463:
 5584 013a 9FE7     		b	.L471
 5585              	.LVL464:
 5586              	.L483:
4910:FreeRTOS/tasks.c ****                     }
 5587              		.loc 1 4910 0
 5588 013c 0024     		movs	r4, #0
 5589              	.LVL465:
 5590 013e 9DE7     		b	.L471
 5591              	.LVL466:
 5592              	.L484:
4869:FreeRTOS/tasks.c ****         uint8_t ucOriginalNotifyState;
 5593              		.loc 1 4869 0
 5594 0140 0124     		movs	r4, #1
 5595              	.LVL467:
 5596 0142 9BE7     		b	.L471
 5597              	.LVL468:
 5598              	.L480:
4959:FreeRTOS/tasks.c ****                 {
 5599              		.loc 1 4959 0
 5600 0144 EA6A     		ldr	r2, [r5, #44]
 5601 0146 0C4B     		ldr	r3, .L487+12
 5602 0148 1B68     		ldr	r3, [r3]
 5603 014a DB6A     		ldr	r3, [r3, #44]
ARM GAS  /tmp/ccrgBt0i.s 			page 208


 5604 014c 9A42     		cmp	r2, r3
 5605 014e 07D9     		bls	.L478
4963:FreeRTOS/tasks.c ****                 }
 5606              		.loc 1 4963 0
 5607 0150 0A4B     		ldr	r3, .L487+16
 5608 0152 4FF08052 		mov	r2, #268435456
 5609 0156 1A60     		str	r2, [r3]
 5610              	.LVL469:
 5611              		.syntax unified
 5612              	@ 4963 "FreeRTOS/tasks.c" 1
 5613 0158 BFF34F8F 		dsb
 5614              	@ 0 "" 2
 5615              	@ 4963 "FreeRTOS/tasks.c" 1
 5616 015c BFF36F8F 		isb
 5617              	@ 0 "" 2
 5618              		.thumb
 5619              		.syntax unified
 5620              	.L478:
4975:FreeRTOS/tasks.c **** 
 5621              		.loc 1 4975 0
 5622 0160 FFF7FEFF 		bl	vPortExitCritical
 5623              	.LVL470:
4978:FreeRTOS/tasks.c **** 
 5624              		.loc 1 4978 0
 5625 0164 2046     		mov	r0, r4
 5626 0166 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 5627              	.LVL471:
 5628              	.L488:
 5629 016a 00BF     		.align	2
 5630              	.L487:
 5631 016c 00000000 		.word	.LANCHOR13
 5632 0170 00000000 		.word	.LANCHOR4
 5633 0174 00000000 		.word	.LANCHOR15
 5634 0178 00000000 		.word	.LANCHOR10
 5635 017c 04ED00E0 		.word	-536810236
 5636              		.cfi_endproc
 5637              	.LFE52:
 5639              		.section	.text.xTaskGenericNotifyFromISR,"ax",%progbits
 5640              		.align	1
 5641              		.global	xTaskGenericNotifyFromISR
 5642              		.syntax unified
 5643              		.thumb
 5644              		.thumb_func
 5645              		.fpu softvfp
 5647              	xTaskGenericNotifyFromISR:
 5648              	.LFB53:
4991:FreeRTOS/tasks.c ****         TCB_t * pxTCB;
 5649              		.loc 1 4991 0
 5650              		.cfi_startproc
 5651              		@ args = 8, pretend = 0, frame = 0
 5652              		@ frame_needed = 0, uses_anonymous_args = 0
 5653              	.LVL472:
 5654 0000 2DE9F843 		push	{r3, r4, r5, r6, r7, r8, r9, lr}
 5655              	.LCFI55:
 5656              		.cfi_def_cfa_offset 32
 5657              		.cfi_offset 3, -32
 5658              		.cfi_offset 4, -28
ARM GAS  /tmp/ccrgBt0i.s 			page 209


 5659              		.cfi_offset 5, -24
 5660              		.cfi_offset 6, -20
 5661              		.cfi_offset 7, -16
 5662              		.cfi_offset 8, -12
 5663              		.cfi_offset 9, -8
 5664              		.cfi_offset 14, -4
 5665 0004 DDF82090 		ldr	r9, [sp, #32]
 5666 0008 099E     		ldr	r6, [sp, #36]
 5667              	.LVL473:
4997:FreeRTOS/tasks.c ****         configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
 5668              		.loc 1 4997 0
 5669 000a 40B9     		cbnz	r0, .L490
 5670              	.LBB294:
 5671              	.LBB295:
 200:FreeRTOS/ARM_CM3/portmacro.h ****         (
 5672              		.loc 2 200 0
 5673              		.syntax unified
 5674              	@ 200 "FreeRTOS/ARM_CM3/portmacro.h" 1
 5675 000c 4FF05003 			mov r3, #80												
 5676 0010 83F31188 		msr basepri, r3											
 5677 0014 BFF36F8F 		isb														
 5678 0018 BFF34F8F 		dsb														
 5679              	
 5680              	@ 0 "" 2
 5681              	.LVL474:
 5682              		.thumb
 5683              		.syntax unified
 5684              	.L491:
 5685 001c FEE7     		b	.L491
 5686              	.LVL475:
 5687              	.L490:
 5688 001e 0446     		mov	r4, r0
 5689              	.LBE295:
 5690              	.LBE294:
4998:FreeRTOS/tasks.c **** 
 5691              		.loc 1 4998 0
 5692 0020 41B1     		cbz	r1, .L492
 5693              	.LBB296:
 5694              	.LBB297:
 200:FreeRTOS/ARM_CM3/portmacro.h ****         (
 5695              		.loc 2 200 0
 5696              		.syntax unified
 5697              	@ 200 "FreeRTOS/ARM_CM3/portmacro.h" 1
 5698 0022 4FF05003 			mov r3, #80												
 5699 0026 83F31188 		msr basepri, r3											
 5700 002a BFF36F8F 		isb														
 5701 002e BFF34F8F 		dsb														
 5702              	
 5703              	@ 0 "" 2
 5704              	.LVL476:
 5705              		.thumb
 5706              		.syntax unified
 5707              	.L493:
 5708 0032 FEE7     		b	.L493
 5709              	.LVL477:
 5710              	.L492:
 5711 0034 9846     		mov	r8, r3
ARM GAS  /tmp/ccrgBt0i.s 			page 210


 5712 0036 1746     		mov	r7, r2
 5713 0038 0D46     		mov	r5, r1
 5714              	.LBE297:
 5715              	.LBE296:
5016:FreeRTOS/tasks.c **** 
 5716              		.loc 1 5016 0
 5717 003a FFF7FEFF 		bl	vPortValidateInterruptPriority
 5718              	.LVL478:
 5719              	.LBB298:
 5720              	.LBB299:
 216:FreeRTOS/ARM_CM3/portmacro.h ****         (
 5721              		.loc 2 216 0
 5722              		.syntax unified
 5723              	@ 216 "FreeRTOS/ARM_CM3/portmacro.h" 1
 5724 003e EFF31181 			mrs r1, basepri											
 5725 0042 4FF05003 		mov r3, #80												
 5726 0046 83F31188 		msr basepri, r3											
 5727 004a BFF36F8F 		isb														
 5728 004e BFF34F8F 		dsb														
 5729              	
 5730              	@ 0 "" 2
 5731              		.thumb
 5732              		.syntax unified
 5733              	.LBE299:
 5734              	.LBE298:
5022:FreeRTOS/tasks.c ****             {
 5735              		.loc 1 5022 0
 5736 0052 B9F1000F 		cmp	r9, #0
 5737 0056 06D0     		beq	.L494
5024:FreeRTOS/tasks.c ****             }
 5738              		.loc 1 5024 0
 5739 0058 05F11203 		add	r3, r5, #18
 5740 005c 04EB8303 		add	r3, r4, r3, lsl #2
 5741 0060 5B68     		ldr	r3, [r3, #4]
 5742 0062 C9F80030 		str	r3, [r9]
 5743              	.L494:
5027:FreeRTOS/tasks.c ****             pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
 5744              		.loc 1 5027 0
 5745 0066 6319     		adds	r3, r4, r5
 5746 0068 93F85020 		ldrb	r2, [r3, #80]	@ zero_extendqisi2
 5747 006c D2B2     		uxtb	r2, r2
 5748              	.LVL479:
5028:FreeRTOS/tasks.c **** 
 5749              		.loc 1 5028 0
 5750 006e 0220     		movs	r0, #2
 5751 0070 83F85000 		strb	r0, [r3, #80]
5030:FreeRTOS/tasks.c ****             {
 5752              		.loc 1 5030 0
 5753 0074 B8F1040F 		cmp	r8, #4
 5754 0078 32D8     		bhi	.L495
 5755 007a DFE808F0 		tbb	[pc, r8]
 5756              	.L497:
 5757 007e 3D       		.byte	(.L510-.L497)/2
 5758 007f 03       		.byte	(.L498-.L497)/2
 5759 0080 18       		.byte	(.L499-.L497)/2
 5760 0081 21       		.byte	(.L500-.L497)/2
 5761 0082 28       		.byte	(.L501-.L497)/2
ARM GAS  /tmp/ccrgBt0i.s 			page 211


 5762 0083 00       		.p2align 1
 5763              	.L498:
5033:FreeRTOS/tasks.c ****                     break;
 5764              		.loc 1 5033 0
 5765 0084 05F11203 		add	r3, r5, #18
 5766 0088 04EB8303 		add	r3, r4, r3, lsl #2
 5767 008c 5868     		ldr	r0, [r3, #4]
 5768 008e 0743     		orrs	r7, r7, r0
 5769              	.LVL480:
 5770 0090 5F60     		str	r7, [r3, #4]
4994:FreeRTOS/tasks.c ****         UBaseType_t uxSavedInterruptStatus;
 5771              		.loc 1 4994 0
 5772 0092 0120     		movs	r0, #1
 5773              	.L496:
 5774              	.LVL481:
5077:FreeRTOS/tasks.c ****             {
 5775              		.loc 1 5077 0
 5776 0094 012A     		cmp	r2, #1
 5777 0096 74D1     		bne	.L503
5080:FreeRTOS/tasks.c **** 
 5778              		.loc 1 5080 0
 5779 0098 A36A     		ldr	r3, [r4, #40]
 5780 009a 9BB3     		cbz	r3, .L504
 5781              	.LBB300:
 5782              	.LBB301:
 200:FreeRTOS/ARM_CM3/portmacro.h ****         (
 5783              		.loc 2 200 0
 5784              		.syntax unified
 5785              	@ 200 "FreeRTOS/ARM_CM3/portmacro.h" 1
 5786 009c 4FF05003 			mov r3, #80												
 5787 00a0 83F31188 		msr basepri, r3											
 5788 00a4 BFF36F8F 		isb														
 5789 00a8 BFF34F8F 		dsb														
 5790              	
 5791              	@ 0 "" 2
 5792              	.LVL482:
 5793              		.thumb
 5794              		.syntax unified
 5795              	.L505:
 5796 00ac FEE7     		b	.L505
 5797              	.LVL483:
 5798              	.L499:
 5799              	.LBE301:
 5800              	.LBE300:
5037:FreeRTOS/tasks.c ****                     break;
 5801              		.loc 1 5037 0
 5802 00ae 05F11203 		add	r3, r5, #18
 5803 00b2 04EB8303 		add	r3, r4, r3, lsl #2
 5804 00b6 5868     		ldr	r0, [r3, #4]
 5805 00b8 0130     		adds	r0, r0, #1
 5806 00ba 5860     		str	r0, [r3, #4]
4994:FreeRTOS/tasks.c ****         UBaseType_t uxSavedInterruptStatus;
 5807              		.loc 1 4994 0
 5808 00bc 0120     		movs	r0, #1
5038:FreeRTOS/tasks.c **** 
 5809              		.loc 1 5038 0
 5810 00be E9E7     		b	.L496
ARM GAS  /tmp/ccrgBt0i.s 			page 212


 5811              	.L500:
5041:FreeRTOS/tasks.c ****                     break;
 5812              		.loc 1 5041 0
 5813 00c0 05F11203 		add	r3, r5, #18
 5814 00c4 04EB8303 		add	r3, r4, r3, lsl #2
 5815 00c8 5F60     		str	r7, [r3, #4]
4994:FreeRTOS/tasks.c ****         UBaseType_t uxSavedInterruptStatus;
 5816              		.loc 1 4994 0
 5817 00ca 0120     		movs	r0, #1
5042:FreeRTOS/tasks.c **** 
 5818              		.loc 1 5042 0
 5819 00cc E2E7     		b	.L496
 5820              	.L501:
5046:FreeRTOS/tasks.c ****                     {
 5821              		.loc 1 5046 0
 5822 00ce 022A     		cmp	r2, #2
 5823 00d0 14D0     		beq	.L511
5048:FreeRTOS/tasks.c ****                     }
 5824              		.loc 1 5048 0
 5825 00d2 05F11203 		add	r3, r5, #18
 5826 00d6 04EB8303 		add	r3, r4, r3, lsl #2
 5827 00da 5F60     		str	r7, [r3, #4]
4994:FreeRTOS/tasks.c ****         UBaseType_t uxSavedInterruptStatus;
 5828              		.loc 1 4994 0
 5829 00dc 0120     		movs	r0, #1
 5830 00de D9E7     		b	.L496
 5831              	.L495:
5069:FreeRTOS/tasks.c ****                     break;
 5832              		.loc 1 5069 0
 5833 00e0 314B     		ldr	r3, .L514
 5834 00e2 1B68     		ldr	r3, [r3]
 5835 00e4 63B1     		cbz	r3, .L512
 5836              	.LBB302:
 5837              	.LBB303:
 200:FreeRTOS/ARM_CM3/portmacro.h ****         (
 5838              		.loc 2 200 0
 5839              		.syntax unified
 5840              	@ 200 "FreeRTOS/ARM_CM3/portmacro.h" 1
 5841 00e6 4FF05003 			mov r3, #80												
 5842 00ea 83F31188 		msr basepri, r3											
 5843 00ee BFF36F8F 		isb														
 5844 00f2 BFF34F8F 		dsb														
 5845              	
 5846              	@ 0 "" 2
 5847              	.LVL484:
 5848              		.thumb
 5849              		.syntax unified
 5850              	.L502:
 5851 00f6 FEE7     		b	.L502
 5852              	.L510:
 5853              	.LBE303:
 5854              	.LBE302:
4994:FreeRTOS/tasks.c ****         UBaseType_t uxSavedInterruptStatus;
 5855              		.loc 1 4994 0
 5856 00f8 0120     		movs	r0, #1
 5857 00fa CBE7     		b	.L496
 5858              	.L511:
ARM GAS  /tmp/ccrgBt0i.s 			page 213


5053:FreeRTOS/tasks.c ****                     }
 5859              		.loc 1 5053 0
 5860 00fc 0020     		movs	r0, #0
 5861 00fe C9E7     		b	.L496
 5862              	.L512:
4994:FreeRTOS/tasks.c ****         UBaseType_t uxSavedInterruptStatus;
 5863              		.loc 1 4994 0
 5864 0100 0120     		movs	r0, #1
 5865 0102 C7E7     		b	.L496
 5866              	.LVL485:
 5867              	.L504:
5082:FreeRTOS/tasks.c ****                 {
 5868              		.loc 1 5082 0
 5869 0104 294B     		ldr	r3, .L514+4
 5870 0106 1B68     		ldr	r3, [r3]
 5871 0108 002B     		cmp	r3, #0
 5872 010a 3ED1     		bne	.L506
 5873              	.LBB304:
5084:FreeRTOS/tasks.c ****                     prvAddTaskToReadyList( pxTCB );
 5874              		.loc 1 5084 0
 5875 010c 6369     		ldr	r3, [r4, #20]
 5876              	.LVL486:
 5877 010e A268     		ldr	r2, [r4, #8]
 5878              	.LVL487:
 5879 0110 E568     		ldr	r5, [r4, #12]
 5880              	.LVL488:
 5881 0112 9560     		str	r5, [r2, #8]
 5882 0114 E268     		ldr	r2, [r4, #12]
 5883 0116 A568     		ldr	r5, [r4, #8]
 5884 0118 5560     		str	r5, [r2, #4]
 5885 011a 5A68     		ldr	r2, [r3, #4]
 5886 011c 251D     		adds	r5, r4, #4
 5887 011e AA42     		cmp	r2, r5
 5888 0120 01D1     		bne	.L507
5084:FreeRTOS/tasks.c ****                     prvAddTaskToReadyList( pxTCB );
 5889              		.loc 1 5084 0 is_stmt 0 discriminator 1
 5890 0122 E268     		ldr	r2, [r4, #12]
 5891 0124 5A60     		str	r2, [r3, #4]
 5892              	.L507:
5084:FreeRTOS/tasks.c ****                     prvAddTaskToReadyList( pxTCB );
 5893              		.loc 1 5084 0 discriminator 3
 5894 0126 0022     		movs	r2, #0
 5895 0128 6261     		str	r2, [r4, #20]
 5896 012a 1A68     		ldr	r2, [r3]
 5897 012c 013A     		subs	r2, r2, #1
 5898 012e 1A60     		str	r2, [r3]
 5899              	.LBE304:
5085:FreeRTOS/tasks.c ****                 }
 5900              		.loc 1 5085 0 is_stmt 1 discriminator 3
 5901 0130 E26A     		ldr	r2, [r4, #44]
 5902 0132 0123     		movs	r3, #1
 5903              	.LVL489:
 5904 0134 9340     		lsls	r3, r3, r2
 5905 0136 1E4F     		ldr	r7, .L514+8
 5906 0138 D7F800C0 		ldr	ip, [r7]
 5907 013c 43EA0C03 		orr	r3, r3, ip
 5908 0140 3B60     		str	r3, [r7]
ARM GAS  /tmp/ccrgBt0i.s 			page 214


 5909              	.LBB305:
 5910 0142 1C4F     		ldr	r7, .L514+12
 5911 0144 4FF0140C 		mov	ip, #20
 5912 0148 0CFB0272 		mla	r2, ip, r2, r7
 5913 014c 5268     		ldr	r2, [r2, #4]
 5914              	.LVL490:
 5915 014e A260     		str	r2, [r4, #8]
 5916 0150 9368     		ldr	r3, [r2, #8]
 5917 0152 E360     		str	r3, [r4, #12]
 5918 0154 9368     		ldr	r3, [r2, #8]
 5919 0156 5D60     		str	r5, [r3, #4]
 5920 0158 9560     		str	r5, [r2, #8]
 5921 015a E26A     		ldr	r2, [r4, #44]
 5922              	.LVL491:
 5923 015c 0CFB02F3 		mul	r3, ip, r2
 5924 0160 FA18     		adds	r2, r7, r3
 5925 0162 6261     		str	r2, [r4, #20]
 5926 0164 FA58     		ldr	r2, [r7, r3]
 5927 0166 0132     		adds	r2, r2, #1
 5928 0168 FA50     		str	r2, [r7, r3]
 5929              	.L508:
 5930              	.LBE305:
5094:FreeRTOS/tasks.c ****                 {
 5931              		.loc 1 5094 0
 5932 016a E26A     		ldr	r2, [r4, #44]
 5933 016c 124B     		ldr	r3, .L514+16
 5934 016e 1B68     		ldr	r3, [r3]
 5935 0170 DB6A     		ldr	r3, [r3, #44]
 5936 0172 9A42     		cmp	r2, r3
 5937 0174 05D9     		bls	.L503
5098:FreeRTOS/tasks.c ****                     {
 5938              		.loc 1 5098 0
 5939 0176 0EB1     		cbz	r6, .L509
5100:FreeRTOS/tasks.c ****                     }
 5940              		.loc 1 5100 0
 5941 0178 0123     		movs	r3, #1
 5942 017a 3360     		str	r3, [r6]
 5943              	.L509:
5106:FreeRTOS/tasks.c ****                 }
 5944              		.loc 1 5106 0
 5945 017c 0F4B     		ldr	r3, .L514+20
 5946 017e 0122     		movs	r2, #1
 5947 0180 1A60     		str	r2, [r3]
 5948              	.L503:
 5949              	.LVL492:
 5950              	.LBB306:
 5951              	.LBB307:
 5952              		.loc 2 234 0
 5953              		.syntax unified
 5954              	@ 234 "FreeRTOS/ARM_CM3/portmacro.h" 1
 5955 0182 81F31188 			msr basepri, r1	
 5956              	@ 0 "" 2
 5957              	.LVL493:
 5958              		.thumb
 5959              		.syntax unified
 5960              	.LBE307:
 5961              	.LBE306:
ARM GAS  /tmp/ccrgBt0i.s 			page 215


5117:FreeRTOS/tasks.c **** 
 5962              		.loc 1 5117 0
 5963 0186 BDE8F883 		pop	{r3, r4, r5, r6, r7, r8, r9, pc}
 5964              	.LVL494:
 5965              	.L506:
 5966              	.LBB308:
5091:FreeRTOS/tasks.c ****                 }
 5967              		.loc 1 5091 0
 5968 018a 0D4B     		ldr	r3, .L514+24
 5969 018c 5A68     		ldr	r2, [r3, #4]
 5970              	.LVL495:
 5971 018e E261     		str	r2, [r4, #28]
 5972 0190 9568     		ldr	r5, [r2, #8]
 5973              	.LVL496:
 5974 0192 2562     		str	r5, [r4, #32]
 5975 0194 9768     		ldr	r7, [r2, #8]
 5976 0196 04F11805 		add	r5, r4, #24
 5977 019a 7D60     		str	r5, [r7, #4]
 5978 019c 9560     		str	r5, [r2, #8]
 5979 019e A362     		str	r3, [r4, #40]
 5980 01a0 1A68     		ldr	r2, [r3]
 5981              	.LVL497:
 5982 01a2 0132     		adds	r2, r2, #1
 5983 01a4 1A60     		str	r2, [r3]
 5984 01a6 E0E7     		b	.L508
 5985              	.L515:
 5986              		.align	2
 5987              	.L514:
 5988 01a8 00000000 		.word	.LANCHOR15
 5989 01ac 00000000 		.word	.LANCHOR16
 5990 01b0 00000000 		.word	.LANCHOR13
 5991 01b4 00000000 		.word	.LANCHOR4
 5992 01b8 00000000 		.word	.LANCHOR10
 5993 01bc 00000000 		.word	.LANCHOR17
 5994 01c0 00000000 		.word	.LANCHOR1
 5995              	.LBE308:
 5996              		.cfi_endproc
 5997              	.LFE53:
 5999              		.section	.text.vTaskGenericNotifyGiveFromISR,"ax",%progbits
 6000              		.align	1
 6001              		.global	vTaskGenericNotifyGiveFromISR
 6002              		.syntax unified
 6003              		.thumb
 6004              		.thumb_func
 6005              		.fpu softvfp
 6007              	vTaskGenericNotifyGiveFromISR:
 6008              	.LFB54:
5127:FreeRTOS/tasks.c ****         TCB_t * pxTCB;
 6009              		.loc 1 5127 0
 6010              		.cfi_startproc
 6011              		@ args = 0, pretend = 0, frame = 0
 6012              		@ frame_needed = 0, uses_anonymous_args = 0
 6013              	.LVL498:
 6014 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 6015              	.LCFI56:
 6016              		.cfi_def_cfa_offset 24
 6017              		.cfi_offset 3, -24
ARM GAS  /tmp/ccrgBt0i.s 			page 216


 6018              		.cfi_offset 4, -20
 6019              		.cfi_offset 5, -16
 6020              		.cfi_offset 6, -12
 6021              		.cfi_offset 7, -8
 6022              		.cfi_offset 14, -4
5132:FreeRTOS/tasks.c ****         configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
 6023              		.loc 1 5132 0
 6024 0002 40B9     		cbnz	r0, .L517
 6025              	.LBB309:
 6026              	.LBB310:
 200:FreeRTOS/ARM_CM3/portmacro.h ****         (
 6027              		.loc 2 200 0
 6028              		.syntax unified
 6029              	@ 200 "FreeRTOS/ARM_CM3/portmacro.h" 1
 6030 0004 4FF05003 			mov r3, #80												
 6031 0008 83F31188 		msr basepri, r3											
 6032 000c BFF36F8F 		isb														
 6033 0010 BFF34F8F 		dsb														
 6034              	
 6035              	@ 0 "" 2
 6036              	.LVL499:
 6037              		.thumb
 6038              		.syntax unified
 6039              	.L518:
 6040 0014 FEE7     		b	.L518
 6041              	.L517:
 6042 0016 0446     		mov	r4, r0
 6043              	.LBE310:
 6044              	.LBE309:
5133:FreeRTOS/tasks.c **** 
 6045              		.loc 1 5133 0
 6046 0018 41B1     		cbz	r1, .L519
 6047              	.LBB311:
 6048              	.LBB312:
 200:FreeRTOS/ARM_CM3/portmacro.h ****         (
 6049              		.loc 2 200 0
 6050              		.syntax unified
 6051              	@ 200 "FreeRTOS/ARM_CM3/portmacro.h" 1
 6052 001a 4FF05003 			mov r3, #80												
 6053 001e 83F31188 		msr basepri, r3											
 6054 0022 BFF36F8F 		isb														
 6055 0026 BFF34F8F 		dsb														
 6056              	
 6057              	@ 0 "" 2
 6058              	.LVL500:
 6059              		.thumb
 6060              		.syntax unified
 6061              	.L520:
 6062 002a FEE7     		b	.L520
 6063              	.L519:
 6064 002c 1646     		mov	r6, r2
 6065 002e 0D46     		mov	r5, r1
 6066              	.LBE312:
 6067              	.LBE311:
5151:FreeRTOS/tasks.c **** 
 6068              		.loc 1 5151 0
 6069 0030 FFF7FEFF 		bl	vPortValidateInterruptPriority
ARM GAS  /tmp/ccrgBt0i.s 			page 217


 6070              	.LVL501:
 6071              	.LBB313:
 6072              	.LBB314:
 216:FreeRTOS/ARM_CM3/portmacro.h ****         (
 6073              		.loc 2 216 0
 6074              		.syntax unified
 6075              	@ 216 "FreeRTOS/ARM_CM3/portmacro.h" 1
 6076 0034 EFF31181 			mrs r1, basepri											
 6077 0038 4FF05003 		mov r3, #80												
 6078 003c 83F31188 		msr basepri, r3											
 6079 0040 BFF36F8F 		isb														
 6080 0044 BFF34F8F 		dsb														
 6081              	
 6082              	@ 0 "" 2
 6083              		.thumb
 6084              		.syntax unified
 6085              	.LBE314:
 6086              	.LBE313:
5157:FreeRTOS/tasks.c ****             pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
 6087              		.loc 1 5157 0
 6088 0048 6319     		adds	r3, r4, r5
 6089 004a 93F85020 		ldrb	r2, [r3, #80]	@ zero_extendqisi2
 6090 004e D2B2     		uxtb	r2, r2
 6091              	.LVL502:
5158:FreeRTOS/tasks.c **** 
 6092              		.loc 1 5158 0
 6093 0050 0220     		movs	r0, #2
 6094 0052 83F85000 		strb	r0, [r3, #80]
5162:FreeRTOS/tasks.c **** 
 6095              		.loc 1 5162 0
 6096 0056 05F11203 		add	r3, r5, #18
 6097 005a 04EB8303 		add	r3, r4, r3, lsl #2
 6098 005e 5868     		ldr	r0, [r3, #4]
 6099 0060 0130     		adds	r0, r0, #1
 6100 0062 5860     		str	r0, [r3, #4]
5168:FreeRTOS/tasks.c ****             {
 6101              		.loc 1 5168 0
 6102 0064 012A     		cmp	r2, #1
 6103 0066 46D1     		bne	.L521
5171:FreeRTOS/tasks.c **** 
 6104              		.loc 1 5171 0
 6105 0068 A36A     		ldr	r3, [r4, #40]
 6106 006a 43B1     		cbz	r3, .L522
 6107              	.LBB315:
 6108              	.LBB316:
 200:FreeRTOS/ARM_CM3/portmacro.h ****         (
 6109              		.loc 2 200 0
 6110              		.syntax unified
 6111              	@ 200 "FreeRTOS/ARM_CM3/portmacro.h" 1
 6112 006c 4FF05003 			mov r3, #80												
 6113 0070 83F31188 		msr basepri, r3											
 6114 0074 BFF36F8F 		isb														
 6115 0078 BFF34F8F 		dsb														
 6116              	
 6117              	@ 0 "" 2
 6118              	.LVL503:
 6119              		.thumb
ARM GAS  /tmp/ccrgBt0i.s 			page 218


 6120              		.syntax unified
 6121              	.L523:
 6122 007c FEE7     		b	.L523
 6123              	.L522:
 6124              	.LBE316:
 6125              	.LBE315:
5173:FreeRTOS/tasks.c ****                 {
 6126              		.loc 1 5173 0
 6127 007e 274B     		ldr	r3, .L529
 6128 0080 1B68     		ldr	r3, [r3]
 6129 0082 002B     		cmp	r3, #0
 6130 0084 3AD1     		bne	.L524
 6131              	.LBB317:
5175:FreeRTOS/tasks.c ****                     prvAddTaskToReadyList( pxTCB );
 6132              		.loc 1 5175 0
 6133 0086 6369     		ldr	r3, [r4, #20]
 6134              	.LVL504:
 6135 0088 A268     		ldr	r2, [r4, #8]
 6136              	.LVL505:
 6137 008a E068     		ldr	r0, [r4, #12]
 6138 008c 9060     		str	r0, [r2, #8]
 6139 008e E268     		ldr	r2, [r4, #12]
 6140 0090 A068     		ldr	r0, [r4, #8]
 6141 0092 5060     		str	r0, [r2, #4]
 6142 0094 5A68     		ldr	r2, [r3, #4]
 6143 0096 201D     		adds	r0, r4, #4
 6144 0098 8242     		cmp	r2, r0
 6145 009a 01D1     		bne	.L525
5175:FreeRTOS/tasks.c ****                     prvAddTaskToReadyList( pxTCB );
 6146              		.loc 1 5175 0 is_stmt 0 discriminator 1
 6147 009c E268     		ldr	r2, [r4, #12]
 6148 009e 5A60     		str	r2, [r3, #4]
 6149              	.L525:
5175:FreeRTOS/tasks.c ****                     prvAddTaskToReadyList( pxTCB );
 6150              		.loc 1 5175 0 discriminator 3
 6151 00a0 0022     		movs	r2, #0
 6152 00a2 6261     		str	r2, [r4, #20]
 6153 00a4 1A68     		ldr	r2, [r3]
 6154 00a6 013A     		subs	r2, r2, #1
 6155 00a8 1A60     		str	r2, [r3]
 6156              	.LBE317:
5176:FreeRTOS/tasks.c ****                 }
 6157              		.loc 1 5176 0 is_stmt 1 discriminator 3
 6158 00aa E26A     		ldr	r2, [r4, #44]
 6159 00ac 0123     		movs	r3, #1
 6160              	.LVL506:
 6161 00ae 9340     		lsls	r3, r3, r2
 6162 00b0 1B4D     		ldr	r5, .L529+4
 6163              	.LVL507:
 6164 00b2 2F68     		ldr	r7, [r5]
 6165 00b4 3B43     		orrs	r3, r3, r7
 6166 00b6 2B60     		str	r3, [r5]
 6167              	.LBB318:
 6168 00b8 1A4D     		ldr	r5, .L529+8
 6169 00ba 1423     		movs	r3, #20
 6170 00bc 03FB0252 		mla	r2, r3, r2, r5
 6171 00c0 5268     		ldr	r2, [r2, #4]
ARM GAS  /tmp/ccrgBt0i.s 			page 219


 6172              	.LVL508:
 6173 00c2 A260     		str	r2, [r4, #8]
 6174 00c4 9768     		ldr	r7, [r2, #8]
 6175 00c6 E760     		str	r7, [r4, #12]
 6176 00c8 9768     		ldr	r7, [r2, #8]
 6177 00ca 7860     		str	r0, [r7, #4]
 6178 00cc 9060     		str	r0, [r2, #8]
 6179 00ce E26A     		ldr	r2, [r4, #44]
 6180              	.LVL509:
 6181 00d0 03FB02F3 		mul	r3, r3, r2
 6182 00d4 EA18     		adds	r2, r5, r3
 6183 00d6 6261     		str	r2, [r4, #20]
 6184 00d8 EA58     		ldr	r2, [r5, r3]
 6185 00da 0132     		adds	r2, r2, #1
 6186 00dc EA50     		str	r2, [r5, r3]
 6187              	.L526:
 6188              	.LBE318:
5185:FreeRTOS/tasks.c ****                 {
 6189              		.loc 1 5185 0
 6190 00de E26A     		ldr	r2, [r4, #44]
 6191 00e0 114B     		ldr	r3, .L529+12
 6192 00e2 1B68     		ldr	r3, [r3]
 6193 00e4 DB6A     		ldr	r3, [r3, #44]
 6194 00e6 9A42     		cmp	r2, r3
 6195 00e8 05D9     		bls	.L521
5189:FreeRTOS/tasks.c ****                     {
 6196              		.loc 1 5189 0
 6197 00ea 0EB1     		cbz	r6, .L527
5191:FreeRTOS/tasks.c ****                     }
 6198              		.loc 1 5191 0
 6199 00ec 0123     		movs	r3, #1
 6200 00ee 3360     		str	r3, [r6]
 6201              	.L527:
5197:FreeRTOS/tasks.c ****                 }
 6202              		.loc 1 5197 0
 6203 00f0 0E4B     		ldr	r3, .L529+16
 6204 00f2 0122     		movs	r2, #1
 6205 00f4 1A60     		str	r2, [r3]
 6206              	.L521:
 6207              	.LVL510:
 6208              	.LBB319:
 6209              	.LBB320:
 6210              		.loc 2 234 0
 6211              		.syntax unified
 6212              	@ 234 "FreeRTOS/ARM_CM3/portmacro.h" 1
 6213 00f6 81F31188 			msr basepri, r1	
 6214              	@ 0 "" 2
 6215              	.LVL511:
 6216              		.thumb
 6217              		.syntax unified
 6218              	.LBE320:
 6219              	.LBE319:
5206:FreeRTOS/tasks.c **** 
 6220              		.loc 1 5206 0
 6221 00fa F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 6222              	.LVL512:
 6223              	.L524:
ARM GAS  /tmp/ccrgBt0i.s 			page 220


 6224              	.LBB321:
5182:FreeRTOS/tasks.c ****                 }
 6225              		.loc 1 5182 0
 6226 00fc 0C4B     		ldr	r3, .L529+20
 6227 00fe 5A68     		ldr	r2, [r3, #4]
 6228              	.LVL513:
 6229 0100 E261     		str	r2, [r4, #28]
 6230 0102 9068     		ldr	r0, [r2, #8]
 6231 0104 2062     		str	r0, [r4, #32]
 6232 0106 9568     		ldr	r5, [r2, #8]
 6233              	.LVL514:
 6234 0108 04F11800 		add	r0, r4, #24
 6235 010c 6860     		str	r0, [r5, #4]
 6236 010e 9060     		str	r0, [r2, #8]
 6237 0110 A362     		str	r3, [r4, #40]
 6238 0112 1A68     		ldr	r2, [r3]
 6239              	.LVL515:
 6240 0114 0132     		adds	r2, r2, #1
 6241 0116 1A60     		str	r2, [r3]
 6242 0118 E1E7     		b	.L526
 6243              	.L530:
 6244 011a 00BF     		.align	2
 6245              	.L529:
 6246 011c 00000000 		.word	.LANCHOR16
 6247 0120 00000000 		.word	.LANCHOR13
 6248 0124 00000000 		.word	.LANCHOR4
 6249 0128 00000000 		.word	.LANCHOR10
 6250 012c 00000000 		.word	.LANCHOR17
 6251 0130 00000000 		.word	.LANCHOR1
 6252              	.LBE321:
 6253              		.cfi_endproc
 6254              	.LFE54:
 6256              		.section	.text.xTaskGenericNotifyStateClear,"ax",%progbits
 6257              		.align	1
 6258              		.global	xTaskGenericNotifyStateClear
 6259              		.syntax unified
 6260              		.thumb
 6261              		.thumb_func
 6262              		.fpu softvfp
 6264              	xTaskGenericNotifyStateClear:
 6265              	.LFB55:
5215:FreeRTOS/tasks.c ****         TCB_t * pxTCB;
 6266              		.loc 1 5215 0
 6267              		.cfi_startproc
 6268              		@ args = 0, pretend = 0, frame = 0
 6269              		@ frame_needed = 0, uses_anonymous_args = 0
 6270              	.LVL516:
 6271 0000 38B5     		push	{r3, r4, r5, lr}
 6272              	.LCFI57:
 6273              		.cfi_def_cfa_offset 16
 6274              		.cfi_offset 3, -16
 6275              		.cfi_offset 4, -12
 6276              		.cfi_offset 5, -8
 6277              		.cfi_offset 14, -4
5219:FreeRTOS/tasks.c **** 
 6278              		.loc 1 5219 0
 6279 0002 41B1     		cbz	r1, .L532
ARM GAS  /tmp/ccrgBt0i.s 			page 221


 6280              	.LBB322:
 6281              	.LBB323:
 200:FreeRTOS/ARM_CM3/portmacro.h ****         (
 6282              		.loc 2 200 0
 6283              		.syntax unified
 6284              	@ 200 "FreeRTOS/ARM_CM3/portmacro.h" 1
 6285 0004 4FF05003 			mov r3, #80												
 6286 0008 83F31188 		msr basepri, r3											
 6287 000c BFF36F8F 		isb														
 6288 0010 BFF34F8F 		dsb														
 6289              	
 6290              	@ 0 "" 2
 6291              	.LVL517:
 6292              		.thumb
 6293              		.syntax unified
 6294              	.L533:
 6295 0014 FEE7     		b	.L533
 6296              	.L532:
 6297 0016 0446     		mov	r4, r0
 6298 0018 0D46     		mov	r5, r1
 6299              	.LBE323:
 6300              	.LBE322:
5223:FreeRTOS/tasks.c **** 
 6301              		.loc 1 5223 0
 6302 001a 60B1     		cbz	r0, .L538
 6303              	.LVL518:
 6304              	.L534:
5225:FreeRTOS/tasks.c ****         {
 6305              		.loc 1 5225 0 discriminator 4
 6306 001c FFF7FEFF 		bl	vPortEnterCritical
 6307              	.LVL519:
5227:FreeRTOS/tasks.c ****             {
 6308              		.loc 1 5227 0 discriminator 4
 6309 0020 6319     		adds	r3, r4, r5
 6310 0022 93F85030 		ldrb	r3, [r3, #80]	@ zero_extendqisi2
 6311 0026 DBB2     		uxtb	r3, r3
 6312 0028 022B     		cmp	r3, #2
 6313 002a 07D0     		beq	.L539
5234:FreeRTOS/tasks.c ****             }
 6314              		.loc 1 5234 0
 6315 002c 0024     		movs	r4, #0
 6316              	.LVL520:
 6317              	.L535:
5237:FreeRTOS/tasks.c **** 
 6318              		.loc 1 5237 0
 6319 002e FFF7FEFF 		bl	vPortExitCritical
 6320              	.LVL521:
5240:FreeRTOS/tasks.c **** 
 6321              		.loc 1 5240 0
 6322 0032 2046     		mov	r0, r4
 6323 0034 38BD     		pop	{r3, r4, r5, pc}
 6324              	.LVL522:
 6325              	.L538:
5223:FreeRTOS/tasks.c **** 
 6326              		.loc 1 5223 0 discriminator 1
 6327 0036 044B     		ldr	r3, .L540
 6328 0038 1C68     		ldr	r4, [r3]
ARM GAS  /tmp/ccrgBt0i.s 			page 222


 6329              	.LVL523:
 6330 003a EFE7     		b	.L534
 6331              	.LVL524:
 6332              	.L539:
5229:FreeRTOS/tasks.c ****                 xReturn = pdPASS;
 6333              		.loc 1 5229 0
 6334 003c 2C44     		add	r4, r4, r5
 6335              	.LVL525:
 6336 003e 0023     		movs	r3, #0
 6337 0040 84F85030 		strb	r3, [r4, #80]
 6338              	.LVL526:
5230:FreeRTOS/tasks.c ****             }
 6339              		.loc 1 5230 0
 6340 0044 0124     		movs	r4, #1
 6341 0046 F2E7     		b	.L535
 6342              	.L541:
 6343              		.align	2
 6344              	.L540:
 6345 0048 00000000 		.word	.LANCHOR10
 6346              		.cfi_endproc
 6347              	.LFE55:
 6349              		.section	.text.ulTaskGenericNotifyValueClear,"ax",%progbits
 6350              		.align	1
 6351              		.global	ulTaskGenericNotifyValueClear
 6352              		.syntax unified
 6353              		.thumb
 6354              		.thumb_func
 6355              		.fpu softvfp
 6357              	ulTaskGenericNotifyValueClear:
 6358              	.LFB56:
5250:FreeRTOS/tasks.c ****         TCB_t * pxTCB;
 6359              		.loc 1 5250 0
 6360              		.cfi_startproc
 6361              		@ args = 0, pretend = 0, frame = 0
 6362              		@ frame_needed = 0, uses_anonymous_args = 0
 6363              	.LVL527:
 6364 0000 70B5     		push	{r4, r5, r6, lr}
 6365              	.LCFI58:
 6366              		.cfi_def_cfa_offset 16
 6367              		.cfi_offset 4, -16
 6368              		.cfi_offset 5, -12
 6369              		.cfi_offset 6, -8
 6370              		.cfi_offset 14, -4
 6371 0002 0D46     		mov	r5, r1
 6372 0004 1646     		mov	r6, r2
5256:FreeRTOS/tasks.c **** 
 6373              		.loc 1 5256 0
 6374 0006 0446     		mov	r4, r0
 6375 0008 70B1     		cbz	r0, .L545
 6376              	.LVL528:
 6377              	.L543:
5258:FreeRTOS/tasks.c ****         {
 6378              		.loc 1 5258 0 discriminator 4
 6379 000a FFF7FEFF 		bl	vPortEnterCritical
 6380              	.LVL529:
5262:FreeRTOS/tasks.c ****             pxTCB->ulNotifiedValue[ uxIndexToClear ] &= ~ulBitsToClear;
 6381              		.loc 1 5262 0 discriminator 4
ARM GAS  /tmp/ccrgBt0i.s 			page 223


 6382 000e 05F11200 		add	r0, r5, #18
 6383 0012 04EB8000 		add	r0, r4, r0, lsl #2
 6384 0016 4468     		ldr	r4, [r0, #4]
 6385              	.LVL530:
5263:FreeRTOS/tasks.c ****         }
 6386              		.loc 1 5263 0 discriminator 4
 6387 0018 4268     		ldr	r2, [r0, #4]
 6388 001a 22EA0602 		bic	r2, r2, r6
 6389 001e 4260     		str	r2, [r0, #4]
5265:FreeRTOS/tasks.c **** 
 6390              		.loc 1 5265 0 discriminator 4
 6391 0020 FFF7FEFF 		bl	vPortExitCritical
 6392              	.LVL531:
5268:FreeRTOS/tasks.c **** 
 6393              		.loc 1 5268 0 discriminator 4
 6394 0024 2046     		mov	r0, r4
 6395 0026 70BD     		pop	{r4, r5, r6, pc}
 6396              	.LVL532:
 6397              	.L545:
5256:FreeRTOS/tasks.c **** 
 6398              		.loc 1 5256 0 discriminator 1
 6399 0028 014B     		ldr	r3, .L546
 6400 002a 1C68     		ldr	r4, [r3]
 6401              	.LVL533:
 6402 002c EDE7     		b	.L543
 6403              	.L547:
 6404 002e 00BF     		.align	2
 6405              	.L546:
 6406 0030 00000000 		.word	.LANCHOR10
 6407              		.cfi_endproc
 6408              	.LFE56:
 6410              		.global	uxTopUsedPriority
 6411              		.global	pxCurrentTCB
 6412              		.section	.bss.pxCurrentTCB,"aw",%nobits
 6413              		.align	2
 6414              		.set	.LANCHOR10,. + 0
 6417              	pxCurrentTCB:
 6418 0000 00000000 		.space	4
 6419              		.section	.bss.pxDelayedTaskList,"aw",%nobits
 6420              		.align	2
 6421              		.set	.LANCHOR2,. + 0
 6424              	pxDelayedTaskList:
 6425 0000 00000000 		.space	4
 6426              		.section	.bss.pxOverflowDelayedTaskList,"aw",%nobits
 6427              		.align	2
 6428              		.set	.LANCHOR8,. + 0
 6431              	pxOverflowDelayedTaskList:
 6432 0000 00000000 		.space	4
 6433              		.section	.bss.pxReadyTasksLists,"aw",%nobits
 6434              		.align	2
 6435              		.set	.LANCHOR4,. + 0
 6438              	pxReadyTasksLists:
 6439 0000 00000000 		.space	140
 6439      00000000 
 6439      00000000 
 6439      00000000 
 6439      00000000 
ARM GAS  /tmp/ccrgBt0i.s 			page 224


 6440              		.section	.bss.uxCurrentNumberOfTasks,"aw",%nobits
 6441              		.align	2
 6442              		.set	.LANCHOR9,. + 0
 6445              	uxCurrentNumberOfTasks:
 6446 0000 00000000 		.space	4
 6447              		.section	.bss.uxDeletedTasksWaitingCleanUp,"aw",%nobits
 6448              		.align	2
 6449              		.set	.LANCHOR14,. + 0
 6452              	uxDeletedTasksWaitingCleanUp:
 6453 0000 00000000 		.space	4
 6454              		.section	.bss.uxSchedulerSuspended,"aw",%nobits
 6455              		.align	2
 6456              		.set	.LANCHOR16,. + 0
 6459              	uxSchedulerSuspended:
 6460 0000 00000000 		.space	4
 6461              		.section	.bss.uxTaskNumber,"aw",%nobits
 6462              		.align	2
 6463              		.set	.LANCHOR12,. + 0
 6466              	uxTaskNumber:
 6467 0000 00000000 		.space	4
 6468              		.section	.bss.uxTopReadyPriority,"aw",%nobits
 6469              		.align	2
 6470              		.set	.LANCHOR13,. + 0
 6473              	uxTopReadyPriority:
 6474 0000 00000000 		.space	4
 6475              		.section	.bss.xDelayedTaskList1,"aw",%nobits
 6476              		.align	2
 6477              		.set	.LANCHOR5,. + 0
 6480              	xDelayedTaskList1:
 6481 0000 00000000 		.space	20
 6481      00000000 
 6481      00000000 
 6481      00000000 
 6481      00000000 
 6482              		.section	.bss.xDelayedTaskList2,"aw",%nobits
 6483              		.align	2
 6484              		.set	.LANCHOR6,. + 0
 6487              	xDelayedTaskList2:
 6488 0000 00000000 		.space	20
 6488      00000000 
 6488      00000000 
 6488      00000000 
 6488      00000000 
 6489              		.section	.bss.xIdleTaskHandle,"aw",%nobits
 6490              		.align	2
 6491              		.set	.LANCHOR18,. + 0
 6494              	xIdleTaskHandle:
 6495 0000 00000000 		.space	4
 6496              		.section	.bss.xNextTaskUnblockTime,"aw",%nobits
 6497              		.align	2
 6498              		.set	.LANCHOR3,. + 0
 6501              	xNextTaskUnblockTime:
 6502 0000 00000000 		.space	4
 6503              		.section	.bss.xNumOfOverflows,"aw",%nobits
 6504              		.align	2
 6505              		.set	.LANCHOR20,. + 0
 6508              	xNumOfOverflows:
ARM GAS  /tmp/ccrgBt0i.s 			page 225


 6509 0000 00000000 		.space	4
 6510              		.section	.bss.xPendedTicks,"aw",%nobits
 6511              		.align	2
 6512              		.set	.LANCHOR21,. + 0
 6515              	xPendedTicks:
 6516 0000 00000000 		.space	4
 6517              		.section	.bss.xPendingReadyList,"aw",%nobits
 6518              		.align	2
 6519              		.set	.LANCHOR1,. + 0
 6522              	xPendingReadyList:
 6523 0000 00000000 		.space	20
 6523      00000000 
 6523      00000000 
 6523      00000000 
 6523      00000000 
 6524              		.section	.bss.xSchedulerRunning,"aw",%nobits
 6525              		.align	2
 6526              		.set	.LANCHOR11,. + 0
 6529              	xSchedulerRunning:
 6530 0000 00000000 		.space	4
 6531              		.section	.bss.xSuspendedTaskList,"aw",%nobits
 6532              		.align	2
 6533              		.set	.LANCHOR0,. + 0
 6536              	xSuspendedTaskList:
 6537 0000 00000000 		.space	20
 6537      00000000 
 6537      00000000 
 6537      00000000 
 6537      00000000 
 6538              		.section	.bss.xTasksWaitingTermination,"aw",%nobits
 6539              		.align	2
 6540              		.set	.LANCHOR7,. + 0
 6543              	xTasksWaitingTermination:
 6544 0000 00000000 		.space	20
 6544      00000000 
 6544      00000000 
 6544      00000000 
 6544      00000000 
 6545              		.section	.bss.xTickCount,"aw",%nobits
 6546              		.align	2
 6547              		.set	.LANCHOR15,. + 0
 6550              	xTickCount:
 6551 0000 00000000 		.space	4
 6552              		.section	.bss.xYieldPending,"aw",%nobits
 6553              		.align	2
 6554              		.set	.LANCHOR17,. + 0
 6557              	xYieldPending:
 6558 0000 00000000 		.space	4
 6559              		.section	.data.uxTopUsedPriority,"aw",%progbits
 6560              		.align	2
 6561              		.set	.LANCHOR19,. + 0
 6564              	uxTopUsedPriority:
 6565 0000 06000000 		.word	6
 6566              		.section	.rodata.vTaskStartScheduler.str1.4,"aMS",%progbits,1
 6567              		.align	2
 6568              	.LC0:
 6569 0000 49444C45 		.ascii	"IDLE\000"
ARM GAS  /tmp/ccrgBt0i.s 			page 226


 6569      00
 6570              		.text
 6571              	.Letext0:
 6572              		.file 3 "/usr/lib/gcc/arm-none-eabi/7.3.1/include/stddef.h"
 6573              		.file 4 "/usr/include/newlib/machine/_default_types.h"
 6574              		.file 5 "/usr/include/newlib/sys/lock.h"
 6575              		.file 6 "/usr/include/newlib/sys/_types.h"
 6576              		.file 7 "/usr/include/newlib/sys/reent.h"
 6577              		.file 8 "/usr/include/newlib/stdlib.h"
 6578              		.file 9 "/usr/include/newlib/sys/_stdint.h"
 6579              		.file 10 "FreeRTOS/ARM_CM3/FreeRTOSConfig.h"
 6580              		.file 11 "FreeRTOS/include/projdefs.h"
 6581              		.file 12 "FreeRTOS/include/list.h"
 6582              		.file 13 "FreeRTOS/include/task.h"
 6583              		.file 14 "FreeRTOS/include/portable.h"
 6584              		.file 15 "FreeRTOS/include/timers.h"
ARM GAS  /tmp/ccrgBt0i.s 			page 227


DEFINED SYMBOLS
                            *ABS*:0000000000000000 tasks.c
     /tmp/ccrgBt0i.s:16     .text.prvTaskIsTaskSuspended:0000000000000000 $t
     /tmp/ccrgBt0i.s:22     .text.prvTaskIsTaskSuspended:0000000000000000 prvTaskIsTaskSuspended
     /tmp/ccrgBt0i.s:90     .text.prvTaskIsTaskSuspended:0000000000000038 $d
     /tmp/ccrgBt0i.s:96     .text.prvResetNextTaskUnblockTime:0000000000000000 $t
     /tmp/ccrgBt0i.s:102    .text.prvResetNextTaskUnblockTime:0000000000000000 prvResetNextTaskUnblockTime
     /tmp/ccrgBt0i.s:132    .text.prvResetNextTaskUnblockTime:0000000000000020 $d
     /tmp/ccrgBt0i.s:138    .text.prvDeleteTCB:0000000000000000 $t
     /tmp/ccrgBt0i.s:144    .text.prvDeleteTCB:0000000000000000 prvDeleteTCB
     /tmp/ccrgBt0i.s:172    .text.prvInitialiseNewTask:0000000000000000 $t
     /tmp/ccrgBt0i.s:178    .text.prvInitialiseNewTask:0000000000000000 prvInitialiseNewTask
     /tmp/ccrgBt0i.s:317    .text.prvInitialiseTaskLists:0000000000000000 $t
     /tmp/ccrgBt0i.s:323    .text.prvInitialiseTaskLists:0000000000000000 prvInitialiseTaskLists
     /tmp/ccrgBt0i.s:390    .text.prvInitialiseTaskLists:0000000000000048 $d
     /tmp/ccrgBt0i.s:402    .text.prvAddNewTaskToReadyList:0000000000000000 $t
     /tmp/ccrgBt0i.s:408    .text.prvAddNewTaskToReadyList:0000000000000000 prvAddNewTaskToReadyList
     /tmp/ccrgBt0i.s:538    .text.prvAddNewTaskToReadyList:00000000000000ac $d
     /tmp/ccrgBt0i.s:549    .text.prvCheckTasksWaitingTermination:0000000000000000 $t
     /tmp/ccrgBt0i.s:555    .text.prvCheckTasksWaitingTermination:0000000000000000 prvCheckTasksWaitingTermination
     /tmp/ccrgBt0i.s:622    .text.prvCheckTasksWaitingTermination:0000000000000040 $d
     /tmp/ccrgBt0i.s:629    .text.prvIdleTask:0000000000000000 $t
     /tmp/ccrgBt0i.s:635    .text.prvIdleTask:0000000000000000 prvIdleTask
     /tmp/ccrgBt0i.s:675    .text.prvIdleTask:0000000000000020 $d
     /tmp/ccrgBt0i.s:681    .text.prvAddCurrentTaskToDelayedList:0000000000000000 $t
     /tmp/ccrgBt0i.s:687    .text.prvAddCurrentTaskToDelayedList:0000000000000000 prvAddCurrentTaskToDelayedList
     /tmp/ccrgBt0i.s:806    .text.prvAddCurrentTaskToDelayedList:0000000000000098 $d
     /tmp/ccrgBt0i.s:817    .text.xTaskCreate:0000000000000000 $t
     /tmp/ccrgBt0i.s:824    .text.xTaskCreate:0000000000000000 xTaskCreate
     /tmp/ccrgBt0i.s:929    .text.vTaskDelete:0000000000000000 $t
     /tmp/ccrgBt0i.s:936    .text.vTaskDelete:0000000000000000 vTaskDelete
     /tmp/ccrgBt0i.s:1094   .text.vTaskDelete:00000000000000c0 $d
     /tmp/ccrgBt0i.s:1108   .text.uxTaskPriorityGet:0000000000000000 $t
     /tmp/ccrgBt0i.s:1115   .text.uxTaskPriorityGet:0000000000000000 uxTaskPriorityGet
     /tmp/ccrgBt0i.s:1154   .text.uxTaskPriorityGet:000000000000001c $d
     /tmp/ccrgBt0i.s:1159   .text.uxTaskPriorityGetFromISR:0000000000000000 $t
     /tmp/ccrgBt0i.s:1166   .text.uxTaskPriorityGetFromISR:0000000000000000 uxTaskPriorityGetFromISR
     /tmp/ccrgBt0i.s:1229   .text.uxTaskPriorityGetFromISR:000000000000002c $d
     /tmp/ccrgBt0i.s:1234   .text.vTaskPrioritySet:0000000000000000 $t
     /tmp/ccrgBt0i.s:1241   .text.vTaskPrioritySet:0000000000000000 vTaskPrioritySet
     /tmp/ccrgBt0i.s:1434   .text.vTaskPrioritySet:00000000000000e4 $d
     /tmp/ccrgBt0i.s:1442   .text.vTaskResume:0000000000000000 $t
     /tmp/ccrgBt0i.s:1449   .text.vTaskResume:0000000000000000 vTaskResume
     /tmp/ccrgBt0i.s:1567   .text.vTaskResume:000000000000008c $d
     /tmp/ccrgBt0i.s:1575   .text.xTaskResumeFromISR:0000000000000000 $t
     /tmp/ccrgBt0i.s:1582   .text.xTaskResumeFromISR:0000000000000000 xTaskResumeFromISR
     /tmp/ccrgBt0i.s:1736   .text.xTaskResumeFromISR:00000000000000b0 $d
     /tmp/ccrgBt0i.s:1746   .text.vTaskStartScheduler:0000000000000000 $t
     /tmp/ccrgBt0i.s:1753   .text.vTaskStartScheduler:0000000000000000 vTaskStartScheduler
     /tmp/ccrgBt0i.s:1859   .text.vTaskStartScheduler:0000000000000070 $d
     /tmp/ccrgBt0i.s:1872   .text.vTaskEndScheduler:0000000000000000 $t
     /tmp/ccrgBt0i.s:1879   .text.vTaskEndScheduler:0000000000000000 vTaskEndScheduler
     /tmp/ccrgBt0i.s:1917   .text.vTaskEndScheduler:0000000000000020 $d
     /tmp/ccrgBt0i.s:1922   .text.vTaskSuspendAll:0000000000000000 $t
     /tmp/ccrgBt0i.s:1929   .text.vTaskSuspendAll:0000000000000000 vTaskSuspendAll
     /tmp/ccrgBt0i.s:1947   .text.vTaskSuspendAll:000000000000000c $d
     /tmp/ccrgBt0i.s:1952   .text.xTaskGetTickCount:0000000000000000 $t
ARM GAS  /tmp/ccrgBt0i.s 			page 228


     /tmp/ccrgBt0i.s:1959   .text.xTaskGetTickCount:0000000000000000 xTaskGetTickCount
     /tmp/ccrgBt0i.s:1975   .text.xTaskGetTickCount:0000000000000008 $d
     /tmp/ccrgBt0i.s:1980   .text.xTaskGetTickCountFromISR:0000000000000000 $t
     /tmp/ccrgBt0i.s:1987   .text.xTaskGetTickCountFromISR:0000000000000000 xTaskGetTickCountFromISR
     /tmp/ccrgBt0i.s:2010   .text.xTaskGetTickCountFromISR:000000000000000c $d
     /tmp/ccrgBt0i.s:2015   .text.uxTaskGetNumberOfTasks:0000000000000000 $t
     /tmp/ccrgBt0i.s:2022   .text.uxTaskGetNumberOfTasks:0000000000000000 uxTaskGetNumberOfTasks
     /tmp/ccrgBt0i.s:2037   .text.uxTaskGetNumberOfTasks:0000000000000008 $d
     /tmp/ccrgBt0i.s:2042   .text.pcTaskGetName:0000000000000000 $t
     /tmp/ccrgBt0i.s:2049   .text.pcTaskGetName:0000000000000000 pcTaskGetName
     /tmp/ccrgBt0i.s:2095   .text.pcTaskGetName:0000000000000024 $d
     /tmp/ccrgBt0i.s:2102   .text.xTaskIncrementTick:0000000000000000 $t
     /tmp/ccrgBt0i.s:2109   .text.xTaskIncrementTick:0000000000000000 xTaskIncrementTick
     /tmp/ccrgBt0i.s:2391   .text.xTaskIncrementTick:0000000000000148 $d
     /tmp/ccrgBt0i.s:2406   .text.xTaskResumeAll:0000000000000000 $t
     /tmp/ccrgBt0i.s:2413   .text.xTaskResumeAll:0000000000000000 xTaskResumeAll
     /tmp/ccrgBt0i.s:2670   .text.xTaskResumeAll:0000000000000130 $d
     /tmp/ccrgBt0i.s:2683   .text.xTaskDelayUntil:0000000000000000 $t
     /tmp/ccrgBt0i.s:2690   .text.xTaskDelayUntil:0000000000000000 xTaskDelayUntil
     /tmp/ccrgBt0i.s:2871   .text.xTaskDelayUntil:00000000000000a4 $d
     /tmp/ccrgBt0i.s:2878   .text.vTaskDelay:0000000000000000 $t
     /tmp/ccrgBt0i.s:2885   .text.vTaskDelay:0000000000000000 vTaskDelay
     /tmp/ccrgBt0i.s:2958   .text.vTaskDelay:0000000000000044 $d
     /tmp/ccrgBt0i.s:2964   .text.xTaskCatchUpTicks:0000000000000000 $t
     /tmp/ccrgBt0i.s:2971   .text.xTaskCatchUpTicks:0000000000000000 xTaskCatchUpTicks
     /tmp/ccrgBt0i.s:3025   .text.xTaskCatchUpTicks:0000000000000030 $d
     /tmp/ccrgBt0i.s:3031   .text.vTaskSwitchContext:0000000000000000 $t
     /tmp/ccrgBt0i.s:3038   .text.vTaskSwitchContext:0000000000000000 vTaskSwitchContext
     /tmp/ccrgBt0i.s:3165   .text.vTaskSwitchContext:0000000000000084 $d
     /tmp/ccrgBt0i.s:3176   .text.vTaskSuspend:0000000000000000 $t
     /tmp/ccrgBt0i.s:3183   .text.vTaskSuspend:0000000000000000 vTaskSuspend
     /tmp/ccrgBt0i.s:3368   .text.vTaskSuspend:00000000000000d8 $d
     /tmp/ccrgBt0i.s:3380   .text.vTaskPlaceOnEventList:0000000000000000 $t
     /tmp/ccrgBt0i.s:3387   .text.vTaskPlaceOnEventList:0000000000000000 vTaskPlaceOnEventList
     /tmp/ccrgBt0i.s:3440   .text.vTaskPlaceOnEventList:000000000000002c $d
     /tmp/ccrgBt0i.s:3445   .text.vTaskPlaceOnUnorderedEventList:0000000000000000 $t
     /tmp/ccrgBt0i.s:3452   .text.vTaskPlaceOnUnorderedEventList:0000000000000000 vTaskPlaceOnUnorderedEventList
     /tmp/ccrgBt0i.s:3553   .text.vTaskPlaceOnUnorderedEventList:0000000000000068 $d
     /tmp/ccrgBt0i.s:3559   .text.vTaskPlaceOnEventListRestricted:0000000000000000 $t
     /tmp/ccrgBt0i.s:3566   .text.vTaskPlaceOnEventListRestricted:0000000000000000 vTaskPlaceOnEventListRestricted
     /tmp/ccrgBt0i.s:3650   .text.vTaskPlaceOnEventListRestricted:0000000000000050 $d
     /tmp/ccrgBt0i.s:3657   .text.xTaskRemoveFromEventList:0000000000000000 $t
     /tmp/ccrgBt0i.s:3664   .text.xTaskRemoveFromEventList:0000000000000000 xTaskRemoveFromEventList
     /tmp/ccrgBt0i.s:3859   .text.xTaskRemoveFromEventList:00000000000000e0 $d
     /tmp/ccrgBt0i.s:3869   .text.vTaskRemoveFromUnorderedEventList:0000000000000000 $t
     /tmp/ccrgBt0i.s:3876   .text.vTaskRemoveFromUnorderedEventList:0000000000000000 vTaskRemoveFromUnorderedEventList
     /tmp/ccrgBt0i.s:4063   .text.vTaskRemoveFromUnorderedEventList:00000000000000d4 $d
     /tmp/ccrgBt0i.s:4073   .text.vTaskSetTimeOutState:0000000000000000 $t
     /tmp/ccrgBt0i.s:4080   .text.vTaskSetTimeOutState:0000000000000000 vTaskSetTimeOutState
     /tmp/ccrgBt0i.s:4135   .text.vTaskSetTimeOutState:0000000000000030 $d
     /tmp/ccrgBt0i.s:4141   .text.vTaskInternalSetTimeOutState:0000000000000000 $t
     /tmp/ccrgBt0i.s:4148   .text.vTaskInternalSetTimeOutState:0000000000000000 vTaskInternalSetTimeOutState
     /tmp/ccrgBt0i.s:4169   .text.vTaskInternalSetTimeOutState:0000000000000010 $d
     /tmp/ccrgBt0i.s:4175   .text.xTaskCheckForTimeOut:0000000000000000 $t
     /tmp/ccrgBt0i.s:4182   .text.xTaskCheckForTimeOut:0000000000000000 xTaskCheckForTimeOut
     /tmp/ccrgBt0i.s:4317   .text.xTaskCheckForTimeOut:000000000000007c $d
     /tmp/ccrgBt0i.s:4324   .text.vTaskMissedYield:0000000000000000 $t
ARM GAS  /tmp/ccrgBt0i.s 			page 229


     /tmp/ccrgBt0i.s:4331   .text.vTaskMissedYield:0000000000000000 vTaskMissedYield
     /tmp/ccrgBt0i.s:4347   .text.vTaskMissedYield:0000000000000008 $d
     /tmp/ccrgBt0i.s:4352   .text.xTaskGetCurrentTaskHandle:0000000000000000 $t
     /tmp/ccrgBt0i.s:4359   .text.xTaskGetCurrentTaskHandle:0000000000000000 xTaskGetCurrentTaskHandle
     /tmp/ccrgBt0i.s:4375   .text.xTaskGetCurrentTaskHandle:0000000000000008 $d
     /tmp/ccrgBt0i.s:4380   .text.xTaskGetSchedulerState:0000000000000000 $t
     /tmp/ccrgBt0i.s:4387   .text.xTaskGetSchedulerState:0000000000000000 xTaskGetSchedulerState
     /tmp/ccrgBt0i.s:4419   .text.xTaskGetSchedulerState:0000000000000018 $d
     /tmp/ccrgBt0i.s:4425   .text.xTaskPriorityInherit:0000000000000000 $t
     /tmp/ccrgBt0i.s:4432   .text.xTaskPriorityInherit:0000000000000000 xTaskPriorityInherit
     /tmp/ccrgBt0i.s:4581   .text.xTaskPriorityInherit:00000000000000bc $d
     /tmp/ccrgBt0i.s:4588   .text.xTaskPriorityDisinherit:0000000000000000 $t
     /tmp/ccrgBt0i.s:4595   .text.xTaskPriorityDisinherit:0000000000000000 xTaskPriorityDisinherit
     /tmp/ccrgBt0i.s:4759   .text.xTaskPriorityDisinherit:00000000000000b0 $d
     /tmp/ccrgBt0i.s:4766   .text.vTaskPriorityDisinheritAfterTimeout:0000000000000000 $t
     /tmp/ccrgBt0i.s:4773   .text.vTaskPriorityDisinheritAfterTimeout:0000000000000000 vTaskPriorityDisinheritAfterTimeout
     /tmp/ccrgBt0i.s:4941   .text.vTaskPriorityDisinheritAfterTimeout:00000000000000c0 $d
     /tmp/ccrgBt0i.s:4948   .text.uxTaskResetEventItemValue:0000000000000000 $t
     /tmp/ccrgBt0i.s:4955   .text.uxTaskResetEventItemValue:0000000000000000 uxTaskResetEventItemValue
     /tmp/ccrgBt0i.s:4978   .text.uxTaskResetEventItemValue:0000000000000014 $d
     /tmp/ccrgBt0i.s:4983   .text.pvTaskIncrementMutexHeldCount:0000000000000000 $t
     /tmp/ccrgBt0i.s:4990   .text.pvTaskIncrementMutexHeldCount:0000000000000000 pvTaskIncrementMutexHeldCount
     /tmp/ccrgBt0i.s:5016   .text.pvTaskIncrementMutexHeldCount:0000000000000018 $d
     /tmp/ccrgBt0i.s:5021   .text.ulTaskGenericNotifyTake:0000000000000000 $t
     /tmp/ccrgBt0i.s:5028   .text.ulTaskGenericNotifyTake:0000000000000000 ulTaskGenericNotifyTake
     /tmp/ccrgBt0i.s:5154   .text.ulTaskGenericNotifyTake:00000000000000a4 $d
     /tmp/ccrgBt0i.s:5160   .text.xTaskGenericNotifyWait:0000000000000000 $t
     /tmp/ccrgBt0i.s:5167   .text.xTaskGenericNotifyWait:0000000000000000 xTaskGenericNotifyWait
     /tmp/ccrgBt0i.s:5315   .text.xTaskGenericNotifyWait:00000000000000c8 $d
     /tmp/ccrgBt0i.s:5321   .text.xTaskGenericNotify:0000000000000000 $t
     /tmp/ccrgBt0i.s:5328   .text.xTaskGenericNotify:0000000000000000 xTaskGenericNotify
     /tmp/ccrgBt0i.s:5400   .text.xTaskGenericNotify:0000000000000054 $d
     /tmp/ccrgBt0i.s:5631   .text.xTaskGenericNotify:000000000000016c $d
     /tmp/ccrgBt0i.s:5640   .text.xTaskGenericNotifyFromISR:0000000000000000 $t
     /tmp/ccrgBt0i.s:5647   .text.xTaskGenericNotifyFromISR:0000000000000000 xTaskGenericNotifyFromISR
     /tmp/ccrgBt0i.s:5757   .text.xTaskGenericNotifyFromISR:000000000000007e $d
     /tmp/ccrgBt0i.s:5988   .text.xTaskGenericNotifyFromISR:00000000000001a8 $d
     /tmp/ccrgBt0i.s:6000   .text.vTaskGenericNotifyGiveFromISR:0000000000000000 $t
     /tmp/ccrgBt0i.s:6007   .text.vTaskGenericNotifyGiveFromISR:0000000000000000 vTaskGenericNotifyGiveFromISR
     /tmp/ccrgBt0i.s:6246   .text.vTaskGenericNotifyGiveFromISR:000000000000011c $d
     /tmp/ccrgBt0i.s:6257   .text.xTaskGenericNotifyStateClear:0000000000000000 $t
     /tmp/ccrgBt0i.s:6264   .text.xTaskGenericNotifyStateClear:0000000000000000 xTaskGenericNotifyStateClear
     /tmp/ccrgBt0i.s:6345   .text.xTaskGenericNotifyStateClear:0000000000000048 $d
     /tmp/ccrgBt0i.s:6350   .text.ulTaskGenericNotifyValueClear:0000000000000000 $t
     /tmp/ccrgBt0i.s:6357   .text.ulTaskGenericNotifyValueClear:0000000000000000 ulTaskGenericNotifyValueClear
     /tmp/ccrgBt0i.s:6406   .text.ulTaskGenericNotifyValueClear:0000000000000030 $d
     /tmp/ccrgBt0i.s:6564   .data.uxTopUsedPriority:0000000000000000 uxTopUsedPriority
     /tmp/ccrgBt0i.s:6417   .bss.pxCurrentTCB:0000000000000000 pxCurrentTCB
     /tmp/ccrgBt0i.s:6413   .bss.pxCurrentTCB:0000000000000000 $d
     /tmp/ccrgBt0i.s:6420   .bss.pxDelayedTaskList:0000000000000000 $d
     /tmp/ccrgBt0i.s:6424   .bss.pxDelayedTaskList:0000000000000000 pxDelayedTaskList
     /tmp/ccrgBt0i.s:6427   .bss.pxOverflowDelayedTaskList:0000000000000000 $d
     /tmp/ccrgBt0i.s:6431   .bss.pxOverflowDelayedTaskList:0000000000000000 pxOverflowDelayedTaskList
     /tmp/ccrgBt0i.s:6434   .bss.pxReadyTasksLists:0000000000000000 $d
     /tmp/ccrgBt0i.s:6438   .bss.pxReadyTasksLists:0000000000000000 pxReadyTasksLists
     /tmp/ccrgBt0i.s:6441   .bss.uxCurrentNumberOfTasks:0000000000000000 $d
     /tmp/ccrgBt0i.s:6445   .bss.uxCurrentNumberOfTasks:0000000000000000 uxCurrentNumberOfTasks
ARM GAS  /tmp/ccrgBt0i.s 			page 230


     /tmp/ccrgBt0i.s:6448   .bss.uxDeletedTasksWaitingCleanUp:0000000000000000 $d
     /tmp/ccrgBt0i.s:6452   .bss.uxDeletedTasksWaitingCleanUp:0000000000000000 uxDeletedTasksWaitingCleanUp
     /tmp/ccrgBt0i.s:6455   .bss.uxSchedulerSuspended:0000000000000000 $d
     /tmp/ccrgBt0i.s:6459   .bss.uxSchedulerSuspended:0000000000000000 uxSchedulerSuspended
     /tmp/ccrgBt0i.s:6462   .bss.uxTaskNumber:0000000000000000 $d
     /tmp/ccrgBt0i.s:6466   .bss.uxTaskNumber:0000000000000000 uxTaskNumber
     /tmp/ccrgBt0i.s:6469   .bss.uxTopReadyPriority:0000000000000000 $d
     /tmp/ccrgBt0i.s:6473   .bss.uxTopReadyPriority:0000000000000000 uxTopReadyPriority
     /tmp/ccrgBt0i.s:6476   .bss.xDelayedTaskList1:0000000000000000 $d
     /tmp/ccrgBt0i.s:6480   .bss.xDelayedTaskList1:0000000000000000 xDelayedTaskList1
     /tmp/ccrgBt0i.s:6483   .bss.xDelayedTaskList2:0000000000000000 $d
     /tmp/ccrgBt0i.s:6487   .bss.xDelayedTaskList2:0000000000000000 xDelayedTaskList2
     /tmp/ccrgBt0i.s:6490   .bss.xIdleTaskHandle:0000000000000000 $d
     /tmp/ccrgBt0i.s:6494   .bss.xIdleTaskHandle:0000000000000000 xIdleTaskHandle
     /tmp/ccrgBt0i.s:6497   .bss.xNextTaskUnblockTime:0000000000000000 $d
     /tmp/ccrgBt0i.s:6501   .bss.xNextTaskUnblockTime:0000000000000000 xNextTaskUnblockTime
     /tmp/ccrgBt0i.s:6504   .bss.xNumOfOverflows:0000000000000000 $d
     /tmp/ccrgBt0i.s:6508   .bss.xNumOfOverflows:0000000000000000 xNumOfOverflows
     /tmp/ccrgBt0i.s:6511   .bss.xPendedTicks:0000000000000000 $d
     /tmp/ccrgBt0i.s:6515   .bss.xPendedTicks:0000000000000000 xPendedTicks
     /tmp/ccrgBt0i.s:6518   .bss.xPendingReadyList:0000000000000000 $d
     /tmp/ccrgBt0i.s:6522   .bss.xPendingReadyList:0000000000000000 xPendingReadyList
     /tmp/ccrgBt0i.s:6525   .bss.xSchedulerRunning:0000000000000000 $d
     /tmp/ccrgBt0i.s:6529   .bss.xSchedulerRunning:0000000000000000 xSchedulerRunning
     /tmp/ccrgBt0i.s:6532   .bss.xSuspendedTaskList:0000000000000000 $d
     /tmp/ccrgBt0i.s:6536   .bss.xSuspendedTaskList:0000000000000000 xSuspendedTaskList
     /tmp/ccrgBt0i.s:6539   .bss.xTasksWaitingTermination:0000000000000000 $d
     /tmp/ccrgBt0i.s:6543   .bss.xTasksWaitingTermination:0000000000000000 xTasksWaitingTermination
     /tmp/ccrgBt0i.s:6546   .bss.xTickCount:0000000000000000 $d
     /tmp/ccrgBt0i.s:6550   .bss.xTickCount:0000000000000000 xTickCount
     /tmp/ccrgBt0i.s:6553   .bss.xYieldPending:0000000000000000 $d
     /tmp/ccrgBt0i.s:6557   .bss.xYieldPending:0000000000000000 xYieldPending
     /tmp/ccrgBt0i.s:6560   .data.uxTopUsedPriority:0000000000000000 $d
     /tmp/ccrgBt0i.s:6567   .rodata.vTaskStartScheduler.str1.4:0000000000000000 $d
     /tmp/ccrgBt0i.s:5406   .text.xTaskGenericNotify:0000000000000059 $d
     /tmp/ccrgBt0i.s:5406   .text.xTaskGenericNotify:000000000000005a $t
     /tmp/ccrgBt0i.s:5762   .text.xTaskGenericNotifyFromISR:0000000000000083 $d
     /tmp/ccrgBt0i.s:5762   .text.xTaskGenericNotifyFromISR:0000000000000084 $t

UNDEFINED SYMBOLS
vPortFree
vListInitialiseItem
pxPortInitialiseStack
vListInitialise
vPortEnterCritical
vPortExitCritical
uxListRemove
vListInsert
pvPortMalloc
vListInsertEnd
vPortValidateInterruptPriority
xTimerCreateTimerTask
xPortStartScheduler
vPortEndScheduler
