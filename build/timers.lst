ARM GAS  /tmp/cczeOkKz.s 			page 1


   1              		.cpu cortex-m3
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 1
   9              		.eabi_attribute 34, 1
  10              		.eabi_attribute 18, 4
  11              		.file	"timers.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.section	.text.prvGetNextExpireTime,"ax",%progbits
  16              		.align	1
  17              		.syntax unified
  18              		.thumb
  19              		.thumb_func
  20              		.fpu softvfp
  22              	prvGetNextExpireTime:
  23              	.LFB19:
  24              		.file 1 "FreeRTOS/timers.c"
   1:FreeRTOS/timers.c **** /*
   2:FreeRTOS/timers.c ****  * FreeRTOS Kernel V10.4.6
   3:FreeRTOS/timers.c ****  * Copyright (C) 2021 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
   4:FreeRTOS/timers.c ****  *
   5:FreeRTOS/timers.c ****  * SPDX-License-Identifier: MIT
   6:FreeRTOS/timers.c ****  *
   7:FreeRTOS/timers.c ****  * Permission is hereby granted, free of charge, to any person obtaining a copy of
   8:FreeRTOS/timers.c ****  * this software and associated documentation files (the "Software"), to deal in
   9:FreeRTOS/timers.c ****  * the Software without restriction, including without limitation the rights to
  10:FreeRTOS/timers.c ****  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
  11:FreeRTOS/timers.c ****  * the Software, and to permit persons to whom the Software is furnished to do so,
  12:FreeRTOS/timers.c ****  * subject to the following conditions:
  13:FreeRTOS/timers.c ****  *
  14:FreeRTOS/timers.c ****  * The above copyright notice and this permission notice shall be included in all
  15:FreeRTOS/timers.c ****  * copies or substantial portions of the Software.
  16:FreeRTOS/timers.c ****  *
  17:FreeRTOS/timers.c ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  18:FreeRTOS/timers.c ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  19:FreeRTOS/timers.c ****  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  20:FreeRTOS/timers.c ****  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  21:FreeRTOS/timers.c ****  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  22:FreeRTOS/timers.c ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  23:FreeRTOS/timers.c ****  *
  24:FreeRTOS/timers.c ****  * https://www.FreeRTOS.org
  25:FreeRTOS/timers.c ****  * https://github.com/FreeRTOS
  26:FreeRTOS/timers.c ****  *
  27:FreeRTOS/timers.c ****  */
  28:FreeRTOS/timers.c **** 
  29:FreeRTOS/timers.c **** /* Standard includes. */
  30:FreeRTOS/timers.c **** #include <stdlib.h>
  31:FreeRTOS/timers.c **** 
  32:FreeRTOS/timers.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  33:FreeRTOS/timers.c ****  * all the API functions to use the MPU wrappers.  That should only be done when
  34:FreeRTOS/timers.c ****  * task.h is included from an application file. */
ARM GAS  /tmp/cczeOkKz.s 			page 2


  35:FreeRTOS/timers.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  36:FreeRTOS/timers.c **** 
  37:FreeRTOS/timers.c **** #include "FreeRTOS.h"
  38:FreeRTOS/timers.c **** #include "task.h"
  39:FreeRTOS/timers.c **** #include "queue.h"
  40:FreeRTOS/timers.c **** #include "timers.h"
  41:FreeRTOS/timers.c **** 
  42:FreeRTOS/timers.c **** #if ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 0 )
  43:FreeRTOS/timers.c ****     #error configUSE_TIMERS must be set to 1 to make the xTimerPendFunctionCall() function availabl
  44:FreeRTOS/timers.c **** #endif
  45:FreeRTOS/timers.c **** 
  46:FreeRTOS/timers.c **** /* Lint e9021, e961 and e750 are suppressed as a MISRA exception justified
  47:FreeRTOS/timers.c ****  * because the MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined
  48:FreeRTOS/timers.c ****  * for the header files above, but not in this file, in order to generate the
  49:FreeRTOS/timers.c ****  * correct privileged Vs unprivileged linkage and placement. */
  50:FreeRTOS/timers.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e9021 !e961 !e750. */
  51:FreeRTOS/timers.c **** 
  52:FreeRTOS/timers.c **** 
  53:FreeRTOS/timers.c **** /* This entire source file will be skipped if the application is not configured
  54:FreeRTOS/timers.c ****  * to include software timer functionality.  This #if is closed at the very bottom
  55:FreeRTOS/timers.c ****  * of this file.  If you want to include software timer functionality then ensure
  56:FreeRTOS/timers.c ****  * configUSE_TIMERS is set to 1 in FreeRTOSConfig.h. */
  57:FreeRTOS/timers.c **** #if ( configUSE_TIMERS == 1 )
  58:FreeRTOS/timers.c **** 
  59:FreeRTOS/timers.c **** /* Misc definitions. */
  60:FreeRTOS/timers.c ****     #define tmrNO_DELAY                    ( ( TickType_t ) 0U )
  61:FreeRTOS/timers.c ****     #define tmrMAX_TIME_BEFORE_OVERFLOW    ( ( TickType_t ) -1 )
  62:FreeRTOS/timers.c **** 
  63:FreeRTOS/timers.c **** /* The name assigned to the timer service task.  This can be overridden by
  64:FreeRTOS/timers.c ****  * defining trmTIMER_SERVICE_TASK_NAME in FreeRTOSConfig.h. */
  65:FreeRTOS/timers.c ****     #ifndef configTIMER_SERVICE_TASK_NAME
  66:FreeRTOS/timers.c ****         #define configTIMER_SERVICE_TASK_NAME    "Tmr Svc"
  67:FreeRTOS/timers.c ****     #endif
  68:FreeRTOS/timers.c **** 
  69:FreeRTOS/timers.c **** /* Bit definitions used in the ucStatus member of a timer structure. */
  70:FreeRTOS/timers.c ****     #define tmrSTATUS_IS_ACTIVE                  ( ( uint8_t ) 0x01 )
  71:FreeRTOS/timers.c ****     #define tmrSTATUS_IS_STATICALLY_ALLOCATED    ( ( uint8_t ) 0x02 )
  72:FreeRTOS/timers.c ****     #define tmrSTATUS_IS_AUTORELOAD              ( ( uint8_t ) 0x04 )
  73:FreeRTOS/timers.c **** 
  74:FreeRTOS/timers.c **** /* The definition of the timers themselves. */
  75:FreeRTOS/timers.c ****     typedef struct tmrTimerControl                  /* The old naming convention is used to prevent
  76:FreeRTOS/timers.c ****     {
  77:FreeRTOS/timers.c ****         const char * pcTimerName;                   /*<< Text name.  This is not used by the kernel
  78:FreeRTOS/timers.c ****         ListItem_t xTimerListItem;                  /*<< Standard linked list item as used by all k
  79:FreeRTOS/timers.c ****         TickType_t xTimerPeriodInTicks;             /*<< How quickly and often the timer expires. *
  80:FreeRTOS/timers.c ****         void * pvTimerID;                           /*<< An ID to identify the timer.  This allows 
  81:FreeRTOS/timers.c ****         TimerCallbackFunction_t pxCallbackFunction; /*<< The function that will be called when the 
  82:FreeRTOS/timers.c ****         #if ( configUSE_TRACE_FACILITY == 1 )
  83:FreeRTOS/timers.c ****             UBaseType_t uxTimerNumber;              /*<< An ID assigned by trace tools such as Free
  84:FreeRTOS/timers.c ****         #endif
  85:FreeRTOS/timers.c ****         uint8_t ucStatus;                           /*<< Holds bits to say if the timer was statica
  86:FreeRTOS/timers.c ****     } xTIMER;
  87:FreeRTOS/timers.c **** 
  88:FreeRTOS/timers.c **** /* The old xTIMER name is maintained above then typedefed to the new Timer_t
  89:FreeRTOS/timers.c ****  * name below to enable the use of older kernel aware debuggers. */
  90:FreeRTOS/timers.c ****     typedef xTIMER Timer_t;
  91:FreeRTOS/timers.c **** 
ARM GAS  /tmp/cczeOkKz.s 			page 3


  92:FreeRTOS/timers.c **** /* The definition of messages that can be sent and received on the timer queue.
  93:FreeRTOS/timers.c ****  * Two types of message can be queued - messages that manipulate a software timer,
  94:FreeRTOS/timers.c ****  * and messages that request the execution of a non-timer related callback.  The
  95:FreeRTOS/timers.c ****  * two message types are defined in two separate structures, xTimerParametersType
  96:FreeRTOS/timers.c ****  * and xCallbackParametersType respectively. */
  97:FreeRTOS/timers.c ****     typedef struct tmrTimerParameters
  98:FreeRTOS/timers.c ****     {
  99:FreeRTOS/timers.c ****         TickType_t xMessageValue; /*<< An optional value used by a subset of commands, for example,
 100:FreeRTOS/timers.c ****         Timer_t * pxTimer;        /*<< The timer to which the command will be applied. */
 101:FreeRTOS/timers.c ****     } TimerParameter_t;
 102:FreeRTOS/timers.c **** 
 103:FreeRTOS/timers.c **** 
 104:FreeRTOS/timers.c ****     typedef struct tmrCallbackParameters
 105:FreeRTOS/timers.c ****     {
 106:FreeRTOS/timers.c ****         PendedFunction_t pxCallbackFunction; /* << The callback function to execute. */
 107:FreeRTOS/timers.c ****         void * pvParameter1;                 /* << The value that will be used as the callback func
 108:FreeRTOS/timers.c ****         uint32_t ulParameter2;               /* << The value that will be used as the callback func
 109:FreeRTOS/timers.c ****     } CallbackParameters_t;
 110:FreeRTOS/timers.c **** 
 111:FreeRTOS/timers.c **** /* The structure that contains the two message types, along with an identifier
 112:FreeRTOS/timers.c ****  * that is used to determine which message type is valid. */
 113:FreeRTOS/timers.c ****     typedef struct tmrTimerQueueMessage
 114:FreeRTOS/timers.c ****     {
 115:FreeRTOS/timers.c ****         BaseType_t xMessageID; /*<< The command being sent to the timer service task. */
 116:FreeRTOS/timers.c ****         union
 117:FreeRTOS/timers.c ****         {
 118:FreeRTOS/timers.c ****             TimerParameter_t xTimerParameters;
 119:FreeRTOS/timers.c **** 
 120:FreeRTOS/timers.c ****             /* Don't include xCallbackParameters if it is not going to be used as
 121:FreeRTOS/timers.c ****              * it makes the structure (and therefore the timer queue) larger. */
 122:FreeRTOS/timers.c ****             #if ( INCLUDE_xTimerPendFunctionCall == 1 )
 123:FreeRTOS/timers.c ****                 CallbackParameters_t xCallbackParameters;
 124:FreeRTOS/timers.c ****             #endif /* INCLUDE_xTimerPendFunctionCall */
 125:FreeRTOS/timers.c ****         } u;
 126:FreeRTOS/timers.c ****     } DaemonTaskMessage_t;
 127:FreeRTOS/timers.c **** 
 128:FreeRTOS/timers.c **** /*lint -save -e956 A manual analysis and inspection has been used to determine
 129:FreeRTOS/timers.c ****  * which static variables must be declared volatile. */
 130:FreeRTOS/timers.c **** 
 131:FreeRTOS/timers.c **** /* The list in which active timers are stored.  Timers are referenced in expire
 132:FreeRTOS/timers.c ****  * time order, with the nearest expiry time at the front of the list.  Only the
 133:FreeRTOS/timers.c ****  * timer service task is allowed to access these lists.
 134:FreeRTOS/timers.c ****  * xActiveTimerList1 and xActiveTimerList2 could be at function scope but that
 135:FreeRTOS/timers.c ****  * breaks some kernel aware debuggers, and debuggers that reply on removing the
 136:FreeRTOS/timers.c ****  * static qualifier. */
 137:FreeRTOS/timers.c ****     PRIVILEGED_DATA static List_t xActiveTimerList1;
 138:FreeRTOS/timers.c ****     PRIVILEGED_DATA static List_t xActiveTimerList2;
 139:FreeRTOS/timers.c ****     PRIVILEGED_DATA static List_t * pxCurrentTimerList;
 140:FreeRTOS/timers.c ****     PRIVILEGED_DATA static List_t * pxOverflowTimerList;
 141:FreeRTOS/timers.c **** 
 142:FreeRTOS/timers.c **** /* A queue that is used to send commands to the timer service task. */
 143:FreeRTOS/timers.c ****     PRIVILEGED_DATA static QueueHandle_t xTimerQueue = NULL;
 144:FreeRTOS/timers.c ****     PRIVILEGED_DATA static TaskHandle_t xTimerTaskHandle = NULL;
 145:FreeRTOS/timers.c **** 
 146:FreeRTOS/timers.c **** /*lint -restore */
 147:FreeRTOS/timers.c **** 
 148:FreeRTOS/timers.c **** /*-----------------------------------------------------------*/
ARM GAS  /tmp/cczeOkKz.s 			page 4


 149:FreeRTOS/timers.c **** 
 150:FreeRTOS/timers.c **** /*
 151:FreeRTOS/timers.c ****  * Initialise the infrastructure used by the timer service task if it has not
 152:FreeRTOS/timers.c ****  * been initialised already.
 153:FreeRTOS/timers.c ****  */
 154:FreeRTOS/timers.c ****     static void prvCheckForValidListAndQueue( void ) PRIVILEGED_FUNCTION;
 155:FreeRTOS/timers.c **** 
 156:FreeRTOS/timers.c **** /*
 157:FreeRTOS/timers.c ****  * The timer service task (daemon).  Timer functionality is controlled by this
 158:FreeRTOS/timers.c ****  * task.  Other tasks communicate with the timer service task using the
 159:FreeRTOS/timers.c ****  * xTimerQueue queue.
 160:FreeRTOS/timers.c ****  */
 161:FreeRTOS/timers.c ****     static portTASK_FUNCTION_PROTO( prvTimerTask, pvParameters ) PRIVILEGED_FUNCTION;
 162:FreeRTOS/timers.c **** 
 163:FreeRTOS/timers.c **** /*
 164:FreeRTOS/timers.c ****  * Called by the timer service task to interpret and process a command it
 165:FreeRTOS/timers.c ****  * received on the timer queue.
 166:FreeRTOS/timers.c ****  */
 167:FreeRTOS/timers.c ****     static void prvProcessReceivedCommands( void ) PRIVILEGED_FUNCTION;
 168:FreeRTOS/timers.c **** 
 169:FreeRTOS/timers.c **** /*
 170:FreeRTOS/timers.c ****  * Insert the timer into either xActiveTimerList1, or xActiveTimerList2,
 171:FreeRTOS/timers.c ****  * depending on if the expire time causes a timer counter overflow.
 172:FreeRTOS/timers.c ****  */
 173:FreeRTOS/timers.c ****     static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer,
 174:FreeRTOS/timers.c ****                                                   const TickType_t xNextExpiryTime,
 175:FreeRTOS/timers.c ****                                                   const TickType_t xTimeNow,
 176:FreeRTOS/timers.c ****                                                   const TickType_t xCommandTime ) PRIVILEGED_FUNCTI
 177:FreeRTOS/timers.c **** 
 178:FreeRTOS/timers.c **** /*
 179:FreeRTOS/timers.c ****  * Reload the specified auto-reload timer.  If the reloading is backlogged,
 180:FreeRTOS/timers.c ****  * clear the backlog, calling the callback for each additional reload.  When
 181:FreeRTOS/timers.c ****  * this function returns, the next expiry time is after xTimeNow.
 182:FreeRTOS/timers.c ****  */
 183:FreeRTOS/timers.c ****     static void prvReloadTimer( Timer_t * const pxTimer,
 184:FreeRTOS/timers.c ****                                 TickType_t xExpiredTime,
 185:FreeRTOS/timers.c ****                                 const TickType_t xTimeNow ) PRIVILEGED_FUNCTION;
 186:FreeRTOS/timers.c **** 
 187:FreeRTOS/timers.c **** /*
 188:FreeRTOS/timers.c ****  * An active timer has reached its expire time.  Reload the timer if it is an
 189:FreeRTOS/timers.c ****  * auto-reload timer, then call its callback.
 190:FreeRTOS/timers.c ****  */
 191:FreeRTOS/timers.c ****     static void prvProcessExpiredTimer( const TickType_t xNextExpireTime,
 192:FreeRTOS/timers.c ****                                         const TickType_t xTimeNow ) PRIVILEGED_FUNCTION;
 193:FreeRTOS/timers.c **** 
 194:FreeRTOS/timers.c **** /*
 195:FreeRTOS/timers.c ****  * The tick count has overflowed.  Switch the timer lists after ensuring the
 196:FreeRTOS/timers.c ****  * current timer list does not still reference some timers.
 197:FreeRTOS/timers.c ****  */
 198:FreeRTOS/timers.c ****     static void prvSwitchTimerLists( void ) PRIVILEGED_FUNCTION;
 199:FreeRTOS/timers.c **** 
 200:FreeRTOS/timers.c **** /*
 201:FreeRTOS/timers.c ****  * Obtain the current tick count, setting *pxTimerListsWereSwitched to pdTRUE
 202:FreeRTOS/timers.c ****  * if a tick count overflow occurred since prvSampleTimeNow() was last called.
 203:FreeRTOS/timers.c ****  */
 204:FreeRTOS/timers.c ****     static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched ) PRIVILEGED_FU
 205:FreeRTOS/timers.c **** 
ARM GAS  /tmp/cczeOkKz.s 			page 5


 206:FreeRTOS/timers.c **** /*
 207:FreeRTOS/timers.c ****  * If the timer list contains any active timers then return the expire time of
 208:FreeRTOS/timers.c ****  * the timer that will expire first and set *pxListWasEmpty to false.  If the
 209:FreeRTOS/timers.c ****  * timer list does not contain any timers then return 0 and set *pxListWasEmpty
 210:FreeRTOS/timers.c ****  * to pdTRUE.
 211:FreeRTOS/timers.c ****  */
 212:FreeRTOS/timers.c ****     static TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty ) PRIVILEGED_FUNCTION
 213:FreeRTOS/timers.c **** 
 214:FreeRTOS/timers.c **** /*
 215:FreeRTOS/timers.c ****  * If a timer has expired, process it.  Otherwise, block the timer service task
 216:FreeRTOS/timers.c ****  * until either a timer does expire or a command is received.
 217:FreeRTOS/timers.c ****  */
 218:FreeRTOS/timers.c ****     static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime,
 219:FreeRTOS/timers.c ****                                             BaseType_t xListWasEmpty ) PRIVILEGED_FUNCTION;
 220:FreeRTOS/timers.c **** 
 221:FreeRTOS/timers.c **** /*
 222:FreeRTOS/timers.c ****  * Called after a Timer_t structure has been allocated either statically or
 223:FreeRTOS/timers.c ****  * dynamically to fill in the structure's members.
 224:FreeRTOS/timers.c ****  */
 225:FreeRTOS/timers.c ****     static void prvInitialiseNewTimer( const char * const pcTimerName, /*lint !e971 Unqualified cha
 226:FreeRTOS/timers.c ****                                        const TickType_t xTimerPeriodInTicks,
 227:FreeRTOS/timers.c ****                                        const UBaseType_t uxAutoReload,
 228:FreeRTOS/timers.c ****                                        void * const pvTimerID,
 229:FreeRTOS/timers.c ****                                        TimerCallbackFunction_t pxCallbackFunction,
 230:FreeRTOS/timers.c ****                                        Timer_t * pxNewTimer ) PRIVILEGED_FUNCTION;
 231:FreeRTOS/timers.c **** /*-----------------------------------------------------------*/
 232:FreeRTOS/timers.c **** 
 233:FreeRTOS/timers.c ****     BaseType_t xTimerCreateTimerTask( void )
 234:FreeRTOS/timers.c ****     {
 235:FreeRTOS/timers.c ****         BaseType_t xReturn = pdFAIL;
 236:FreeRTOS/timers.c **** 
 237:FreeRTOS/timers.c ****         /* This function is called when the scheduler is started if
 238:FreeRTOS/timers.c ****          * configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
 239:FreeRTOS/timers.c ****          * timer service task has been created/initialised.  If timers have already
 240:FreeRTOS/timers.c ****          * been created then the initialisation will already have been performed. */
 241:FreeRTOS/timers.c ****         prvCheckForValidListAndQueue();
 242:FreeRTOS/timers.c **** 
 243:FreeRTOS/timers.c ****         if( xTimerQueue != NULL )
 244:FreeRTOS/timers.c ****         {
 245:FreeRTOS/timers.c ****             #if ( configSUPPORT_STATIC_ALLOCATION == 1 )
 246:FreeRTOS/timers.c ****                 {
 247:FreeRTOS/timers.c ****                     StaticTask_t * pxTimerTaskTCBBuffer = NULL;
 248:FreeRTOS/timers.c ****                     StackType_t * pxTimerTaskStackBuffer = NULL;
 249:FreeRTOS/timers.c ****                     uint32_t ulTimerTaskStackSize;
 250:FreeRTOS/timers.c **** 
 251:FreeRTOS/timers.c ****                     vApplicationGetTimerTaskMemory( &pxTimerTaskTCBBuffer, &pxTimerTaskStackBuffer,
 252:FreeRTOS/timers.c ****                     xTimerTaskHandle = xTaskCreateStatic( prvTimerTask,
 253:FreeRTOS/timers.c ****                                                           configTIMER_SERVICE_TASK_NAME,
 254:FreeRTOS/timers.c ****                                                           ulTimerTaskStackSize,
 255:FreeRTOS/timers.c ****                                                           NULL,
 256:FreeRTOS/timers.c ****                                                           ( ( UBaseType_t ) configTIMER_TASK_PRIORI
 257:FreeRTOS/timers.c ****                                                           pxTimerTaskStackBuffer,
 258:FreeRTOS/timers.c ****                                                           pxTimerTaskTCBBuffer );
 259:FreeRTOS/timers.c **** 
 260:FreeRTOS/timers.c ****                     if( xTimerTaskHandle != NULL )
 261:FreeRTOS/timers.c ****                     {
 262:FreeRTOS/timers.c ****                         xReturn = pdPASS;
ARM GAS  /tmp/cczeOkKz.s 			page 6


 263:FreeRTOS/timers.c ****                     }
 264:FreeRTOS/timers.c ****                 }
 265:FreeRTOS/timers.c ****             #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
 266:FreeRTOS/timers.c ****                 {
 267:FreeRTOS/timers.c ****                     xReturn = xTaskCreate( prvTimerTask,
 268:FreeRTOS/timers.c ****                                            configTIMER_SERVICE_TASK_NAME,
 269:FreeRTOS/timers.c ****                                            configTIMER_TASK_STACK_DEPTH,
 270:FreeRTOS/timers.c ****                                            NULL,
 271:FreeRTOS/timers.c ****                                            ( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIV
 272:FreeRTOS/timers.c ****                                            &xTimerTaskHandle );
 273:FreeRTOS/timers.c ****                 }
 274:FreeRTOS/timers.c ****             #endif /* configSUPPORT_STATIC_ALLOCATION */
 275:FreeRTOS/timers.c ****         }
 276:FreeRTOS/timers.c ****         else
 277:FreeRTOS/timers.c ****         {
 278:FreeRTOS/timers.c ****             mtCOVERAGE_TEST_MARKER();
 279:FreeRTOS/timers.c ****         }
 280:FreeRTOS/timers.c **** 
 281:FreeRTOS/timers.c ****         configASSERT( xReturn );
 282:FreeRTOS/timers.c ****         return xReturn;
 283:FreeRTOS/timers.c ****     }
 284:FreeRTOS/timers.c **** /*-----------------------------------------------------------*/
 285:FreeRTOS/timers.c **** 
 286:FreeRTOS/timers.c ****     #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
 287:FreeRTOS/timers.c **** 
 288:FreeRTOS/timers.c ****         TimerHandle_t xTimerCreate( const char * const pcTimerName, /*lint !e971 Unqualified char t
 289:FreeRTOS/timers.c ****                                     const TickType_t xTimerPeriodInTicks,
 290:FreeRTOS/timers.c ****                                     const UBaseType_t uxAutoReload,
 291:FreeRTOS/timers.c ****                                     void * const pvTimerID,
 292:FreeRTOS/timers.c ****                                     TimerCallbackFunction_t pxCallbackFunction )
 293:FreeRTOS/timers.c ****         {
 294:FreeRTOS/timers.c ****             Timer_t * pxNewTimer;
 295:FreeRTOS/timers.c **** 
 296:FreeRTOS/timers.c ****             pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) ); /*lint !e9087 !e9079 All 
 297:FreeRTOS/timers.c **** 
 298:FreeRTOS/timers.c ****             if( pxNewTimer != NULL )
 299:FreeRTOS/timers.c ****             {
 300:FreeRTOS/timers.c ****                 /* Status is thus far zero as the timer is not created statically
 301:FreeRTOS/timers.c ****                  * and has not been started.  The auto-reload bit may get set in
 302:FreeRTOS/timers.c ****                  * prvInitialiseNewTimer. */
 303:FreeRTOS/timers.c ****                 pxNewTimer->ucStatus = 0x00;
 304:FreeRTOS/timers.c ****                 prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, p
 305:FreeRTOS/timers.c ****             }
 306:FreeRTOS/timers.c **** 
 307:FreeRTOS/timers.c ****             return pxNewTimer;
 308:FreeRTOS/timers.c ****         }
 309:FreeRTOS/timers.c **** 
 310:FreeRTOS/timers.c ****     #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
 311:FreeRTOS/timers.c **** /*-----------------------------------------------------------*/
 312:FreeRTOS/timers.c **** 
 313:FreeRTOS/timers.c ****     #if ( configSUPPORT_STATIC_ALLOCATION == 1 )
 314:FreeRTOS/timers.c **** 
 315:FreeRTOS/timers.c ****         TimerHandle_t xTimerCreateStatic( const char * const pcTimerName, /*lint !e971 Unqualified 
 316:FreeRTOS/timers.c ****                                           const TickType_t xTimerPeriodInTicks,
 317:FreeRTOS/timers.c ****                                           const UBaseType_t uxAutoReload,
 318:FreeRTOS/timers.c ****                                           void * const pvTimerID,
 319:FreeRTOS/timers.c ****                                           TimerCallbackFunction_t pxCallbackFunction,
ARM GAS  /tmp/cczeOkKz.s 			page 7


 320:FreeRTOS/timers.c ****                                           StaticTimer_t * pxTimerBuffer )
 321:FreeRTOS/timers.c ****         {
 322:FreeRTOS/timers.c ****             Timer_t * pxNewTimer;
 323:FreeRTOS/timers.c **** 
 324:FreeRTOS/timers.c ****             #if ( configASSERT_DEFINED == 1 )
 325:FreeRTOS/timers.c ****                 {
 326:FreeRTOS/timers.c ****                     /* Sanity check that the size of the structure used to declare a
 327:FreeRTOS/timers.c ****                      * variable of type StaticTimer_t equals the size of the real timer
 328:FreeRTOS/timers.c ****                      * structure. */
 329:FreeRTOS/timers.c ****                     volatile size_t xSize = sizeof( StaticTimer_t );
 330:FreeRTOS/timers.c ****                     configASSERT( xSize == sizeof( Timer_t ) );
 331:FreeRTOS/timers.c ****                     ( void ) xSize; /* Keeps lint quiet when configASSERT() is not defined. */
 332:FreeRTOS/timers.c ****                 }
 333:FreeRTOS/timers.c ****             #endif /* configASSERT_DEFINED */
 334:FreeRTOS/timers.c **** 
 335:FreeRTOS/timers.c ****             /* A pointer to a StaticTimer_t structure MUST be provided, use it. */
 336:FreeRTOS/timers.c ****             configASSERT( pxTimerBuffer );
 337:FreeRTOS/timers.c ****             pxNewTimer = ( Timer_t * ) pxTimerBuffer; /*lint !e740 !e9087 StaticTimer_t is a pointe
 338:FreeRTOS/timers.c **** 
 339:FreeRTOS/timers.c ****             if( pxNewTimer != NULL )
 340:FreeRTOS/timers.c ****             {
 341:FreeRTOS/timers.c ****                 /* Timers can be created statically or dynamically so note this
 342:FreeRTOS/timers.c ****                  * timer was created statically in case it is later deleted.  The
 343:FreeRTOS/timers.c ****                  * auto-reload bit may get set in prvInitialiseNewTimer(). */
 344:FreeRTOS/timers.c ****                 pxNewTimer->ucStatus = tmrSTATUS_IS_STATICALLY_ALLOCATED;
 345:FreeRTOS/timers.c **** 
 346:FreeRTOS/timers.c ****                 prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, p
 347:FreeRTOS/timers.c ****             }
 348:FreeRTOS/timers.c **** 
 349:FreeRTOS/timers.c ****             return pxNewTimer;
 350:FreeRTOS/timers.c ****         }
 351:FreeRTOS/timers.c **** 
 352:FreeRTOS/timers.c ****     #endif /* configSUPPORT_STATIC_ALLOCATION */
 353:FreeRTOS/timers.c **** /*-----------------------------------------------------------*/
 354:FreeRTOS/timers.c **** 
 355:FreeRTOS/timers.c ****     static void prvInitialiseNewTimer( const char * const pcTimerName, /*lint !e971 Unqualified cha
 356:FreeRTOS/timers.c ****                                        const TickType_t xTimerPeriodInTicks,
 357:FreeRTOS/timers.c ****                                        const UBaseType_t uxAutoReload,
 358:FreeRTOS/timers.c ****                                        void * const pvTimerID,
 359:FreeRTOS/timers.c ****                                        TimerCallbackFunction_t pxCallbackFunction,
 360:FreeRTOS/timers.c ****                                        Timer_t * pxNewTimer )
 361:FreeRTOS/timers.c ****     {
 362:FreeRTOS/timers.c ****         /* 0 is not a valid value for xTimerPeriodInTicks. */
 363:FreeRTOS/timers.c ****         configASSERT( ( xTimerPeriodInTicks > 0 ) );
 364:FreeRTOS/timers.c **** 
 365:FreeRTOS/timers.c ****         /* Ensure the infrastructure used by the timer service task has been
 366:FreeRTOS/timers.c ****          * created/initialised. */
 367:FreeRTOS/timers.c ****         prvCheckForValidListAndQueue();
 368:FreeRTOS/timers.c **** 
 369:FreeRTOS/timers.c ****         /* Initialise the timer structure members using the function
 370:FreeRTOS/timers.c ****          * parameters. */
 371:FreeRTOS/timers.c ****         pxNewTimer->pcTimerName = pcTimerName;
 372:FreeRTOS/timers.c ****         pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
 373:FreeRTOS/timers.c ****         pxNewTimer->pvTimerID = pvTimerID;
 374:FreeRTOS/timers.c ****         pxNewTimer->pxCallbackFunction = pxCallbackFunction;
 375:FreeRTOS/timers.c ****         vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
 376:FreeRTOS/timers.c **** 
ARM GAS  /tmp/cczeOkKz.s 			page 8


 377:FreeRTOS/timers.c ****         if( uxAutoReload != pdFALSE )
 378:FreeRTOS/timers.c ****         {
 379:FreeRTOS/timers.c ****             pxNewTimer->ucStatus |= tmrSTATUS_IS_AUTORELOAD;
 380:FreeRTOS/timers.c ****         }
 381:FreeRTOS/timers.c **** 
 382:FreeRTOS/timers.c ****         traceTIMER_CREATE( pxNewTimer );
 383:FreeRTOS/timers.c ****     }
 384:FreeRTOS/timers.c **** /*-----------------------------------------------------------*/
 385:FreeRTOS/timers.c **** 
 386:FreeRTOS/timers.c ****     BaseType_t xTimerGenericCommand( TimerHandle_t xTimer,
 387:FreeRTOS/timers.c ****                                      const BaseType_t xCommandID,
 388:FreeRTOS/timers.c ****                                      const TickType_t xOptionalValue,
 389:FreeRTOS/timers.c ****                                      BaseType_t * const pxHigherPriorityTaskWoken,
 390:FreeRTOS/timers.c ****                                      const TickType_t xTicksToWait )
 391:FreeRTOS/timers.c ****     {
 392:FreeRTOS/timers.c ****         BaseType_t xReturn = pdFAIL;
 393:FreeRTOS/timers.c ****         DaemonTaskMessage_t xMessage;
 394:FreeRTOS/timers.c **** 
 395:FreeRTOS/timers.c ****         configASSERT( xTimer );
 396:FreeRTOS/timers.c **** 
 397:FreeRTOS/timers.c ****         /* Send a message to the timer service task to perform a particular action
 398:FreeRTOS/timers.c ****          * on a particular timer definition. */
 399:FreeRTOS/timers.c ****         if( xTimerQueue != NULL )
 400:FreeRTOS/timers.c ****         {
 401:FreeRTOS/timers.c ****             /* Send a command to the timer service task to start the xTimer timer. */
 402:FreeRTOS/timers.c ****             xMessage.xMessageID = xCommandID;
 403:FreeRTOS/timers.c ****             xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
 404:FreeRTOS/timers.c ****             xMessage.u.xTimerParameters.pxTimer = xTimer;
 405:FreeRTOS/timers.c **** 
 406:FreeRTOS/timers.c ****             if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
 407:FreeRTOS/timers.c ****             {
 408:FreeRTOS/timers.c ****                 if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
 409:FreeRTOS/timers.c ****                 {
 410:FreeRTOS/timers.c ****                     xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
 411:FreeRTOS/timers.c ****                 }
 412:FreeRTOS/timers.c ****                 else
 413:FreeRTOS/timers.c ****                 {
 414:FreeRTOS/timers.c ****                     xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
 415:FreeRTOS/timers.c ****                 }
 416:FreeRTOS/timers.c ****             }
 417:FreeRTOS/timers.c ****             else
 418:FreeRTOS/timers.c ****             {
 419:FreeRTOS/timers.c ****                 xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoke
 420:FreeRTOS/timers.c ****             }
 421:FreeRTOS/timers.c **** 
 422:FreeRTOS/timers.c ****             traceTIMER_COMMAND_SEND( xTimer, xCommandID, xOptionalValue, xReturn );
 423:FreeRTOS/timers.c ****         }
 424:FreeRTOS/timers.c ****         else
 425:FreeRTOS/timers.c ****         {
 426:FreeRTOS/timers.c ****             mtCOVERAGE_TEST_MARKER();
 427:FreeRTOS/timers.c ****         }
 428:FreeRTOS/timers.c **** 
 429:FreeRTOS/timers.c ****         return xReturn;
 430:FreeRTOS/timers.c ****     }
 431:FreeRTOS/timers.c **** /*-----------------------------------------------------------*/
 432:FreeRTOS/timers.c **** 
 433:FreeRTOS/timers.c ****     TaskHandle_t xTimerGetTimerDaemonTaskHandle( void )
ARM GAS  /tmp/cczeOkKz.s 			page 9


 434:FreeRTOS/timers.c ****     {
 435:FreeRTOS/timers.c ****         /* If xTimerGetTimerDaemonTaskHandle() is called before the scheduler has been
 436:FreeRTOS/timers.c ****          * started, then xTimerTaskHandle will be NULL. */
 437:FreeRTOS/timers.c ****         configASSERT( ( xTimerTaskHandle != NULL ) );
 438:FreeRTOS/timers.c ****         return xTimerTaskHandle;
 439:FreeRTOS/timers.c ****     }
 440:FreeRTOS/timers.c **** /*-----------------------------------------------------------*/
 441:FreeRTOS/timers.c **** 
 442:FreeRTOS/timers.c ****     TickType_t xTimerGetPeriod( TimerHandle_t xTimer )
 443:FreeRTOS/timers.c ****     {
 444:FreeRTOS/timers.c ****         Timer_t * pxTimer = xTimer;
 445:FreeRTOS/timers.c **** 
 446:FreeRTOS/timers.c ****         configASSERT( xTimer );
 447:FreeRTOS/timers.c ****         return pxTimer->xTimerPeriodInTicks;
 448:FreeRTOS/timers.c ****     }
 449:FreeRTOS/timers.c **** /*-----------------------------------------------------------*/
 450:FreeRTOS/timers.c **** 
 451:FreeRTOS/timers.c ****     void vTimerSetReloadMode( TimerHandle_t xTimer,
 452:FreeRTOS/timers.c ****                               const UBaseType_t uxAutoReload )
 453:FreeRTOS/timers.c ****     {
 454:FreeRTOS/timers.c ****         Timer_t * pxTimer = xTimer;
 455:FreeRTOS/timers.c **** 
 456:FreeRTOS/timers.c ****         configASSERT( xTimer );
 457:FreeRTOS/timers.c ****         taskENTER_CRITICAL();
 458:FreeRTOS/timers.c ****         {
 459:FreeRTOS/timers.c ****             if( uxAutoReload != pdFALSE )
 460:FreeRTOS/timers.c ****             {
 461:FreeRTOS/timers.c ****                 pxTimer->ucStatus |= tmrSTATUS_IS_AUTORELOAD;
 462:FreeRTOS/timers.c ****             }
 463:FreeRTOS/timers.c ****             else
 464:FreeRTOS/timers.c ****             {
 465:FreeRTOS/timers.c ****                 pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_AUTORELOAD );
 466:FreeRTOS/timers.c ****             }
 467:FreeRTOS/timers.c ****         }
 468:FreeRTOS/timers.c ****         taskEXIT_CRITICAL();
 469:FreeRTOS/timers.c ****     }
 470:FreeRTOS/timers.c **** /*-----------------------------------------------------------*/
 471:FreeRTOS/timers.c **** 
 472:FreeRTOS/timers.c ****     UBaseType_t uxTimerGetReloadMode( TimerHandle_t xTimer )
 473:FreeRTOS/timers.c ****     {
 474:FreeRTOS/timers.c ****         Timer_t * pxTimer = xTimer;
 475:FreeRTOS/timers.c ****         UBaseType_t uxReturn;
 476:FreeRTOS/timers.c **** 
 477:FreeRTOS/timers.c ****         configASSERT( xTimer );
 478:FreeRTOS/timers.c ****         taskENTER_CRITICAL();
 479:FreeRTOS/timers.c ****         {
 480:FreeRTOS/timers.c ****             if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) == 0 )
 481:FreeRTOS/timers.c ****             {
 482:FreeRTOS/timers.c ****                 /* Not an auto-reload timer. */
 483:FreeRTOS/timers.c ****                 uxReturn = ( UBaseType_t ) pdFALSE;
 484:FreeRTOS/timers.c ****             }
 485:FreeRTOS/timers.c ****             else
 486:FreeRTOS/timers.c ****             {
 487:FreeRTOS/timers.c ****                 /* Is an auto-reload timer. */
 488:FreeRTOS/timers.c ****                 uxReturn = ( UBaseType_t ) pdTRUE;
 489:FreeRTOS/timers.c ****             }
 490:FreeRTOS/timers.c ****         }
ARM GAS  /tmp/cczeOkKz.s 			page 10


 491:FreeRTOS/timers.c ****         taskEXIT_CRITICAL();
 492:FreeRTOS/timers.c **** 
 493:FreeRTOS/timers.c ****         return uxReturn;
 494:FreeRTOS/timers.c ****     }
 495:FreeRTOS/timers.c **** /*-----------------------------------------------------------*/
 496:FreeRTOS/timers.c **** 
 497:FreeRTOS/timers.c ****     TickType_t xTimerGetExpiryTime( TimerHandle_t xTimer )
 498:FreeRTOS/timers.c ****     {
 499:FreeRTOS/timers.c ****         Timer_t * pxTimer = xTimer;
 500:FreeRTOS/timers.c ****         TickType_t xReturn;
 501:FreeRTOS/timers.c **** 
 502:FreeRTOS/timers.c ****         configASSERT( xTimer );
 503:FreeRTOS/timers.c ****         xReturn = listGET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ) );
 504:FreeRTOS/timers.c ****         return xReturn;
 505:FreeRTOS/timers.c ****     }
 506:FreeRTOS/timers.c **** /*-----------------------------------------------------------*/
 507:FreeRTOS/timers.c **** 
 508:FreeRTOS/timers.c ****     const char * pcTimerGetName( TimerHandle_t xTimer ) /*lint !e971 Unqualified char types are all
 509:FreeRTOS/timers.c ****     {
 510:FreeRTOS/timers.c ****         Timer_t * pxTimer = xTimer;
 511:FreeRTOS/timers.c **** 
 512:FreeRTOS/timers.c ****         configASSERT( xTimer );
 513:FreeRTOS/timers.c ****         return pxTimer->pcTimerName;
 514:FreeRTOS/timers.c ****     }
 515:FreeRTOS/timers.c **** /*-----------------------------------------------------------*/
 516:FreeRTOS/timers.c **** 
 517:FreeRTOS/timers.c ****     static void prvReloadTimer( Timer_t * const pxTimer,
 518:FreeRTOS/timers.c ****                                 TickType_t xExpiredTime,
 519:FreeRTOS/timers.c ****                                 const TickType_t xTimeNow )
 520:FreeRTOS/timers.c ****     {
 521:FreeRTOS/timers.c ****         /* Insert the timer into the appropriate list for the next expiry time.
 522:FreeRTOS/timers.c ****          * If the next expiry time has already passed, advance the expiry time,
 523:FreeRTOS/timers.c ****          * call the callback function, and try again. */
 524:FreeRTOS/timers.c ****         while( prvInsertTimerInActiveList( pxTimer, ( xExpiredTime + pxTimer->xTimerPeriodInTicks )
 525:FreeRTOS/timers.c ****         {
 526:FreeRTOS/timers.c ****             /* Advance the expiry time. */
 527:FreeRTOS/timers.c ****             xExpiredTime += pxTimer->xTimerPeriodInTicks;
 528:FreeRTOS/timers.c **** 
 529:FreeRTOS/timers.c ****             /* Call the timer callback. */
 530:FreeRTOS/timers.c ****             traceTIMER_EXPIRED( pxTimer );
 531:FreeRTOS/timers.c ****             pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 532:FreeRTOS/timers.c ****         }
 533:FreeRTOS/timers.c ****     }
 534:FreeRTOS/timers.c **** /*-----------------------------------------------------------*/
 535:FreeRTOS/timers.c **** 
 536:FreeRTOS/timers.c ****     static void prvProcessExpiredTimer( const TickType_t xNextExpireTime,
 537:FreeRTOS/timers.c ****                                         const TickType_t xTimeNow )
 538:FreeRTOS/timers.c ****     {
 539:FreeRTOS/timers.c ****         Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); 
 540:FreeRTOS/timers.c **** 
 541:FreeRTOS/timers.c ****         /* Remove the timer from the list of active timers.  A check has already
 542:FreeRTOS/timers.c ****          * been performed to ensure the list is not empty. */
 543:FreeRTOS/timers.c **** 
 544:FreeRTOS/timers.c ****         ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 545:FreeRTOS/timers.c **** 
 546:FreeRTOS/timers.c ****         /* If the timer is an auto-reload timer then calculate the next
 547:FreeRTOS/timers.c ****          * expiry time and re-insert the timer in the list of active timers. */
ARM GAS  /tmp/cczeOkKz.s 			page 11


 548:FreeRTOS/timers.c ****         if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
 549:FreeRTOS/timers.c ****         {
 550:FreeRTOS/timers.c ****             prvReloadTimer( pxTimer, xNextExpireTime, xTimeNow );
 551:FreeRTOS/timers.c ****         }
 552:FreeRTOS/timers.c ****         else
 553:FreeRTOS/timers.c ****         {
 554:FreeRTOS/timers.c ****             pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
 555:FreeRTOS/timers.c ****         }
 556:FreeRTOS/timers.c **** 
 557:FreeRTOS/timers.c ****         /* Call the timer callback. */
 558:FreeRTOS/timers.c ****         traceTIMER_EXPIRED( pxTimer );
 559:FreeRTOS/timers.c ****         pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 560:FreeRTOS/timers.c ****     }
 561:FreeRTOS/timers.c **** /*-----------------------------------------------------------*/
 562:FreeRTOS/timers.c **** 
 563:FreeRTOS/timers.c ****     static portTASK_FUNCTION( prvTimerTask, pvParameters )
 564:FreeRTOS/timers.c ****     {
 565:FreeRTOS/timers.c ****         TickType_t xNextExpireTime;
 566:FreeRTOS/timers.c ****         BaseType_t xListWasEmpty;
 567:FreeRTOS/timers.c **** 
 568:FreeRTOS/timers.c ****         /* Just to avoid compiler warnings. */
 569:FreeRTOS/timers.c ****         ( void ) pvParameters;
 570:FreeRTOS/timers.c **** 
 571:FreeRTOS/timers.c ****         #if ( configUSE_DAEMON_TASK_STARTUP_HOOK == 1 )
 572:FreeRTOS/timers.c ****             {
 573:FreeRTOS/timers.c ****                 extern void vApplicationDaemonTaskStartupHook( void );
 574:FreeRTOS/timers.c **** 
 575:FreeRTOS/timers.c ****                 /* Allow the application writer to execute some code in the context of
 576:FreeRTOS/timers.c ****                  * this task at the point the task starts executing.  This is useful if the
 577:FreeRTOS/timers.c ****                  * application includes initialisation code that would benefit from
 578:FreeRTOS/timers.c ****                  * executing after the scheduler has been started. */
 579:FreeRTOS/timers.c ****                 vApplicationDaemonTaskStartupHook();
 580:FreeRTOS/timers.c ****             }
 581:FreeRTOS/timers.c ****         #endif /* configUSE_DAEMON_TASK_STARTUP_HOOK */
 582:FreeRTOS/timers.c **** 
 583:FreeRTOS/timers.c ****         for( ; ; )
 584:FreeRTOS/timers.c ****         {
 585:FreeRTOS/timers.c ****             /* Query the timers list to see if it contains any timers, and if so,
 586:FreeRTOS/timers.c ****              * obtain the time at which the next timer will expire. */
 587:FreeRTOS/timers.c ****             xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
 588:FreeRTOS/timers.c **** 
 589:FreeRTOS/timers.c ****             /* If a timer has expired, process it.  Otherwise, block this task
 590:FreeRTOS/timers.c ****              * until either a timer does expire, or a command is received. */
 591:FreeRTOS/timers.c ****             prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
 592:FreeRTOS/timers.c **** 
 593:FreeRTOS/timers.c ****             /* Empty the command queue. */
 594:FreeRTOS/timers.c ****             prvProcessReceivedCommands();
 595:FreeRTOS/timers.c ****         }
 596:FreeRTOS/timers.c ****     }
 597:FreeRTOS/timers.c **** /*-----------------------------------------------------------*/
 598:FreeRTOS/timers.c **** 
 599:FreeRTOS/timers.c ****     static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime,
 600:FreeRTOS/timers.c ****                                             BaseType_t xListWasEmpty )
 601:FreeRTOS/timers.c ****     {
 602:FreeRTOS/timers.c ****         TickType_t xTimeNow;
 603:FreeRTOS/timers.c ****         BaseType_t xTimerListsWereSwitched;
 604:FreeRTOS/timers.c **** 
ARM GAS  /tmp/cczeOkKz.s 			page 12


 605:FreeRTOS/timers.c ****         vTaskSuspendAll();
 606:FreeRTOS/timers.c ****         {
 607:FreeRTOS/timers.c ****             /* Obtain the time now to make an assessment as to whether the timer
 608:FreeRTOS/timers.c ****              * has expired or not.  If obtaining the time causes the lists to switch
 609:FreeRTOS/timers.c ****              * then don't process this timer as any timers that remained in the list
 610:FreeRTOS/timers.c ****              * when the lists were switched will have been processed within the
 611:FreeRTOS/timers.c ****              * prvSampleTimeNow() function. */
 612:FreeRTOS/timers.c ****             xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
 613:FreeRTOS/timers.c **** 
 614:FreeRTOS/timers.c ****             if( xTimerListsWereSwitched == pdFALSE )
 615:FreeRTOS/timers.c ****             {
 616:FreeRTOS/timers.c ****                 /* The tick count has not overflowed, has the timer expired? */
 617:FreeRTOS/timers.c ****                 if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
 618:FreeRTOS/timers.c ****                 {
 619:FreeRTOS/timers.c ****                     ( void ) xTaskResumeAll();
 620:FreeRTOS/timers.c ****                     prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
 621:FreeRTOS/timers.c ****                 }
 622:FreeRTOS/timers.c ****                 else
 623:FreeRTOS/timers.c ****                 {
 624:FreeRTOS/timers.c ****                     /* The tick count has not overflowed, and the next expire
 625:FreeRTOS/timers.c ****                      * time has not been reached yet.  This task should therefore
 626:FreeRTOS/timers.c ****                      * block to wait for the next expire time or a command to be
 627:FreeRTOS/timers.c ****                      * received - whichever comes first.  The following line cannot
 628:FreeRTOS/timers.c ****                      * be reached unless xNextExpireTime > xTimeNow, except in the
 629:FreeRTOS/timers.c ****                      * case when the current timer list is empty. */
 630:FreeRTOS/timers.c ****                     if( xListWasEmpty != pdFALSE )
 631:FreeRTOS/timers.c ****                     {
 632:FreeRTOS/timers.c ****                         /* The current timer list is empty - is the overflow list
 633:FreeRTOS/timers.c ****                          * also empty? */
 634:FreeRTOS/timers.c ****                         xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
 635:FreeRTOS/timers.c ****                     }
 636:FreeRTOS/timers.c **** 
 637:FreeRTOS/timers.c ****                     vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xL
 638:FreeRTOS/timers.c **** 
 639:FreeRTOS/timers.c ****                     if( xTaskResumeAll() == pdFALSE )
 640:FreeRTOS/timers.c ****                     {
 641:FreeRTOS/timers.c ****                         /* Yield to wait for either a command to arrive, or the
 642:FreeRTOS/timers.c ****                          * block time to expire.  If a command arrived between the
 643:FreeRTOS/timers.c ****                          * critical section being exited and this yield then the yield
 644:FreeRTOS/timers.c ****                          * will not cause the task to block. */
 645:FreeRTOS/timers.c ****                         portYIELD_WITHIN_API();
 646:FreeRTOS/timers.c ****                     }
 647:FreeRTOS/timers.c ****                     else
 648:FreeRTOS/timers.c ****                     {
 649:FreeRTOS/timers.c ****                         mtCOVERAGE_TEST_MARKER();
 650:FreeRTOS/timers.c ****                     }
 651:FreeRTOS/timers.c ****                 }
 652:FreeRTOS/timers.c ****             }
 653:FreeRTOS/timers.c ****             else
 654:FreeRTOS/timers.c ****             {
 655:FreeRTOS/timers.c ****                 ( void ) xTaskResumeAll();
 656:FreeRTOS/timers.c ****             }
 657:FreeRTOS/timers.c ****         }
 658:FreeRTOS/timers.c ****     }
 659:FreeRTOS/timers.c **** /*-----------------------------------------------------------*/
 660:FreeRTOS/timers.c **** 
 661:FreeRTOS/timers.c ****     static TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty )
ARM GAS  /tmp/cczeOkKz.s 			page 13


 662:FreeRTOS/timers.c ****     {
  25              		.loc 1 662 0
  26              		.cfi_startproc
  27              		@ args = 0, pretend = 0, frame = 0
  28              		@ frame_needed = 0, uses_anonymous_args = 0
  29              		@ link register save eliminated.
  30              	.LVL0:
 663:FreeRTOS/timers.c ****         TickType_t xNextExpireTime;
 664:FreeRTOS/timers.c **** 
 665:FreeRTOS/timers.c ****         /* Timers are listed in expiry time order, with the head of the list
 666:FreeRTOS/timers.c ****          * referencing the task that will expire first.  Obtain the time at which
 667:FreeRTOS/timers.c ****          * the timer with the nearest expiry time will expire.  If there are no
 668:FreeRTOS/timers.c ****          * active timers then just set the next expire time to 0.  That will cause
 669:FreeRTOS/timers.c ****          * this task to unblock when the tick count overflows, at which point the
 670:FreeRTOS/timers.c ****          * timer lists will be switched and the next expiry time can be
 671:FreeRTOS/timers.c ****          * re-assessed.  */
 672:FreeRTOS/timers.c ****         *pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
  31              		.loc 1 672 0
  32 0000 064B     		ldr	r3, .L6
  33 0002 1A68     		ldr	r2, [r3]
  34 0004 1368     		ldr	r3, [r2]
  35 0006 2BB9     		cbnz	r3, .L4
  36 0008 0123     		movs	r3, #1
  37              	.L2:
  38              		.loc 1 672 0 is_stmt 0 discriminator 4
  39 000a 0360     		str	r3, [r0]
 673:FreeRTOS/timers.c **** 
 674:FreeRTOS/timers.c ****         if( *pxListWasEmpty == pdFALSE )
  40              		.loc 1 674 0 is_stmt 1 discriminator 4
  41 000c 23B9     		cbnz	r3, .L5
 675:FreeRTOS/timers.c ****         {
 676:FreeRTOS/timers.c ****             xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
  42              		.loc 1 676 0
  43 000e D368     		ldr	r3, [r2, #12]
  44 0010 1868     		ldr	r0, [r3]
  45              	.LVL1:
  46 0012 7047     		bx	lr
  47              	.LVL2:
  48              	.L4:
 672:FreeRTOS/timers.c **** 
  49              		.loc 1 672 0
  50 0014 0023     		movs	r3, #0
  51 0016 F8E7     		b	.L2
  52              	.L5:
 677:FreeRTOS/timers.c ****         }
 678:FreeRTOS/timers.c ****         else
 679:FreeRTOS/timers.c ****         {
 680:FreeRTOS/timers.c ****             /* Ensure the task unblocks when the tick count rolls over. */
 681:FreeRTOS/timers.c ****             xNextExpireTime = ( TickType_t ) 0U;
  53              		.loc 1 681 0
  54 0018 0020     		movs	r0, #0
  55              	.LVL3:
 682:FreeRTOS/timers.c ****         }
 683:FreeRTOS/timers.c **** 
 684:FreeRTOS/timers.c ****         return xNextExpireTime;
 685:FreeRTOS/timers.c ****     }
  56              		.loc 1 685 0
ARM GAS  /tmp/cczeOkKz.s 			page 14


  57 001a 7047     		bx	lr
  58              	.L7:
  59              		.align	2
  60              	.L6:
  61 001c 00000000 		.word	.LANCHOR0
  62              		.cfi_endproc
  63              	.LFE19:
  65              		.section	.text.prvInsertTimerInActiveList,"ax",%progbits
  66              		.align	1
  67              		.syntax unified
  68              		.thumb
  69              		.thumb_func
  70              		.fpu softvfp
  72              	prvInsertTimerInActiveList:
  73              	.LFB21:
 686:FreeRTOS/timers.c **** /*-----------------------------------------------------------*/
 687:FreeRTOS/timers.c **** 
 688:FreeRTOS/timers.c ****     static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
 689:FreeRTOS/timers.c ****     {
 690:FreeRTOS/timers.c ****         TickType_t xTimeNow;
 691:FreeRTOS/timers.c ****         PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is o
 692:FreeRTOS/timers.c **** 
 693:FreeRTOS/timers.c ****         xTimeNow = xTaskGetTickCount();
 694:FreeRTOS/timers.c **** 
 695:FreeRTOS/timers.c ****         if( xTimeNow < xLastTime )
 696:FreeRTOS/timers.c ****         {
 697:FreeRTOS/timers.c ****             prvSwitchTimerLists();
 698:FreeRTOS/timers.c ****             *pxTimerListsWereSwitched = pdTRUE;
 699:FreeRTOS/timers.c ****         }
 700:FreeRTOS/timers.c ****         else
 701:FreeRTOS/timers.c ****         {
 702:FreeRTOS/timers.c ****             *pxTimerListsWereSwitched = pdFALSE;
 703:FreeRTOS/timers.c ****         }
 704:FreeRTOS/timers.c **** 
 705:FreeRTOS/timers.c ****         xLastTime = xTimeNow;
 706:FreeRTOS/timers.c **** 
 707:FreeRTOS/timers.c ****         return xTimeNow;
 708:FreeRTOS/timers.c ****     }
 709:FreeRTOS/timers.c **** /*-----------------------------------------------------------*/
 710:FreeRTOS/timers.c **** 
 711:FreeRTOS/timers.c ****     static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer,
 712:FreeRTOS/timers.c ****                                                   const TickType_t xNextExpiryTime,
 713:FreeRTOS/timers.c ****                                                   const TickType_t xTimeNow,
 714:FreeRTOS/timers.c ****                                                   const TickType_t xCommandTime )
 715:FreeRTOS/timers.c ****     {
  74              		.loc 1 715 0
  75              		.cfi_startproc
  76              		@ args = 0, pretend = 0, frame = 0
  77              		@ frame_needed = 0, uses_anonymous_args = 0
  78              	.LVL4:
  79 0000 08B5     		push	{r3, lr}
  80              	.LCFI0:
  81              		.cfi_def_cfa_offset 8
  82              		.cfi_offset 3, -8
  83              		.cfi_offset 14, -4
  84              	.LVL5:
 716:FreeRTOS/timers.c ****         BaseType_t xProcessTimerNow = pdFALSE;
ARM GAS  /tmp/cczeOkKz.s 			page 15


 717:FreeRTOS/timers.c **** 
 718:FreeRTOS/timers.c ****         listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
  85              		.loc 1 718 0
  86 0002 4160     		str	r1, [r0, #4]
 719:FreeRTOS/timers.c ****         listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
  87              		.loc 1 719 0
  88 0004 0061     		str	r0, [r0, #16]
 720:FreeRTOS/timers.c **** 
 721:FreeRTOS/timers.c ****         if( xNextExpiryTime <= xTimeNow )
  89              		.loc 1 721 0
  90 0006 9142     		cmp	r1, r2
  91 0008 0CD8     		bhi	.L9
 722:FreeRTOS/timers.c ****         {
 723:FreeRTOS/timers.c ****             /* Has the expiry time elapsed between the command to start/reset a
 724:FreeRTOS/timers.c ****              * timer was issued, and the time the command was processed? */
 725:FreeRTOS/timers.c ****             if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*
  92              		.loc 1 725 0
  93 000a D21A     		subs	r2, r2, r3
  94              	.LVL6:
  95 000c 8369     		ldr	r3, [r0, #24]
  96              	.LVL7:
  97 000e 9A42     		cmp	r2, r3
  98 0010 01D3     		bcc	.L15
 726:FreeRTOS/timers.c ****             {
 727:FreeRTOS/timers.c ****                 /* The time between a command being issued and the command being
 728:FreeRTOS/timers.c ****                  * processed actually exceeds the timers period.  */
 729:FreeRTOS/timers.c ****                 xProcessTimerNow = pdTRUE;
  99              		.loc 1 729 0
 100 0012 0120     		movs	r0, #1
 101              	.LVL8:
 102 0014 10E0     		b	.L8
 103              	.LVL9:
 104              	.L15:
 730:FreeRTOS/timers.c ****             }
 731:FreeRTOS/timers.c ****             else
 732:FreeRTOS/timers.c ****             {
 733:FreeRTOS/timers.c ****                 vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
 105              		.loc 1 733 0
 106 0016 011D     		adds	r1, r0, #4
 107              	.LVL10:
 108 0018 094B     		ldr	r3, .L16
 109 001a 1868     		ldr	r0, [r3]
 110              	.LVL11:
 111 001c FFF7FEFF 		bl	vListInsert
 112              	.LVL12:
 716:FreeRTOS/timers.c **** 
 113              		.loc 1 716 0
 114 0020 0020     		movs	r0, #0
 115 0022 09E0     		b	.L8
 116              	.LVL13:
 117              	.L9:
 734:FreeRTOS/timers.c ****             }
 735:FreeRTOS/timers.c ****         }
 736:FreeRTOS/timers.c ****         else
 737:FreeRTOS/timers.c ****         {
 738:FreeRTOS/timers.c ****             if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
 118              		.loc 1 738 0
ARM GAS  /tmp/cczeOkKz.s 			page 16


 119 0024 9A42     		cmp	r2, r3
 120 0026 01D2     		bcs	.L11
 121              		.loc 1 738 0 is_stmt 0 discriminator 1
 122 0028 9942     		cmp	r1, r3
 123 002a 06D2     		bcs	.L13
 124              	.L11:
 739:FreeRTOS/timers.c ****             {
 740:FreeRTOS/timers.c ****                 /* If, since the command was issued, the tick count has overflowed
 741:FreeRTOS/timers.c ****                  * but the expiry time has not, then the timer must have already passed
 742:FreeRTOS/timers.c ****                  * its expiry time and should be processed immediately. */
 743:FreeRTOS/timers.c ****                 xProcessTimerNow = pdTRUE;
 744:FreeRTOS/timers.c ****             }
 745:FreeRTOS/timers.c ****             else
 746:FreeRTOS/timers.c ****             {
 747:FreeRTOS/timers.c ****                 vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 125              		.loc 1 747 0 is_stmt 1
 126 002c 011D     		adds	r1, r0, #4
 127              	.LVL14:
 128 002e 054B     		ldr	r3, .L16+4
 129              	.LVL15:
 130 0030 1868     		ldr	r0, [r3]
 131              	.LVL16:
 132 0032 FFF7FEFF 		bl	vListInsert
 133              	.LVL17:
 716:FreeRTOS/timers.c **** 
 134              		.loc 1 716 0
 135 0036 0020     		movs	r0, #0
 136              	.LVL18:
 137              	.L8:
 748:FreeRTOS/timers.c ****             }
 749:FreeRTOS/timers.c ****         }
 750:FreeRTOS/timers.c **** 
 751:FreeRTOS/timers.c ****         return xProcessTimerNow;
 752:FreeRTOS/timers.c ****     }
 138              		.loc 1 752 0
 139 0038 08BD     		pop	{r3, pc}
 140              	.LVL19:
 141              	.L13:
 743:FreeRTOS/timers.c ****             }
 142              		.loc 1 743 0
 143 003a 0120     		movs	r0, #1
 144              	.LVL20:
 751:FreeRTOS/timers.c ****     }
 145              		.loc 1 751 0
 146 003c FCE7     		b	.L8
 147              	.L17:
 148 003e 00BF     		.align	2
 149              	.L16:
 150 0040 00000000 		.word	.LANCHOR1
 151 0044 00000000 		.word	.LANCHOR0
 152              		.cfi_endproc
 153              	.LFE21:
 155              		.section	.text.prvReloadTimer,"ax",%progbits
 156              		.align	1
 157              		.syntax unified
 158              		.thumb
 159              		.thumb_func
ARM GAS  /tmp/cczeOkKz.s 			page 17


 160              		.fpu softvfp
 162              	prvReloadTimer:
 163              	.LFB15:
 520:FreeRTOS/timers.c ****         /* Insert the timer into the appropriate list for the next expiry time.
 164              		.loc 1 520 0
 165              		.cfi_startproc
 166              		@ args = 0, pretend = 0, frame = 0
 167              		@ frame_needed = 0, uses_anonymous_args = 0
 168              	.LVL21:
 169 0000 70B5     		push	{r4, r5, r6, lr}
 170              	.LCFI1:
 171              		.cfi_def_cfa_offset 16
 172              		.cfi_offset 4, -16
 173              		.cfi_offset 5, -12
 174              		.cfi_offset 6, -8
 175              		.cfi_offset 14, -4
 176 0002 0446     		mov	r4, r0
 177 0004 0D46     		mov	r5, r1
 178 0006 1646     		mov	r6, r2
 524:FreeRTOS/timers.c ****         {
 179              		.loc 1 524 0
 180 0008 04E0     		b	.L19
 181              	.LVL22:
 182              	.L20:
 527:FreeRTOS/timers.c **** 
 183              		.loc 1 527 0
 184 000a A369     		ldr	r3, [r4, #24]
 185 000c 1D44     		add	r5, r5, r3
 186              	.LVL23:
 531:FreeRTOS/timers.c ****         }
 187              		.loc 1 531 0
 188 000e 236A     		ldr	r3, [r4, #32]
 189 0010 2046     		mov	r0, r4
 190 0012 9847     		blx	r3
 191              	.LVL24:
 192              	.L19:
 524:FreeRTOS/timers.c ****         {
 193              		.loc 1 524 0
 194 0014 A169     		ldr	r1, [r4, #24]
 195 0016 2B46     		mov	r3, r5
 196 0018 3246     		mov	r2, r6
 197 001a 2944     		add	r1, r1, r5
 198 001c 2046     		mov	r0, r4
 199 001e FFF7FEFF 		bl	prvInsertTimerInActiveList
 200              	.LVL25:
 201 0022 0028     		cmp	r0, #0
 202 0024 F1D1     		bne	.L20
 533:FreeRTOS/timers.c **** /*-----------------------------------------------------------*/
 203              		.loc 1 533 0
 204 0026 70BD     		pop	{r4, r5, r6, pc}
 205              		.cfi_endproc
 206              	.LFE15:
 208              		.section	.text.prvProcessExpiredTimer,"ax",%progbits
 209              		.align	1
 210              		.syntax unified
 211              		.thumb
 212              		.thumb_func
ARM GAS  /tmp/cczeOkKz.s 			page 18


 213              		.fpu softvfp
 215              	prvProcessExpiredTimer:
 216              	.LFB16:
 538:FreeRTOS/timers.c ****         Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); 
 217              		.loc 1 538 0
 218              		.cfi_startproc
 219              		@ args = 0, pretend = 0, frame = 0
 220              		@ frame_needed = 0, uses_anonymous_args = 0
 221              	.LVL26:
 222 0000 70B5     		push	{r4, r5, r6, lr}
 223              	.LCFI2:
 224              		.cfi_def_cfa_offset 16
 225              		.cfi_offset 4, -16
 226              		.cfi_offset 5, -12
 227              		.cfi_offset 6, -8
 228              		.cfi_offset 14, -4
 229 0002 0546     		mov	r5, r0
 230 0004 0E46     		mov	r6, r1
 539:FreeRTOS/timers.c **** 
 231              		.loc 1 539 0
 232 0006 0D4B     		ldr	r3, .L27
 233 0008 1B68     		ldr	r3, [r3]
 234 000a DB68     		ldr	r3, [r3, #12]
 235 000c DC68     		ldr	r4, [r3, #12]
 236              	.LVL27:
 544:FreeRTOS/timers.c **** 
 237              		.loc 1 544 0
 238 000e 201D     		adds	r0, r4, #4
 239              	.LVL28:
 240 0010 FFF7FEFF 		bl	uxListRemove
 241              	.LVL29:
 548:FreeRTOS/timers.c ****         {
 242              		.loc 1 548 0
 243 0014 94F82430 		ldrb	r3, [r4, #36]	@ zero_extendqisi2
 244 0018 13F0040F 		tst	r3, #4
 245 001c 07D1     		bne	.L26
 554:FreeRTOS/timers.c ****         }
 246              		.loc 1 554 0
 247 001e 23F00103 		bic	r3, r3, #1
 248 0022 84F82430 		strb	r3, [r4, #36]
 249              	.L24:
 559:FreeRTOS/timers.c ****     }
 250              		.loc 1 559 0
 251 0026 236A     		ldr	r3, [r4, #32]
 252 0028 2046     		mov	r0, r4
 253 002a 9847     		blx	r3
 254              	.LVL30:
 560:FreeRTOS/timers.c **** /*-----------------------------------------------------------*/
 255              		.loc 1 560 0
 256 002c 70BD     		pop	{r4, r5, r6, pc}
 257              	.LVL31:
 258              	.L26:
 550:FreeRTOS/timers.c ****         }
 259              		.loc 1 550 0
 260 002e 3246     		mov	r2, r6
 261 0030 2946     		mov	r1, r5
 262 0032 2046     		mov	r0, r4
ARM GAS  /tmp/cczeOkKz.s 			page 19


 263 0034 FFF7FEFF 		bl	prvReloadTimer
 264              	.LVL32:
 265 0038 F5E7     		b	.L24
 266              	.L28:
 267 003a 00BF     		.align	2
 268              	.L27:
 269 003c 00000000 		.word	.LANCHOR0
 270              		.cfi_endproc
 271              	.LFE16:
 273              		.section	.text.prvSwitchTimerLists,"ax",%progbits
 274              		.align	1
 275              		.syntax unified
 276              		.thumb
 277              		.thumb_func
 278              		.fpu softvfp
 280              	prvSwitchTimerLists:
 281              	.LFB23:
 753:FreeRTOS/timers.c **** /*-----------------------------------------------------------*/
 754:FreeRTOS/timers.c **** 
 755:FreeRTOS/timers.c ****     static void prvProcessReceivedCommands( void )
 756:FreeRTOS/timers.c ****     {
 757:FreeRTOS/timers.c ****         DaemonTaskMessage_t xMessage;
 758:FreeRTOS/timers.c ****         Timer_t * pxTimer;
 759:FreeRTOS/timers.c ****         BaseType_t xTimerListsWereSwitched;
 760:FreeRTOS/timers.c ****         TickType_t xTimeNow;
 761:FreeRTOS/timers.c **** 
 762:FreeRTOS/timers.c ****         while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessa
 763:FreeRTOS/timers.c ****         {
 764:FreeRTOS/timers.c ****             #if ( INCLUDE_xTimerPendFunctionCall == 1 )
 765:FreeRTOS/timers.c ****                 {
 766:FreeRTOS/timers.c ****                     /* Negative commands are pended function calls rather than timer
 767:FreeRTOS/timers.c ****                      * commands. */
 768:FreeRTOS/timers.c ****                     if( xMessage.xMessageID < ( BaseType_t ) 0 )
 769:FreeRTOS/timers.c ****                     {
 770:FreeRTOS/timers.c ****                         const CallbackParameters_t * const pxCallback = &( xMessage.u.xCallbackPara
 771:FreeRTOS/timers.c **** 
 772:FreeRTOS/timers.c ****                         /* The timer uses the xCallbackParameters member to request a
 773:FreeRTOS/timers.c ****                          * callback be executed.  Check the callback is not NULL. */
 774:FreeRTOS/timers.c ****                         configASSERT( pxCallback );
 775:FreeRTOS/timers.c **** 
 776:FreeRTOS/timers.c ****                         /* Call the function. */
 777:FreeRTOS/timers.c ****                         pxCallback->pxCallbackFunction( pxCallback->pvParameter1, pxCallback->ulPar
 778:FreeRTOS/timers.c ****                     }
 779:FreeRTOS/timers.c ****                     else
 780:FreeRTOS/timers.c ****                     {
 781:FreeRTOS/timers.c ****                         mtCOVERAGE_TEST_MARKER();
 782:FreeRTOS/timers.c ****                     }
 783:FreeRTOS/timers.c ****                 }
 784:FreeRTOS/timers.c ****             #endif /* INCLUDE_xTimerPendFunctionCall */
 785:FreeRTOS/timers.c **** 
 786:FreeRTOS/timers.c ****             /* Commands that are positive are timer commands rather than pended
 787:FreeRTOS/timers.c ****              * function calls. */
 788:FreeRTOS/timers.c ****             if( xMessage.xMessageID >= ( BaseType_t ) 0 )
 789:FreeRTOS/timers.c ****             {
 790:FreeRTOS/timers.c ****                 /* The messages uses the xTimerParameters member to work on a
 791:FreeRTOS/timers.c ****                  * software timer. */
 792:FreeRTOS/timers.c ****                 pxTimer = xMessage.u.xTimerParameters.pxTimer;
ARM GAS  /tmp/cczeOkKz.s 			page 20


 793:FreeRTOS/timers.c **** 
 794:FreeRTOS/timers.c ****                 if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*li
 795:FreeRTOS/timers.c ****                 {
 796:FreeRTOS/timers.c ****                     /* The timer is in a list, remove it. */
 797:FreeRTOS/timers.c ****                     ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 798:FreeRTOS/timers.c ****                 }
 799:FreeRTOS/timers.c ****                 else
 800:FreeRTOS/timers.c ****                 {
 801:FreeRTOS/timers.c ****                     mtCOVERAGE_TEST_MARKER();
 802:FreeRTOS/timers.c ****                 }
 803:FreeRTOS/timers.c **** 
 804:FreeRTOS/timers.c ****                 traceTIMER_COMMAND_RECEIVED( pxTimer, xMessage.xMessageID, xMessage.u.xTimerParamet
 805:FreeRTOS/timers.c **** 
 806:FreeRTOS/timers.c ****                 /* In this case the xTimerListsWereSwitched parameter is not used, but
 807:FreeRTOS/timers.c ****                  *  it must be present in the function call.  prvSampleTimeNow() must be
 808:FreeRTOS/timers.c ****                  *  called after the message is received from xTimerQueue so there is no
 809:FreeRTOS/timers.c ****                  *  possibility of a higher priority task adding a message to the message
 810:FreeRTOS/timers.c ****                  *  queue with a time that is ahead of the timer daemon task (because it
 811:FreeRTOS/timers.c ****                  *  pre-empted the timer daemon task after the xTimeNow value was set). */
 812:FreeRTOS/timers.c ****                 xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
 813:FreeRTOS/timers.c **** 
 814:FreeRTOS/timers.c ****                 switch( xMessage.xMessageID )
 815:FreeRTOS/timers.c ****                 {
 816:FreeRTOS/timers.c ****                     case tmrCOMMAND_START:
 817:FreeRTOS/timers.c ****                     case tmrCOMMAND_START_FROM_ISR:
 818:FreeRTOS/timers.c ****                     case tmrCOMMAND_RESET:
 819:FreeRTOS/timers.c ****                     case tmrCOMMAND_RESET_FROM_ISR:
 820:FreeRTOS/timers.c ****                         /* Start or restart a timer. */
 821:FreeRTOS/timers.c ****                         pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
 822:FreeRTOS/timers.c **** 
 823:FreeRTOS/timers.c ****                         if( prvInsertTimerInActiveList( pxTimer, xMessage.u.xTimerParameters.xMessa
 824:FreeRTOS/timers.c ****                         {
 825:FreeRTOS/timers.c ****                             /* The timer expired before it was added to the active
 826:FreeRTOS/timers.c ****                              * timer list.  Process it now. */
 827:FreeRTOS/timers.c ****                             if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
 828:FreeRTOS/timers.c ****                             {
 829:FreeRTOS/timers.c ****                                 prvReloadTimer( pxTimer, xMessage.u.xTimerParameters.xMessageValue 
 830:FreeRTOS/timers.c ****                             }
 831:FreeRTOS/timers.c ****                             else
 832:FreeRTOS/timers.c ****                             {
 833:FreeRTOS/timers.c ****                                 pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
 834:FreeRTOS/timers.c ****                             }
 835:FreeRTOS/timers.c **** 
 836:FreeRTOS/timers.c ****                             /* Call the timer callback. */
 837:FreeRTOS/timers.c ****                             traceTIMER_EXPIRED( pxTimer );
 838:FreeRTOS/timers.c ****                             pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 839:FreeRTOS/timers.c ****                         }
 840:FreeRTOS/timers.c ****                         else
 841:FreeRTOS/timers.c ****                         {
 842:FreeRTOS/timers.c ****                             mtCOVERAGE_TEST_MARKER();
 843:FreeRTOS/timers.c ****                         }
 844:FreeRTOS/timers.c **** 
 845:FreeRTOS/timers.c ****                         break;
 846:FreeRTOS/timers.c **** 
 847:FreeRTOS/timers.c ****                     case tmrCOMMAND_STOP:
 848:FreeRTOS/timers.c ****                     case tmrCOMMAND_STOP_FROM_ISR:
 849:FreeRTOS/timers.c ****                         /* The timer has already been removed from the active list. */
ARM GAS  /tmp/cczeOkKz.s 			page 21


 850:FreeRTOS/timers.c ****                         pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
 851:FreeRTOS/timers.c ****                         break;
 852:FreeRTOS/timers.c **** 
 853:FreeRTOS/timers.c ****                     case tmrCOMMAND_CHANGE_PERIOD:
 854:FreeRTOS/timers.c ****                     case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR:
 855:FreeRTOS/timers.c ****                         pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
 856:FreeRTOS/timers.c ****                         pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
 857:FreeRTOS/timers.c ****                         configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
 858:FreeRTOS/timers.c **** 
 859:FreeRTOS/timers.c ****                         /* The new period does not really have a reference, and can
 860:FreeRTOS/timers.c ****                          * be longer or shorter than the old one.  The command time is
 861:FreeRTOS/timers.c ****                          * therefore set to the current time, and as the period cannot
 862:FreeRTOS/timers.c ****                          * be zero the next expiry time can only be in the future,
 863:FreeRTOS/timers.c ****                          * meaning (unlike for the xTimerStart() case above) there is
 864:FreeRTOS/timers.c ****                          * no fail case that needs to be handled here. */
 865:FreeRTOS/timers.c ****                         ( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerP
 866:FreeRTOS/timers.c ****                         break;
 867:FreeRTOS/timers.c **** 
 868:FreeRTOS/timers.c ****                     case tmrCOMMAND_DELETE:
 869:FreeRTOS/timers.c ****                         #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
 870:FreeRTOS/timers.c ****                             {
 871:FreeRTOS/timers.c ****                                 /* The timer has already been removed from the active list,
 872:FreeRTOS/timers.c ****                                  * just free up the memory if the memory was dynamically
 873:FreeRTOS/timers.c ****                                  * allocated. */
 874:FreeRTOS/timers.c ****                                 if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( 
 875:FreeRTOS/timers.c ****                                 {
 876:FreeRTOS/timers.c ****                                     vPortFree( pxTimer );
 877:FreeRTOS/timers.c ****                                 }
 878:FreeRTOS/timers.c ****                                 else
 879:FreeRTOS/timers.c ****                                 {
 880:FreeRTOS/timers.c ****                                     pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
 881:FreeRTOS/timers.c ****                                 }
 882:FreeRTOS/timers.c ****                             }
 883:FreeRTOS/timers.c ****                         #else /* if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) */
 884:FreeRTOS/timers.c ****                             {
 885:FreeRTOS/timers.c ****                                 /* If dynamic allocation is not enabled, the memory
 886:FreeRTOS/timers.c ****                                  * could not have been dynamically allocated. So there is
 887:FreeRTOS/timers.c ****                                  * no need to free the memory - just mark the timer as
 888:FreeRTOS/timers.c ****                                  * "not active". */
 889:FreeRTOS/timers.c ****                                 pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
 890:FreeRTOS/timers.c ****                             }
 891:FreeRTOS/timers.c ****                         #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
 892:FreeRTOS/timers.c ****                         break;
 893:FreeRTOS/timers.c **** 
 894:FreeRTOS/timers.c ****                     default:
 895:FreeRTOS/timers.c ****                         /* Don't expect to get here. */
 896:FreeRTOS/timers.c ****                         break;
 897:FreeRTOS/timers.c ****                 }
 898:FreeRTOS/timers.c ****             }
 899:FreeRTOS/timers.c ****         }
 900:FreeRTOS/timers.c ****     }
 901:FreeRTOS/timers.c **** /*-----------------------------------------------------------*/
 902:FreeRTOS/timers.c **** 
 903:FreeRTOS/timers.c ****     static void prvSwitchTimerLists( void )
 904:FreeRTOS/timers.c ****     {
 282              		.loc 1 904 0
 283              		.cfi_startproc
ARM GAS  /tmp/cczeOkKz.s 			page 22


 284              		@ args = 0, pretend = 0, frame = 0
 285              		@ frame_needed = 0, uses_anonymous_args = 0
 286 0000 08B5     		push	{r3, lr}
 287              	.LCFI3:
 288              		.cfi_def_cfa_offset 8
 289              		.cfi_offset 3, -8
 290              		.cfi_offset 14, -4
 905:FreeRTOS/timers.c ****         TickType_t xNextExpireTime;
 906:FreeRTOS/timers.c ****         List_t * pxTemp;
 907:FreeRTOS/timers.c **** 
 908:FreeRTOS/timers.c ****         /* The tick count has overflowed.  The timer lists must be switched.
 909:FreeRTOS/timers.c ****          * If there are any timers still referenced from the current timer list
 910:FreeRTOS/timers.c ****          * then they must have expired and should be processed before the lists
 911:FreeRTOS/timers.c ****          * are switched. */
 912:FreeRTOS/timers.c ****         while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 291              		.loc 1 912 0
 292 0002 05E0     		b	.L30
 293              	.L31:
 913:FreeRTOS/timers.c ****         {
 914:FreeRTOS/timers.c ****             xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 294              		.loc 1 914 0
 295 0004 DB68     		ldr	r3, [r3, #12]
 296              	.LVL33:
 915:FreeRTOS/timers.c **** 
 916:FreeRTOS/timers.c ****             /* Process the expired timer.  For auto-reload timers, be careful to
 917:FreeRTOS/timers.c ****              * process only expirations that occur on the current list.  Further
 918:FreeRTOS/timers.c ****              * expirations must wait until after the lists are switched. */
 919:FreeRTOS/timers.c ****             prvProcessExpiredTimer( xNextExpireTime, tmrMAX_TIME_BEFORE_OVERFLOW );
 297              		.loc 1 919 0
 298 0006 4FF0FF31 		mov	r1, #-1
 299 000a 1868     		ldr	r0, [r3]
 300 000c FFF7FEFF 		bl	prvProcessExpiredTimer
 301              	.LVL34:
 302              	.L30:
 912:FreeRTOS/timers.c ****         {
 303              		.loc 1 912 0
 304 0010 054B     		ldr	r3, .L33
 305 0012 1B68     		ldr	r3, [r3]
 306 0014 1A68     		ldr	r2, [r3]
 307 0016 002A     		cmp	r2, #0
 308 0018 F4D1     		bne	.L31
 309              	.LVL35:
 920:FreeRTOS/timers.c ****         }
 921:FreeRTOS/timers.c **** 
 922:FreeRTOS/timers.c ****         pxTemp = pxCurrentTimerList;
 923:FreeRTOS/timers.c ****         pxCurrentTimerList = pxOverflowTimerList;
 310              		.loc 1 923 0
 311 001a 044A     		ldr	r2, .L33+4
 312 001c 1068     		ldr	r0, [r2]
 313 001e 0249     		ldr	r1, .L33
 314 0020 0860     		str	r0, [r1]
 924:FreeRTOS/timers.c ****         pxOverflowTimerList = pxTemp;
 315              		.loc 1 924 0
 316 0022 1360     		str	r3, [r2]
 925:FreeRTOS/timers.c ****     }
 317              		.loc 1 925 0
 318 0024 08BD     		pop	{r3, pc}
ARM GAS  /tmp/cczeOkKz.s 			page 23


 319              	.LVL36:
 320              	.L34:
 321 0026 00BF     		.align	2
 322              	.L33:
 323 0028 00000000 		.word	.LANCHOR0
 324 002c 00000000 		.word	.LANCHOR1
 325              		.cfi_endproc
 326              	.LFE23:
 328              		.section	.text.prvSampleTimeNow,"ax",%progbits
 329              		.align	1
 330              		.syntax unified
 331              		.thumb
 332              		.thumb_func
 333              		.fpu softvfp
 335              	prvSampleTimeNow:
 336              	.LFB20:
 689:FreeRTOS/timers.c ****         TickType_t xTimeNow;
 337              		.loc 1 689 0
 338              		.cfi_startproc
 339              		@ args = 0, pretend = 0, frame = 0
 340              		@ frame_needed = 0, uses_anonymous_args = 0
 341              	.LVL37:
 342 0000 38B5     		push	{r3, r4, r5, lr}
 343              	.LCFI4:
 344              		.cfi_def_cfa_offset 16
 345              		.cfi_offset 3, -16
 346              		.cfi_offset 4, -12
 347              		.cfi_offset 5, -8
 348              		.cfi_offset 14, -4
 349 0002 0546     		mov	r5, r0
 693:FreeRTOS/timers.c **** 
 350              		.loc 1 693 0
 351 0004 FFF7FEFF 		bl	xTaskGetTickCount
 352              	.LVL38:
 353 0008 0446     		mov	r4, r0
 354              	.LVL39:
 695:FreeRTOS/timers.c ****         {
 355              		.loc 1 695 0
 356 000a 074B     		ldr	r3, .L40
 357 000c 1B68     		ldr	r3, [r3]
 358 000e 8342     		cmp	r3, r0
 359 0010 05D8     		bhi	.L39
 702:FreeRTOS/timers.c ****         }
 360              		.loc 1 702 0
 361 0012 0023     		movs	r3, #0
 362 0014 2B60     		str	r3, [r5]
 363              	.LVL40:
 364              	.L37:
 705:FreeRTOS/timers.c **** 
 365              		.loc 1 705 0
 366 0016 044B     		ldr	r3, .L40
 367 0018 1C60     		str	r4, [r3]
 708:FreeRTOS/timers.c **** /*-----------------------------------------------------------*/
 368              		.loc 1 708 0
 369 001a 2046     		mov	r0, r4
 370 001c 38BD     		pop	{r3, r4, r5, pc}
 371              	.LVL41:
ARM GAS  /tmp/cczeOkKz.s 			page 24


 372              	.L39:
 697:FreeRTOS/timers.c ****             *pxTimerListsWereSwitched = pdTRUE;
 373              		.loc 1 697 0
 374 001e FFF7FEFF 		bl	prvSwitchTimerLists
 375              	.LVL42:
 698:FreeRTOS/timers.c ****         }
 376              		.loc 1 698 0
 377 0022 0123     		movs	r3, #1
 378 0024 2B60     		str	r3, [r5]
 379 0026 F6E7     		b	.L37
 380              	.L41:
 381              		.align	2
 382              	.L40:
 383 0028 00000000 		.word	.LANCHOR2
 384              		.cfi_endproc
 385              	.LFE20:
 387              		.section	.text.prvProcessTimerOrBlockTask,"ax",%progbits
 388              		.align	1
 389              		.syntax unified
 390              		.thumb
 391              		.thumb_func
 392              		.fpu softvfp
 394              	prvProcessTimerOrBlockTask:
 395              	.LFB18:
 601:FreeRTOS/timers.c ****         TickType_t xTimeNow;
 396              		.loc 1 601 0
 397              		.cfi_startproc
 398              		@ args = 0, pretend = 0, frame = 8
 399              		@ frame_needed = 0, uses_anonymous_args = 0
 400              	.LVL43:
 401 0000 70B5     		push	{r4, r5, r6, lr}
 402              	.LCFI5:
 403              		.cfi_def_cfa_offset 16
 404              		.cfi_offset 4, -16
 405              		.cfi_offset 5, -12
 406              		.cfi_offset 6, -8
 407              		.cfi_offset 14, -4
 408 0002 82B0     		sub	sp, sp, #8
 409              	.LCFI6:
 410              		.cfi_def_cfa_offset 24
 411 0004 0646     		mov	r6, r0
 412 0006 0C46     		mov	r4, r1
 605:FreeRTOS/timers.c ****         {
 413              		.loc 1 605 0
 414 0008 FFF7FEFF 		bl	vTaskSuspendAll
 415              	.LVL44:
 612:FreeRTOS/timers.c **** 
 416              		.loc 1 612 0
 417 000c 01A8     		add	r0, sp, #4
 418 000e FFF7FEFF 		bl	prvSampleTimeNow
 419              	.LVL45:
 614:FreeRTOS/timers.c ****             {
 420              		.loc 1 614 0
 421 0012 019B     		ldr	r3, [sp, #4]
 422 0014 23BB     		cbnz	r3, .L43
 423 0016 0546     		mov	r5, r0
 617:FreeRTOS/timers.c ****                 {
ARM GAS  /tmp/cczeOkKz.s 			page 25


 424              		.loc 1 617 0
 425 0018 0CB9     		cbnz	r4, .L44
 617:FreeRTOS/timers.c ****                 {
 426              		.loc 1 617 0 is_stmt 0 discriminator 1
 427 001a B042     		cmp	r0, r6
 428 001c 17D2     		bcs	.L49
 429              	.L44:
 630:FreeRTOS/timers.c ****                     {
 430              		.loc 1 630 0 is_stmt 1
 431 001e 24B1     		cbz	r4, .L46
 634:FreeRTOS/timers.c ****                     }
 432              		.loc 1 634 0
 433 0020 114B     		ldr	r3, .L50
 434 0022 1B68     		ldr	r3, [r3]
 435 0024 1B68     		ldr	r3, [r3]
 436 0026 CBB9     		cbnz	r3, .L47
 437 0028 0124     		movs	r4, #1
 438              	.LVL46:
 439              	.L46:
 637:FreeRTOS/timers.c **** 
 440              		.loc 1 637 0
 441 002a 2246     		mov	r2, r4
 442 002c 711B     		subs	r1, r6, r5
 443 002e 0F4B     		ldr	r3, .L50+4
 444 0030 1868     		ldr	r0, [r3]
 445              	.LVL47:
 446 0032 FFF7FEFF 		bl	vQueueWaitForMessageRestricted
 447              	.LVL48:
 639:FreeRTOS/timers.c ****                     {
 448              		.loc 1 639 0
 449 0036 FFF7FEFF 		bl	xTaskResumeAll
 450              	.LVL49:
 451 003a 98B9     		cbnz	r0, .L42
 645:FreeRTOS/timers.c ****                     }
 452              		.loc 1 645 0
 453 003c 0C4B     		ldr	r3, .L50+8
 454 003e 4FF08052 		mov	r2, #268435456
 455 0042 1A60     		str	r2, [r3]
 456              		.syntax unified
 457              	@ 645 "FreeRTOS/timers.c" 1
 458 0044 BFF34F8F 		dsb
 459              	@ 0 "" 2
 460              	@ 645 "FreeRTOS/timers.c" 1
 461 0048 BFF36F8F 		isb
 462              	@ 0 "" 2
 463              		.thumb
 464              		.syntax unified
 465 004c 0AE0     		b	.L42
 466              	.LVL50:
 467              	.L49:
 619:FreeRTOS/timers.c ****                     prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
 468              		.loc 1 619 0
 469 004e FFF7FEFF 		bl	xTaskResumeAll
 470              	.LVL51:
 620:FreeRTOS/timers.c ****                 }
 471              		.loc 1 620 0
 472 0052 2946     		mov	r1, r5
ARM GAS  /tmp/cczeOkKz.s 			page 26


 473 0054 3046     		mov	r0, r6
 474 0056 FFF7FEFF 		bl	prvProcessExpiredTimer
 475              	.LVL52:
 476 005a 03E0     		b	.L42
 477              	.LVL53:
 478              	.L47:
 634:FreeRTOS/timers.c ****                     }
 479              		.loc 1 634 0
 480 005c 0024     		movs	r4, #0
 481              	.LVL54:
 482 005e E4E7     		b	.L46
 483              	.LVL55:
 484              	.L43:
 655:FreeRTOS/timers.c ****             }
 485              		.loc 1 655 0
 486 0060 FFF7FEFF 		bl	xTaskResumeAll
 487              	.LVL56:
 488              	.L42:
 658:FreeRTOS/timers.c **** /*-----------------------------------------------------------*/
 489              		.loc 1 658 0
 490 0064 02B0     		add	sp, sp, #8
 491              	.LCFI7:
 492              		.cfi_def_cfa_offset 16
 493              		@ sp needed
 494 0066 70BD     		pop	{r4, r5, r6, pc}
 495              	.LVL57:
 496              	.L51:
 497              		.align	2
 498              	.L50:
 499 0068 00000000 		.word	.LANCHOR1
 500 006c 00000000 		.word	.LANCHOR3
 501 0070 04ED00E0 		.word	-536810236
 502              		.cfi_endproc
 503              	.LFE18:
 505              		.section	.text.prvProcessReceivedCommands,"ax",%progbits
 506              		.align	1
 507              		.syntax unified
 508              		.thumb
 509              		.thumb_func
 510              		.fpu softvfp
 512              	prvProcessReceivedCommands:
 513              	.LFB22:
 756:FreeRTOS/timers.c ****         DaemonTaskMessage_t xMessage;
 514              		.loc 1 756 0
 515              		.cfi_startproc
 516              		@ args = 0, pretend = 0, frame = 16
 517              		@ frame_needed = 0, uses_anonymous_args = 0
 518 0000 30B5     		push	{r4, r5, lr}
 519              	.LCFI8:
 520              		.cfi_def_cfa_offset 12
 521              		.cfi_offset 4, -12
 522              		.cfi_offset 5, -8
 523              		.cfi_offset 14, -4
 524 0002 85B0     		sub	sp, sp, #20
 525              	.LCFI9:
 526              		.cfi_def_cfa_offset 32
 527              	.L54:
ARM GAS  /tmp/cczeOkKz.s 			page 27


 762:FreeRTOS/timers.c ****         {
 528              		.loc 1 762 0
 529 0004 0022     		movs	r2, #0
 530 0006 01A9     		add	r1, sp, #4
 531 0008 394B     		ldr	r3, .L74
 532 000a 1868     		ldr	r0, [r3]
 533 000c FFF7FEFF 		bl	xQueueReceive
 534              	.LVL58:
 535 0010 0028     		cmp	r0, #0
 536 0012 6AD0     		beq	.L70
 788:FreeRTOS/timers.c ****             {
 537              		.loc 1 788 0
 538 0014 019B     		ldr	r3, [sp, #4]
 539 0016 002B     		cmp	r3, #0
 540 0018 F4DB     		blt	.L54
 792:FreeRTOS/timers.c **** 
 541              		.loc 1 792 0
 542 001a 039C     		ldr	r4, [sp, #12]
 543              	.LVL59:
 794:FreeRTOS/timers.c ****                 {
 544              		.loc 1 794 0
 545 001c 6369     		ldr	r3, [r4, #20]
 546 001e 13B1     		cbz	r3, .L55
 797:FreeRTOS/timers.c ****                 }
 547              		.loc 1 797 0
 548 0020 201D     		adds	r0, r4, #4
 549 0022 FFF7FEFF 		bl	uxListRemove
 550              	.LVL60:
 551              	.L55:
 812:FreeRTOS/timers.c **** 
 552              		.loc 1 812 0
 553 0026 6846     		mov	r0, sp
 554 0028 FFF7FEFF 		bl	prvSampleTimeNow
 555              	.LVL61:
 556 002c 0546     		mov	r5, r0
 557              	.LVL62:
 814:FreeRTOS/timers.c ****                 {
 558              		.loc 1 814 0
 559 002e 019B     		ldr	r3, [sp, #4]
 560 0030 013B     		subs	r3, r3, #1
 561 0032 082B     		cmp	r3, #8
 562 0034 E6D8     		bhi	.L54
 563 0036 DFE803F0 		tbb	[pc, r3]
 564              	.L58:
 565 003a 05       		.byte	(.L57-.L58)/2
 566 003b 05       		.byte	(.L57-.L58)/2
 567 003c 2A       		.byte	(.L59-.L58)/2
 568 003d 31       		.byte	(.L60-.L58)/2
 569 003e 4A       		.byte	(.L61-.L58)/2
 570 003f 05       		.byte	(.L57-.L58)/2
 571 0040 05       		.byte	(.L57-.L58)/2
 572 0041 2A       		.byte	(.L59-.L58)/2
 573 0042 31       		.byte	(.L60-.L58)/2
 574 0043 00       		.p2align 1
 575              	.L57:
 821:FreeRTOS/timers.c **** 
 576              		.loc 1 821 0
ARM GAS  /tmp/cczeOkKz.s 			page 28


 577 0044 94F82430 		ldrb	r3, [r4, #36]	@ zero_extendqisi2
 578 0048 43F00103 		orr	r3, r3, #1
 579 004c 84F82430 		strb	r3, [r4, #36]
 823:FreeRTOS/timers.c ****                         {
 580              		.loc 1 823 0
 581 0050 0299     		ldr	r1, [sp, #8]
 582 0052 A069     		ldr	r0, [r4, #24]
 583              	.LVL63:
 584 0054 0B46     		mov	r3, r1
 585 0056 2A46     		mov	r2, r5
 586 0058 0144     		add	r1, r1, r0
 587 005a 2046     		mov	r0, r4
 588 005c FFF7FEFF 		bl	prvInsertTimerInActiveList
 589              	.LVL64:
 590 0060 0028     		cmp	r0, #0
 591 0062 CFD0     		beq	.L54
 827:FreeRTOS/timers.c ****                             {
 592              		.loc 1 827 0
 593 0064 94F82430 		ldrb	r3, [r4, #36]	@ zero_extendqisi2
 594 0068 13F0040F 		tst	r3, #4
 595 006c 07D1     		bne	.L71
 833:FreeRTOS/timers.c ****                             }
 596              		.loc 1 833 0
 597 006e 23F00103 		bic	r3, r3, #1
 598 0072 84F82430 		strb	r3, [r4, #36]
 599              	.L64:
 838:FreeRTOS/timers.c ****                         }
 600              		.loc 1 838 0
 601 0076 236A     		ldr	r3, [r4, #32]
 602 0078 2046     		mov	r0, r4
 603 007a 9847     		blx	r3
 604              	.LVL65:
 605 007c C2E7     		b	.L54
 606              	.L71:
 829:FreeRTOS/timers.c ****                             }
 607              		.loc 1 829 0
 608 007e A369     		ldr	r3, [r4, #24]
 609 0080 2A46     		mov	r2, r5
 610 0082 0299     		ldr	r1, [sp, #8]
 611 0084 1944     		add	r1, r1, r3
 612 0086 2046     		mov	r0, r4
 613 0088 FFF7FEFF 		bl	prvReloadTimer
 614              	.LVL66:
 615 008c F3E7     		b	.L64
 616              	.LVL67:
 617              	.L59:
 850:FreeRTOS/timers.c ****                         break;
 618              		.loc 1 850 0
 619 008e 94F82430 		ldrb	r3, [r4, #36]	@ zero_extendqisi2
 620 0092 23F00103 		bic	r3, r3, #1
 621 0096 84F82430 		strb	r3, [r4, #36]
 851:FreeRTOS/timers.c **** 
 622              		.loc 1 851 0
 623 009a B3E7     		b	.L54
 624              	.L60:
 855:FreeRTOS/timers.c ****                         pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
 625              		.loc 1 855 0
ARM GAS  /tmp/cczeOkKz.s 			page 29


 626 009c 94F82430 		ldrb	r3, [r4, #36]	@ zero_extendqisi2
 627 00a0 43F00103 		orr	r3, r3, #1
 628 00a4 84F82430 		strb	r3, [r4, #36]
 856:FreeRTOS/timers.c ****                         configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
 629              		.loc 1 856 0
 630 00a8 0299     		ldr	r1, [sp, #8]
 631 00aa A161     		str	r1, [r4, #24]
 857:FreeRTOS/timers.c **** 
 632              		.loc 1 857 0
 633 00ac 31B1     		cbz	r1, .L72
 865:FreeRTOS/timers.c ****                         break;
 634              		.loc 1 865 0
 635 00ae 0346     		mov	r3, r0
 636 00b0 0246     		mov	r2, r0
 637 00b2 0144     		add	r1, r1, r0
 638 00b4 2046     		mov	r0, r4
 639              	.LVL68:
 640 00b6 FFF7FEFF 		bl	prvInsertTimerInActiveList
 641              	.LVL69:
 866:FreeRTOS/timers.c **** 
 642              		.loc 1 866 0
 643 00ba A3E7     		b	.L54
 644              	.LVL70:
 645              	.L72:
 646              	.LBB28:
 647              	.LBB29:
 648              		.file 2 "FreeRTOS/ARM_CM3/portmacro.h"
   1:FreeRTOS/ARM_CM3/portmacro.h **** /*
   2:FreeRTOS/ARM_CM3/portmacro.h ****  * FreeRTOS Kernel V10.4.6
   3:FreeRTOS/ARM_CM3/portmacro.h ****  * Copyright (C) 2021 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
   4:FreeRTOS/ARM_CM3/portmacro.h ****  *
   5:FreeRTOS/ARM_CM3/portmacro.h ****  * SPDX-License-Identifier: MIT
   6:FreeRTOS/ARM_CM3/portmacro.h ****  *
   7:FreeRTOS/ARM_CM3/portmacro.h ****  * Permission is hereby granted, free of charge, to any person obtaining a copy of
   8:FreeRTOS/ARM_CM3/portmacro.h ****  * this software and associated documentation files (the "Software"), to deal in
   9:FreeRTOS/ARM_CM3/portmacro.h ****  * the Software without restriction, including without limitation the rights to
  10:FreeRTOS/ARM_CM3/portmacro.h ****  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
  11:FreeRTOS/ARM_CM3/portmacro.h ****  * the Software, and to permit persons to whom the Software is furnished to do so,
  12:FreeRTOS/ARM_CM3/portmacro.h ****  * subject to the following conditions:
  13:FreeRTOS/ARM_CM3/portmacro.h ****  *
  14:FreeRTOS/ARM_CM3/portmacro.h ****  * The above copyright notice and this permission notice shall be included in all
  15:FreeRTOS/ARM_CM3/portmacro.h ****  * copies or substantial portions of the Software.
  16:FreeRTOS/ARM_CM3/portmacro.h ****  *
  17:FreeRTOS/ARM_CM3/portmacro.h ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  18:FreeRTOS/ARM_CM3/portmacro.h ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  19:FreeRTOS/ARM_CM3/portmacro.h ****  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  20:FreeRTOS/ARM_CM3/portmacro.h ****  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  21:FreeRTOS/ARM_CM3/portmacro.h ****  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  22:FreeRTOS/ARM_CM3/portmacro.h ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  23:FreeRTOS/ARM_CM3/portmacro.h ****  *
  24:FreeRTOS/ARM_CM3/portmacro.h ****  * https://www.FreeRTOS.org
  25:FreeRTOS/ARM_CM3/portmacro.h ****  * https://github.com/FreeRTOS
  26:FreeRTOS/ARM_CM3/portmacro.h ****  *
  27:FreeRTOS/ARM_CM3/portmacro.h ****  */
  28:FreeRTOS/ARM_CM3/portmacro.h **** 
  29:FreeRTOS/ARM_CM3/portmacro.h **** 
  30:FreeRTOS/ARM_CM3/portmacro.h **** #ifndef PORTMACRO_H
ARM GAS  /tmp/cczeOkKz.s 			page 30


  31:FreeRTOS/ARM_CM3/portmacro.h ****     #define PORTMACRO_H
  32:FreeRTOS/ARM_CM3/portmacro.h **** 
  33:FreeRTOS/ARM_CM3/portmacro.h ****     #ifdef __cplusplus
  34:FreeRTOS/ARM_CM3/portmacro.h ****         extern "C" {
  35:FreeRTOS/ARM_CM3/portmacro.h ****     #endif
  36:FreeRTOS/ARM_CM3/portmacro.h **** 
  37:FreeRTOS/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------
  38:FreeRTOS/ARM_CM3/portmacro.h ****  * Port specific definitions.
  39:FreeRTOS/ARM_CM3/portmacro.h ****  *
  40:FreeRTOS/ARM_CM3/portmacro.h ****  * The settings in this file configure FreeRTOS correctly for the
  41:FreeRTOS/ARM_CM3/portmacro.h ****  * given hardware and compiler.
  42:FreeRTOS/ARM_CM3/portmacro.h ****  *
  43:FreeRTOS/ARM_CM3/portmacro.h ****  * These settings should not be altered.
  44:FreeRTOS/ARM_CM3/portmacro.h ****  *-----------------------------------------------------------
  45:FreeRTOS/ARM_CM3/portmacro.h ****  */
  46:FreeRTOS/ARM_CM3/portmacro.h **** 
  47:FreeRTOS/ARM_CM3/portmacro.h **** /* Type definitions. */
  48:FreeRTOS/ARM_CM3/portmacro.h ****     #define portCHAR          char
  49:FreeRTOS/ARM_CM3/portmacro.h ****     #define portFLOAT         float
  50:FreeRTOS/ARM_CM3/portmacro.h ****     #define portDOUBLE        double
  51:FreeRTOS/ARM_CM3/portmacro.h ****     #define portLONG          long
  52:FreeRTOS/ARM_CM3/portmacro.h ****     #define portSHORT         short
  53:FreeRTOS/ARM_CM3/portmacro.h ****     #define portSTACK_TYPE    uint32_t
  54:FreeRTOS/ARM_CM3/portmacro.h ****     #define portBASE_TYPE     long
  55:FreeRTOS/ARM_CM3/portmacro.h **** 
  56:FreeRTOS/ARM_CM3/portmacro.h ****     typedef portSTACK_TYPE   StackType_t;
  57:FreeRTOS/ARM_CM3/portmacro.h ****     typedef long             BaseType_t;
  58:FreeRTOS/ARM_CM3/portmacro.h ****     typedef unsigned long    UBaseType_t;
  59:FreeRTOS/ARM_CM3/portmacro.h **** 
  60:FreeRTOS/ARM_CM3/portmacro.h ****     #if ( configUSE_16_BIT_TICKS == 1 )
  61:FreeRTOS/ARM_CM3/portmacro.h ****         typedef uint16_t     TickType_t;
  62:FreeRTOS/ARM_CM3/portmacro.h ****         #define portMAX_DELAY              ( TickType_t ) 0xffff
  63:FreeRTOS/ARM_CM3/portmacro.h ****     #else
  64:FreeRTOS/ARM_CM3/portmacro.h ****         typedef uint32_t     TickType_t;
  65:FreeRTOS/ARM_CM3/portmacro.h ****         #define portMAX_DELAY              ( TickType_t ) 0xffffffffUL
  66:FreeRTOS/ARM_CM3/portmacro.h **** 
  67:FreeRTOS/ARM_CM3/portmacro.h **** /* 32-bit tick type on a 32-bit architecture, so reads of the tick count do
  68:FreeRTOS/ARM_CM3/portmacro.h ****  * not need to be guarded with a critical section. */
  69:FreeRTOS/ARM_CM3/portmacro.h ****         #define portTICK_TYPE_IS_ATOMIC    1
  70:FreeRTOS/ARM_CM3/portmacro.h ****     #endif
  71:FreeRTOS/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
  72:FreeRTOS/ARM_CM3/portmacro.h **** 
  73:FreeRTOS/ARM_CM3/portmacro.h **** /* Architecture specifics. */
  74:FreeRTOS/ARM_CM3/portmacro.h ****     #define portSTACK_GROWTH      ( -1 )
  75:FreeRTOS/ARM_CM3/portmacro.h ****     #define portTICK_PERIOD_MS    ( ( TickType_t ) 1000 / configTICK_RATE_HZ )
  76:FreeRTOS/ARM_CM3/portmacro.h ****     #define portBYTE_ALIGNMENT    8
  77:FreeRTOS/ARM_CM3/portmacro.h ****     #define portDONT_DISCARD      __attribute__( ( used ) )
  78:FreeRTOS/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
  79:FreeRTOS/ARM_CM3/portmacro.h **** 
  80:FreeRTOS/ARM_CM3/portmacro.h **** /* Scheduler utilities. */
  81:FreeRTOS/ARM_CM3/portmacro.h ****     #define portYIELD()                                 \
  82:FreeRTOS/ARM_CM3/portmacro.h ****     {                                                   \
  83:FreeRTOS/ARM_CM3/portmacro.h ****         /* Set a PendSV to request a context switch. */ \
  84:FreeRTOS/ARM_CM3/portmacro.h ****         portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT; \
  85:FreeRTOS/ARM_CM3/portmacro.h ****                                                         \
  86:FreeRTOS/ARM_CM3/portmacro.h ****         /* Barriers are normally not required but do ensure the code is completely \
  87:FreeRTOS/ARM_CM3/portmacro.h ****          * within the specified behaviour for the architecture. */ \
ARM GAS  /tmp/cczeOkKz.s 			page 31


  88:FreeRTOS/ARM_CM3/portmacro.h ****         __asm volatile ( "dsb" ::: "memory" );                     \
  89:FreeRTOS/ARM_CM3/portmacro.h ****         __asm volatile ( "isb" );                                  \
  90:FreeRTOS/ARM_CM3/portmacro.h ****     }
  91:FreeRTOS/ARM_CM3/portmacro.h **** 
  92:FreeRTOS/ARM_CM3/portmacro.h ****     #define portNVIC_INT_CTRL_REG     ( *( ( volatile uint32_t * ) 0xe000ed04 ) )
  93:FreeRTOS/ARM_CM3/portmacro.h ****     #define portNVIC_PENDSVSET_BIT    ( 1UL << 28UL )
  94:FreeRTOS/ARM_CM3/portmacro.h ****     #define portEND_SWITCHING_ISR( xSwitchRequired )    do { if( xSwitchRequired != pdFALSE ) portY
  95:FreeRTOS/ARM_CM3/portmacro.h ****     #define portYIELD_FROM_ISR( x )                     portEND_SWITCHING_ISR( x )
  96:FreeRTOS/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
  97:FreeRTOS/ARM_CM3/portmacro.h **** 
  98:FreeRTOS/ARM_CM3/portmacro.h **** /* Critical section management. */
  99:FreeRTOS/ARM_CM3/portmacro.h ****     extern void vPortEnterCritical( void );
 100:FreeRTOS/ARM_CM3/portmacro.h ****     extern void vPortExitCritical( void );
 101:FreeRTOS/ARM_CM3/portmacro.h ****     #define portSET_INTERRUPT_MASK_FROM_ISR()         ulPortRaiseBASEPRI()
 102:FreeRTOS/ARM_CM3/portmacro.h ****     #define portCLEAR_INTERRUPT_MASK_FROM_ISR( x )    vPortSetBASEPRI( x )
 103:FreeRTOS/ARM_CM3/portmacro.h ****     #define portDISABLE_INTERRUPTS()                  vPortRaiseBASEPRI()
 104:FreeRTOS/ARM_CM3/portmacro.h ****     #define portENABLE_INTERRUPTS()                   vPortSetBASEPRI( 0 )
 105:FreeRTOS/ARM_CM3/portmacro.h ****     #define portENTER_CRITICAL()                      vPortEnterCritical()
 106:FreeRTOS/ARM_CM3/portmacro.h ****     #define portEXIT_CRITICAL()                       vPortExitCritical()
 107:FreeRTOS/ARM_CM3/portmacro.h **** 
 108:FreeRTOS/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 109:FreeRTOS/ARM_CM3/portmacro.h **** 
 110:FreeRTOS/ARM_CM3/portmacro.h **** /* Task function macros as described on the FreeRTOS.org WEB site.  These are
 111:FreeRTOS/ARM_CM3/portmacro.h ****  * not necessary for to use this port.  They are defined so the common demo files
 112:FreeRTOS/ARM_CM3/portmacro.h ****  * (which build with all the ports) will build. */
 113:FreeRTOS/ARM_CM3/portmacro.h ****     #define portTASK_FUNCTION_PROTO( vFunction, pvParameters )    void vFunction( void * pvParamete
 114:FreeRTOS/ARM_CM3/portmacro.h ****     #define portTASK_FUNCTION( vFunction, pvParameters )          void vFunction( void * pvParamete
 115:FreeRTOS/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 116:FreeRTOS/ARM_CM3/portmacro.h **** 
 117:FreeRTOS/ARM_CM3/portmacro.h **** /* Tickless idle/low power functionality. */
 118:FreeRTOS/ARM_CM3/portmacro.h ****     #ifndef portSUPPRESS_TICKS_AND_SLEEP
 119:FreeRTOS/ARM_CM3/portmacro.h ****         extern void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime );
 120:FreeRTOS/ARM_CM3/portmacro.h ****         #define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime )    vPortSuppressTicksAndSleep( xE
 121:FreeRTOS/ARM_CM3/portmacro.h ****     #endif
 122:FreeRTOS/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 123:FreeRTOS/ARM_CM3/portmacro.h **** 
 124:FreeRTOS/ARM_CM3/portmacro.h **** /* Architecture specific optimisations. */
 125:FreeRTOS/ARM_CM3/portmacro.h ****     #ifndef configUSE_PORT_OPTIMISED_TASK_SELECTION
 126:FreeRTOS/ARM_CM3/portmacro.h ****         #define configUSE_PORT_OPTIMISED_TASK_SELECTION    1
 127:FreeRTOS/ARM_CM3/portmacro.h ****     #endif
 128:FreeRTOS/ARM_CM3/portmacro.h **** 
 129:FreeRTOS/ARM_CM3/portmacro.h ****     #if configUSE_PORT_OPTIMISED_TASK_SELECTION == 1
 130:FreeRTOS/ARM_CM3/portmacro.h **** 
 131:FreeRTOS/ARM_CM3/portmacro.h **** /* Generic helper function. */
 132:FreeRTOS/ARM_CM3/portmacro.h ****         __attribute__( ( always_inline ) ) static inline uint8_t ucPortCountLeadingZeros( uint32_t 
 133:FreeRTOS/ARM_CM3/portmacro.h ****         {
 134:FreeRTOS/ARM_CM3/portmacro.h ****             uint8_t ucReturn;
 135:FreeRTOS/ARM_CM3/portmacro.h **** 
 136:FreeRTOS/ARM_CM3/portmacro.h ****             __asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) : "memory" );
 137:FreeRTOS/ARM_CM3/portmacro.h **** 
 138:FreeRTOS/ARM_CM3/portmacro.h ****             return ucReturn;
 139:FreeRTOS/ARM_CM3/portmacro.h ****         }
 140:FreeRTOS/ARM_CM3/portmacro.h **** 
 141:FreeRTOS/ARM_CM3/portmacro.h **** /* Check the configuration. */
 142:FreeRTOS/ARM_CM3/portmacro.h ****         #if ( configMAX_PRIORITIES > 32 )
 143:FreeRTOS/ARM_CM3/portmacro.h ****             #error configUSE_PORT_OPTIMISED_TASK_SELECTION can only be set to 1 when configMAX_PRIO
 144:FreeRTOS/ARM_CM3/portmacro.h ****         #endif
ARM GAS  /tmp/cczeOkKz.s 			page 32


 145:FreeRTOS/ARM_CM3/portmacro.h **** 
 146:FreeRTOS/ARM_CM3/portmacro.h **** /* Store/clear the ready priorities in a bit map. */
 147:FreeRTOS/ARM_CM3/portmacro.h ****         #define portRECORD_READY_PRIORITY( uxPriority, uxReadyPriorities )    ( uxReadyPriorities )
 148:FreeRTOS/ARM_CM3/portmacro.h ****         #define portRESET_READY_PRIORITY( uxPriority, uxReadyPriorities )     ( uxReadyPriorities )
 149:FreeRTOS/ARM_CM3/portmacro.h **** 
 150:FreeRTOS/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 151:FreeRTOS/ARM_CM3/portmacro.h **** 
 152:FreeRTOS/ARM_CM3/portmacro.h ****         #define portGET_HIGHEST_PRIORITY( uxTopPriority, uxReadyPriorities )    uxTopPriority = ( 3
 153:FreeRTOS/ARM_CM3/portmacro.h **** 
 154:FreeRTOS/ARM_CM3/portmacro.h ****     #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 155:FreeRTOS/ARM_CM3/portmacro.h **** 
 156:FreeRTOS/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 157:FreeRTOS/ARM_CM3/portmacro.h **** 
 158:FreeRTOS/ARM_CM3/portmacro.h ****     #ifdef configASSERT
 159:FreeRTOS/ARM_CM3/portmacro.h ****         void vPortValidateInterruptPriority( void );
 160:FreeRTOS/ARM_CM3/portmacro.h ****         #define portASSERT_IF_INTERRUPT_PRIORITY_INVALID()    vPortValidateInterruptPriority()
 161:FreeRTOS/ARM_CM3/portmacro.h ****     #endif
 162:FreeRTOS/ARM_CM3/portmacro.h **** 
 163:FreeRTOS/ARM_CM3/portmacro.h **** /* portNOP() is not required by this port. */
 164:FreeRTOS/ARM_CM3/portmacro.h ****     #define portNOP()
 165:FreeRTOS/ARM_CM3/portmacro.h **** 
 166:FreeRTOS/ARM_CM3/portmacro.h ****     #define portINLINE              __inline
 167:FreeRTOS/ARM_CM3/portmacro.h **** 
 168:FreeRTOS/ARM_CM3/portmacro.h ****     #ifndef portFORCE_INLINE
 169:FreeRTOS/ARM_CM3/portmacro.h ****         #define portFORCE_INLINE    inline __attribute__( ( always_inline ) )
 170:FreeRTOS/ARM_CM3/portmacro.h ****     #endif
 171:FreeRTOS/ARM_CM3/portmacro.h **** 
 172:FreeRTOS/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 173:FreeRTOS/ARM_CM3/portmacro.h **** 
 174:FreeRTOS/ARM_CM3/portmacro.h ****     portFORCE_INLINE static BaseType_t xPortIsInsideInterrupt( void )
 175:FreeRTOS/ARM_CM3/portmacro.h ****     {
 176:FreeRTOS/ARM_CM3/portmacro.h ****         uint32_t ulCurrentInterrupt;
 177:FreeRTOS/ARM_CM3/portmacro.h ****         BaseType_t xReturn;
 178:FreeRTOS/ARM_CM3/portmacro.h **** 
 179:FreeRTOS/ARM_CM3/portmacro.h ****         /* Obtain the number of the currently executing interrupt. */
 180:FreeRTOS/ARM_CM3/portmacro.h ****         __asm volatile ( "mrs %0, ipsr" : "=r" ( ulCurrentInterrupt )::"memory" );
 181:FreeRTOS/ARM_CM3/portmacro.h **** 
 182:FreeRTOS/ARM_CM3/portmacro.h ****         if( ulCurrentInterrupt == 0 )
 183:FreeRTOS/ARM_CM3/portmacro.h ****         {
 184:FreeRTOS/ARM_CM3/portmacro.h ****             xReturn = pdFALSE;
 185:FreeRTOS/ARM_CM3/portmacro.h ****         }
 186:FreeRTOS/ARM_CM3/portmacro.h ****         else
 187:FreeRTOS/ARM_CM3/portmacro.h ****         {
 188:FreeRTOS/ARM_CM3/portmacro.h ****             xReturn = pdTRUE;
 189:FreeRTOS/ARM_CM3/portmacro.h ****         }
 190:FreeRTOS/ARM_CM3/portmacro.h **** 
 191:FreeRTOS/ARM_CM3/portmacro.h ****         return xReturn;
 192:FreeRTOS/ARM_CM3/portmacro.h ****     }
 193:FreeRTOS/ARM_CM3/portmacro.h **** 
 194:FreeRTOS/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 195:FreeRTOS/ARM_CM3/portmacro.h **** 
 196:FreeRTOS/ARM_CM3/portmacro.h ****     portFORCE_INLINE static void vPortRaiseBASEPRI( void )
 197:FreeRTOS/ARM_CM3/portmacro.h ****     {
 198:FreeRTOS/ARM_CM3/portmacro.h ****         uint32_t ulNewBASEPRI;
 199:FreeRTOS/ARM_CM3/portmacro.h **** 
 200:FreeRTOS/ARM_CM3/portmacro.h ****         __asm volatile
 649              		.loc 2 200 0
ARM GAS  /tmp/cczeOkKz.s 			page 33


 650              		.syntax unified
 651              	@ 200 "FreeRTOS/ARM_CM3/portmacro.h" 1
 652 00bc 4FF05003 			mov r3, #80												
 653 00c0 83F31188 		msr basepri, r3											
 654 00c4 BFF36F8F 		isb														
 655 00c8 BFF34F8F 		dsb														
 656              	
 657              	@ 0 "" 2
 658              	.LVL71:
 659              		.thumb
 660              		.syntax unified
 661              	.L66:
 662 00cc FEE7     		b	.L66
 663              	.L61:
 664              	.LBE29:
 665              	.LBE28:
 874:FreeRTOS/timers.c ****                                 {
 666              		.loc 1 874 0
 667 00ce 94F82430 		ldrb	r3, [r4, #36]	@ zero_extendqisi2
 668 00d2 13F0020F 		tst	r3, #2
 669 00d6 04D0     		beq	.L73
 880:FreeRTOS/timers.c ****                                 }
 670              		.loc 1 880 0
 671 00d8 23F00103 		bic	r3, r3, #1
 672 00dc 84F82430 		strb	r3, [r4, #36]
 673 00e0 90E7     		b	.L54
 674              	.L73:
 876:FreeRTOS/timers.c ****                                 }
 675              		.loc 1 876 0
 676 00e2 2046     		mov	r0, r4
 677              	.LVL72:
 678 00e4 FFF7FEFF 		bl	vPortFree
 679              	.LVL73:
 680 00e8 8CE7     		b	.L54
 681              	.LVL74:
 682              	.L70:
 900:FreeRTOS/timers.c **** /*-----------------------------------------------------------*/
 683              		.loc 1 900 0
 684 00ea 05B0     		add	sp, sp, #20
 685              	.LCFI10:
 686              		.cfi_def_cfa_offset 12
 687              		@ sp needed
 688 00ec 30BD     		pop	{r4, r5, pc}
 689              	.L75:
 690 00ee 00BF     		.align	2
 691              	.L74:
 692 00f0 00000000 		.word	.LANCHOR3
 693              		.cfi_endproc
 694              	.LFE22:
 696              		.section	.text.prvTimerTask,"ax",%progbits
 697              		.align	1
 698              		.syntax unified
 699              		.thumb
 700              		.thumb_func
 701              		.fpu softvfp
 703              	prvTimerTask:
 704              	.LFB17:
ARM GAS  /tmp/cczeOkKz.s 			page 34


 564:FreeRTOS/timers.c ****         TickType_t xNextExpireTime;
 705              		.loc 1 564 0
 706              		.cfi_startproc
 707              		@ args = 0, pretend = 0, frame = 8
 708              		@ frame_needed = 0, uses_anonymous_args = 0
 709              	.LVL75:
 710 0000 00B5     		push	{lr}
 711              	.LCFI11:
 712              		.cfi_def_cfa_offset 4
 713              		.cfi_offset 14, -4
 714 0002 83B0     		sub	sp, sp, #12
 715              	.LCFI12:
 716              		.cfi_def_cfa_offset 16
 717              	.LVL76:
 718              	.L77:
 587:FreeRTOS/timers.c **** 
 719              		.loc 1 587 0 discriminator 1
 720 0004 01A8     		add	r0, sp, #4
 721 0006 FFF7FEFF 		bl	prvGetNextExpireTime
 722              	.LVL77:
 591:FreeRTOS/timers.c **** 
 723              		.loc 1 591 0 discriminator 1
 724 000a 0199     		ldr	r1, [sp, #4]
 725 000c FFF7FEFF 		bl	prvProcessTimerOrBlockTask
 726              	.LVL78:
 594:FreeRTOS/timers.c ****         }
 727              		.loc 1 594 0 discriminator 1
 728 0010 FFF7FEFF 		bl	prvProcessReceivedCommands
 729              	.LVL79:
 730 0014 F6E7     		b	.L77
 731              		.cfi_endproc
 732              	.LFE17:
 734              		.section	.text.prvCheckForValidListAndQueue,"ax",%progbits
 735              		.align	1
 736              		.syntax unified
 737              		.thumb
 738              		.thumb_func
 739              		.fpu softvfp
 741              	prvCheckForValidListAndQueue:
 742              	.LFB24:
 926:FreeRTOS/timers.c **** /*-----------------------------------------------------------*/
 927:FreeRTOS/timers.c **** 
 928:FreeRTOS/timers.c ****     static void prvCheckForValidListAndQueue( void )
 929:FreeRTOS/timers.c ****     {
 743              		.loc 1 929 0
 744              		.cfi_startproc
 745              		@ args = 0, pretend = 0, frame = 0
 746              		@ frame_needed = 0, uses_anonymous_args = 0
 747 0000 38B5     		push	{r3, r4, r5, lr}
 748              	.LCFI13:
 749              		.cfi_def_cfa_offset 16
 750              		.cfi_offset 3, -16
 751              		.cfi_offset 4, -12
 752              		.cfi_offset 5, -8
 753              		.cfi_offset 14, -4
 930:FreeRTOS/timers.c ****         /* Check that the list from which active timers are referenced, and the
 931:FreeRTOS/timers.c ****          * queue used to communicate with the timer service, have been
ARM GAS  /tmp/cczeOkKz.s 			page 35


 932:FreeRTOS/timers.c ****          * initialised. */
 933:FreeRTOS/timers.c ****         taskENTER_CRITICAL();
 754              		.loc 1 933 0
 755 0002 FFF7FEFF 		bl	vPortEnterCritical
 756              	.LVL80:
 934:FreeRTOS/timers.c ****         {
 935:FreeRTOS/timers.c ****             if( xTimerQueue == NULL )
 757              		.loc 1 935 0
 758 0006 0F4B     		ldr	r3, .L83
 759 0008 1B68     		ldr	r3, [r3]
 760 000a 13B1     		cbz	r3, .L82
 761              	.L80:
 936:FreeRTOS/timers.c ****             {
 937:FreeRTOS/timers.c ****                 vListInitialise( &xActiveTimerList1 );
 938:FreeRTOS/timers.c ****                 vListInitialise( &xActiveTimerList2 );
 939:FreeRTOS/timers.c ****                 pxCurrentTimerList = &xActiveTimerList1;
 940:FreeRTOS/timers.c ****                 pxOverflowTimerList = &xActiveTimerList2;
 941:FreeRTOS/timers.c **** 
 942:FreeRTOS/timers.c ****                 #if ( configSUPPORT_STATIC_ALLOCATION == 1 )
 943:FreeRTOS/timers.c ****                     {
 944:FreeRTOS/timers.c ****                         /* The timer queue is allocated statically in case
 945:FreeRTOS/timers.c ****                          * configSUPPORT_DYNAMIC_ALLOCATION is 0. */
 946:FreeRTOS/timers.c ****                         PRIVILEGED_DATA static StaticQueue_t xStaticTimerQueue;                    
 947:FreeRTOS/timers.c ****                         PRIVILEGED_DATA static uint8_t ucStaticTimerQueueStorage[ ( size_t ) config
 948:FreeRTOS/timers.c **** 
 949:FreeRTOS/timers.c ****                         xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH,
 950:FreeRTOS/timers.c ****                     }
 951:FreeRTOS/timers.c ****                 #else
 952:FreeRTOS/timers.c ****                     {
 953:FreeRTOS/timers.c ****                         xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeo
 954:FreeRTOS/timers.c ****                     }
 955:FreeRTOS/timers.c ****                 #endif /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
 956:FreeRTOS/timers.c **** 
 957:FreeRTOS/timers.c ****                 #if ( configQUEUE_REGISTRY_SIZE > 0 )
 958:FreeRTOS/timers.c ****                     {
 959:FreeRTOS/timers.c ****                         if( xTimerQueue != NULL )
 960:FreeRTOS/timers.c ****                         {
 961:FreeRTOS/timers.c ****                             vQueueAddToRegistry( xTimerQueue, "TmrQ" );
 962:FreeRTOS/timers.c ****                         }
 963:FreeRTOS/timers.c ****                         else
 964:FreeRTOS/timers.c ****                         {
 965:FreeRTOS/timers.c ****                             mtCOVERAGE_TEST_MARKER();
 966:FreeRTOS/timers.c ****                         }
 967:FreeRTOS/timers.c ****                     }
 968:FreeRTOS/timers.c ****                 #endif /* configQUEUE_REGISTRY_SIZE */
 969:FreeRTOS/timers.c ****             }
 970:FreeRTOS/timers.c ****             else
 971:FreeRTOS/timers.c ****             {
 972:FreeRTOS/timers.c ****                 mtCOVERAGE_TEST_MARKER();
 973:FreeRTOS/timers.c ****             }
 974:FreeRTOS/timers.c ****         }
 975:FreeRTOS/timers.c ****         taskEXIT_CRITICAL();
 762              		.loc 1 975 0
 763 000c FFF7FEFF 		bl	vPortExitCritical
 764              	.LVL81:
 976:FreeRTOS/timers.c ****     }
 765              		.loc 1 976 0
ARM GAS  /tmp/cczeOkKz.s 			page 36


 766 0010 38BD     		pop	{r3, r4, r5, pc}
 767              	.L82:
 937:FreeRTOS/timers.c ****                 vListInitialise( &xActiveTimerList2 );
 768              		.loc 1 937 0
 769 0012 0D4D     		ldr	r5, .L83+4
 770 0014 2846     		mov	r0, r5
 771 0016 FFF7FEFF 		bl	vListInitialise
 772              	.LVL82:
 938:FreeRTOS/timers.c ****                 pxCurrentTimerList = &xActiveTimerList1;
 773              		.loc 1 938 0
 774 001a 0C4C     		ldr	r4, .L83+8
 775 001c 2046     		mov	r0, r4
 776 001e FFF7FEFF 		bl	vListInitialise
 777              	.LVL83:
 939:FreeRTOS/timers.c ****                 pxOverflowTimerList = &xActiveTimerList2;
 778              		.loc 1 939 0
 779 0022 0B4B     		ldr	r3, .L83+12
 780 0024 1D60     		str	r5, [r3]
 940:FreeRTOS/timers.c **** 
 781              		.loc 1 940 0
 782 0026 0B4B     		ldr	r3, .L83+16
 783 0028 1C60     		str	r4, [r3]
 953:FreeRTOS/timers.c ****                     }
 784              		.loc 1 953 0
 785 002a 0022     		movs	r2, #0
 786 002c 0C21     		movs	r1, #12
 787 002e 0A20     		movs	r0, #10
 788 0030 FFF7FEFF 		bl	xQueueGenericCreate
 789              	.LVL84:
 790 0034 034B     		ldr	r3, .L83
 791 0036 1860     		str	r0, [r3]
 959:FreeRTOS/timers.c ****                         {
 792              		.loc 1 959 0
 793 0038 0028     		cmp	r0, #0
 794 003a E7D0     		beq	.L80
 961:FreeRTOS/timers.c ****                         }
 795              		.loc 1 961 0
 796 003c 0649     		ldr	r1, .L83+20
 797 003e FFF7FEFF 		bl	vQueueAddToRegistry
 798              	.LVL85:
 799 0042 E3E7     		b	.L80
 800              	.L84:
 801              		.align	2
 802              	.L83:
 803 0044 00000000 		.word	.LANCHOR3
 804 0048 00000000 		.word	.LANCHOR4
 805 004c 00000000 		.word	.LANCHOR5
 806 0050 00000000 		.word	.LANCHOR0
 807 0054 00000000 		.word	.LANCHOR1
 808 0058 00000000 		.word	.LC0
 809              		.cfi_endproc
 810              	.LFE24:
 812              		.section	.text.prvInitialiseNewTimer,"ax",%progbits
 813              		.align	1
 814              		.syntax unified
 815              		.thumb
 816              		.thumb_func
ARM GAS  /tmp/cczeOkKz.s 			page 37


 817              		.fpu softvfp
 819              	prvInitialiseNewTimer:
 820              	.LFB7:
 361:FreeRTOS/timers.c ****         /* 0 is not a valid value for xTimerPeriodInTicks. */
 821              		.loc 1 361 0
 822              		.cfi_startproc
 823              		@ args = 8, pretend = 0, frame = 0
 824              		@ frame_needed = 0, uses_anonymous_args = 0
 825              	.LVL86:
 826 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 827              	.LCFI14:
 828              		.cfi_def_cfa_offset 24
 829              		.cfi_offset 4, -24
 830              		.cfi_offset 5, -20
 831              		.cfi_offset 6, -16
 832              		.cfi_offset 7, -12
 833              		.cfi_offset 8, -8
 834              		.cfi_offset 14, -4
 835 0004 079C     		ldr	r4, [sp, #28]
 363:FreeRTOS/timers.c **** 
 836              		.loc 1 363 0
 837 0006 41B9     		cbnz	r1, .L86
 838              	.LBB30:
 839              	.LBB31:
 840              		.loc 2 200 0
 841              		.syntax unified
 842              	@ 200 "FreeRTOS/ARM_CM3/portmacro.h" 1
 843 0008 4FF05003 			mov r3, #80												
 844 000c 83F31188 		msr basepri, r3											
 845 0010 BFF36F8F 		isb														
 846 0014 BFF34F8F 		dsb														
 847              	
 848              	@ 0 "" 2
 849              	.LVL87:
 850              		.thumb
 851              		.syntax unified
 852              	.L87:
 853 0018 FEE7     		b	.L87
 854              	.LVL88:
 855              	.L86:
 856 001a 0F46     		mov	r7, r1
 857 001c 1E46     		mov	r6, r3
 858 001e 1546     		mov	r5, r2
 859 0020 8046     		mov	r8, r0
 860              	.LBE31:
 861              	.LBE30:
 367:FreeRTOS/timers.c **** 
 862              		.loc 1 367 0
 863 0022 FFF7FEFF 		bl	prvCheckForValidListAndQueue
 864              	.LVL89:
 371:FreeRTOS/timers.c ****         pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
 865              		.loc 1 371 0
 866 0026 C4F80080 		str	r8, [r4]
 372:FreeRTOS/timers.c ****         pxNewTimer->pvTimerID = pvTimerID;
 867              		.loc 1 372 0
 868 002a A761     		str	r7, [r4, #24]
 373:FreeRTOS/timers.c ****         pxNewTimer->pxCallbackFunction = pxCallbackFunction;
ARM GAS  /tmp/cczeOkKz.s 			page 38


 869              		.loc 1 373 0
 870 002c E661     		str	r6, [r4, #28]
 374:FreeRTOS/timers.c ****         vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
 871              		.loc 1 374 0
 872 002e 069B     		ldr	r3, [sp, #24]
 873 0030 2362     		str	r3, [r4, #32]
 375:FreeRTOS/timers.c **** 
 874              		.loc 1 375 0
 875 0032 201D     		adds	r0, r4, #4
 876 0034 FFF7FEFF 		bl	vListInitialiseItem
 877              	.LVL90:
 377:FreeRTOS/timers.c ****         {
 878              		.loc 1 377 0
 879 0038 2DB1     		cbz	r5, .L85
 379:FreeRTOS/timers.c ****         }
 880              		.loc 1 379 0
 881 003a 94F82430 		ldrb	r3, [r4, #36]	@ zero_extendqisi2
 882 003e 43F00403 		orr	r3, r3, #4
 883 0042 84F82430 		strb	r3, [r4, #36]
 884              	.L85:
 383:FreeRTOS/timers.c **** /*-----------------------------------------------------------*/
 885              		.loc 1 383 0
 886 0046 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 887              		.cfi_endproc
 888              	.LFE7:
 890              		.section	.text.xTimerCreateTimerTask,"ax",%progbits
 891              		.align	1
 892              		.global	xTimerCreateTimerTask
 893              		.syntax unified
 894              		.thumb
 895              		.thumb_func
 896              		.fpu softvfp
 898              	xTimerCreateTimerTask:
 899              	.LFB5:
 234:FreeRTOS/timers.c ****         BaseType_t xReturn = pdFAIL;
 900              		.loc 1 234 0
 901              		.cfi_startproc
 902              		@ args = 0, pretend = 0, frame = 0
 903              		@ frame_needed = 0, uses_anonymous_args = 0
 904 0000 00B5     		push	{lr}
 905              	.LCFI15:
 906              		.cfi_def_cfa_offset 4
 907              		.cfi_offset 14, -4
 908 0002 83B0     		sub	sp, sp, #12
 909              	.LCFI16:
 910              		.cfi_def_cfa_offset 16
 911              	.LVL91:
 241:FreeRTOS/timers.c **** 
 912              		.loc 1 241 0
 913 0004 FFF7FEFF 		bl	prvCheckForValidListAndQueue
 914              	.LVL92:
 243:FreeRTOS/timers.c ****         {
 915              		.loc 1 243 0
 916 0008 0C4B     		ldr	r3, .L95
 917 000a 1B68     		ldr	r3, [r3]
 918 000c 53B1     		cbz	r3, .L91
 267:FreeRTOS/timers.c ****                                            configTIMER_SERVICE_TASK_NAME,
ARM GAS  /tmp/cczeOkKz.s 			page 39


 919              		.loc 1 267 0
 920 000e 0C4B     		ldr	r3, .L95+4
 921 0010 0193     		str	r3, [sp, #4]
 922 0012 0123     		movs	r3, #1
 923 0014 0093     		str	r3, [sp]
 924 0016 0023     		movs	r3, #0
 925 0018 0222     		movs	r2, #2
 926 001a 0A49     		ldr	r1, .L95+8
 927 001c 0A48     		ldr	r0, .L95+12
 928 001e FFF7FEFF 		bl	xTaskCreate
 929              	.LVL93:
 281:FreeRTOS/timers.c ****         return xReturn;
 930              		.loc 1 281 0
 931 0022 40B9     		cbnz	r0, .L90
 932              	.LVL94:
 933              	.L91:
 934              	.LBB32:
 935              	.LBB33:
 936              		.loc 2 200 0
 937              		.syntax unified
 938              	@ 200 "FreeRTOS/ARM_CM3/portmacro.h" 1
 939 0024 4FF05003 			mov r3, #80												
 940 0028 83F31188 		msr basepri, r3											
 941 002c BFF36F8F 		isb														
 942 0030 BFF34F8F 		dsb														
 943              	
 944              	@ 0 "" 2
 945              	.LVL95:
 946              		.thumb
 947              		.syntax unified
 948              	.L93:
 949 0034 FEE7     		b	.L93
 950              	.LVL96:
 951              	.L90:
 952              	.LBE33:
 953              	.LBE32:
 283:FreeRTOS/timers.c **** /*-----------------------------------------------------------*/
 954              		.loc 1 283 0
 955 0036 03B0     		add	sp, sp, #12
 956              	.LCFI17:
 957              		.cfi_def_cfa_offset 4
 958              		@ sp needed
 959 0038 5DF804FB 		ldr	pc, [sp], #4
 960              	.L96:
 961              		.align	2
 962              	.L95:
 963 003c 00000000 		.word	.LANCHOR3
 964 0040 00000000 		.word	.LANCHOR6
 965 0044 00000000 		.word	.LC1
 966 0048 00000000 		.word	prvTimerTask
 967              		.cfi_endproc
 968              	.LFE5:
 970              		.section	.text.xTimerCreate,"ax",%progbits
 971              		.align	1
 972              		.global	xTimerCreate
 973              		.syntax unified
 974              		.thumb
ARM GAS  /tmp/cczeOkKz.s 			page 40


 975              		.thumb_func
 976              		.fpu softvfp
 978              	xTimerCreate:
 979              	.LFB6:
 293:FreeRTOS/timers.c ****             Timer_t * pxNewTimer;
 980              		.loc 1 293 0
 981              		.cfi_startproc
 982              		@ args = 4, pretend = 0, frame = 0
 983              		@ frame_needed = 0, uses_anonymous_args = 0
 984              	.LVL97:
 985 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 986              	.LCFI18:
 987              		.cfi_def_cfa_offset 24
 988              		.cfi_offset 4, -24
 989              		.cfi_offset 5, -20
 990              		.cfi_offset 6, -16
 991              		.cfi_offset 7, -12
 992              		.cfi_offset 8, -8
 993              		.cfi_offset 14, -4
 994 0004 82B0     		sub	sp, sp, #8
 995              	.LCFI19:
 996              		.cfi_def_cfa_offset 32
 997 0006 0546     		mov	r5, r0
 998 0008 0E46     		mov	r6, r1
 999 000a 1746     		mov	r7, r2
 1000 000c 9846     		mov	r8, r3
 296:FreeRTOS/timers.c **** 
 1001              		.loc 1 296 0
 1002 000e 2820     		movs	r0, #40
 1003              	.LVL98:
 1004 0010 FFF7FEFF 		bl	pvPortMalloc
 1005              	.LVL99:
 298:FreeRTOS/timers.c ****             {
 1006              		.loc 1 298 0
 1007 0014 0446     		mov	r4, r0
 1008 0016 58B1     		cbz	r0, .L97
 303:FreeRTOS/timers.c ****                 prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, p
 1009              		.loc 1 303 0
 1010 0018 0023     		movs	r3, #0
 1011 001a 80F82430 		strb	r3, [r0, #36]
 304:FreeRTOS/timers.c ****             }
 1012              		.loc 1 304 0
 1013 001e 0190     		str	r0, [sp, #4]
 1014 0020 089B     		ldr	r3, [sp, #32]
 1015 0022 0093     		str	r3, [sp]
 1016 0024 4346     		mov	r3, r8
 1017 0026 3A46     		mov	r2, r7
 1018 0028 3146     		mov	r1, r6
 1019 002a 2846     		mov	r0, r5
 1020              	.LVL100:
 1021 002c FFF7FEFF 		bl	prvInitialiseNewTimer
 1022              	.LVL101:
 1023              	.L97:
 308:FreeRTOS/timers.c **** 
 1024              		.loc 1 308 0
 1025 0030 2046     		mov	r0, r4
 1026 0032 02B0     		add	sp, sp, #8
ARM GAS  /tmp/cczeOkKz.s 			page 41


 1027              	.LCFI20:
 1028              		.cfi_def_cfa_offset 24
 1029              		@ sp needed
 1030 0034 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 1031              		.cfi_endproc
 1032              	.LFE6:
 1034              		.section	.text.xTimerGenericCommand,"ax",%progbits
 1035              		.align	1
 1036              		.global	xTimerGenericCommand
 1037              		.syntax unified
 1038              		.thumb
 1039              		.thumb_func
 1040              		.fpu softvfp
 1042              	xTimerGenericCommand:
 1043              	.LFB8:
 391:FreeRTOS/timers.c ****         BaseType_t xReturn = pdFAIL;
 1044              		.loc 1 391 0
 1045              		.cfi_startproc
 1046              		@ args = 4, pretend = 0, frame = 16
 1047              		@ frame_needed = 0, uses_anonymous_args = 0
 1048              	.LVL102:
 395:FreeRTOS/timers.c **** 
 1049              		.loc 1 395 0
 1050 0000 C8B1     		cbz	r0, .L109
 391:FreeRTOS/timers.c ****         BaseType_t xReturn = pdFAIL;
 1051              		.loc 1 391 0
 1052 0002 30B5     		push	{r4, r5, lr}
 1053              	.LCFI21:
 1054              		.cfi_def_cfa_offset 12
 1055              		.cfi_offset 4, -12
 1056              		.cfi_offset 5, -8
 1057              		.cfi_offset 14, -4
 1058 0004 85B0     		sub	sp, sp, #20
 1059              	.LCFI22:
 1060              		.cfi_def_cfa_offset 32
 1061 0006 1546     		mov	r5, r2
 1062 0008 0446     		mov	r4, r0
 399:FreeRTOS/timers.c ****         {
 1063              		.loc 1 399 0
 1064 000a 174A     		ldr	r2, .L111
 1065              	.LVL103:
 1066 000c 1068     		ldr	r0, [r2]
 1067              	.LVL104:
 1068 000e 40B3     		cbz	r0, .L106
 1069 0010 1A46     		mov	r2, r3
 402:FreeRTOS/timers.c ****             xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
 1070              		.loc 1 402 0
 1071 0012 0191     		str	r1, [sp, #4]
 403:FreeRTOS/timers.c ****             xMessage.u.xTimerParameters.pxTimer = xTimer;
 1072              		.loc 1 403 0
 1073 0014 0295     		str	r5, [sp, #8]
 404:FreeRTOS/timers.c **** 
 1074              		.loc 1 404 0
 1075 0016 0394     		str	r4, [sp, #12]
 406:FreeRTOS/timers.c ****             {
 1076              		.loc 1 406 0
 1077 0018 0529     		cmp	r1, #5
ARM GAS  /tmp/cczeOkKz.s 			page 42


 1078 001a 1DDC     		bgt	.L104
 408:FreeRTOS/timers.c ****                 {
 1079              		.loc 1 408 0
 1080 001c FFF7FEFF 		bl	xTaskGetSchedulerState
 1081              	.LVL105:
 1082 0020 0228     		cmp	r0, #2
 1083 0022 11D0     		beq	.L110
 414:FreeRTOS/timers.c ****                 }
 1084              		.loc 1 414 0
 1085 0024 0023     		movs	r3, #0
 1086 0026 1A46     		mov	r2, r3
 1087 0028 01A9     		add	r1, sp, #4
 1088 002a 0F48     		ldr	r0, .L111
 1089 002c 0068     		ldr	r0, [r0]
 1090 002e FFF7FEFF 		bl	xQueueGenericSend
 1091              	.LVL106:
 1092              	.L100:
 430:FreeRTOS/timers.c **** /*-----------------------------------------------------------*/
 1093              		.loc 1 430 0
 1094 0032 05B0     		add	sp, sp, #20
 1095              	.LCFI23:
 1096              		.cfi_def_cfa_offset 12
 1097              		@ sp needed
 1098 0034 30BD     		pop	{r4, r5, pc}
 1099              	.LVL107:
 1100              	.L109:
 1101              	.LCFI24:
 1102              		.cfi_def_cfa_offset 0
 1103              		.cfi_restore 4
 1104              		.cfi_restore 5
 1105              		.cfi_restore 14
 1106              	.LBB34:
 1107              	.LBB35:
 1108              		.loc 2 200 0
 1109              		.syntax unified
 1110              	@ 200 "FreeRTOS/ARM_CM3/portmacro.h" 1
 1111 0036 4FF05003 			mov r3, #80												
 1112 003a 83F31188 		msr basepri, r3											
 1113 003e BFF36F8F 		isb														
 1114 0042 BFF34F8F 		dsb														
 1115              	
 1116              	@ 0 "" 2
 1117              	.LVL108:
 1118              		.thumb
 1119              		.syntax unified
 1120              	.L102:
 1121 0046 FEE7     		b	.L102
 1122              	.LVL109:
 1123              	.L110:
 1124              	.LCFI25:
 1125              		.cfi_def_cfa_offset 32
 1126              		.cfi_offset 4, -12
 1127              		.cfi_offset 5, -8
 1128              		.cfi_offset 14, -4
 1129              	.LBE35:
 1130              	.LBE34:
 410:FreeRTOS/timers.c ****                 }
ARM GAS  /tmp/cczeOkKz.s 			page 43


 1131              		.loc 1 410 0
 1132 0048 0023     		movs	r3, #0
 1133 004a 089A     		ldr	r2, [sp, #32]
 1134 004c 01A9     		add	r1, sp, #4
 1135 004e 0648     		ldr	r0, .L111
 1136 0050 0068     		ldr	r0, [r0]
 1137 0052 FFF7FEFF 		bl	xQueueGenericSend
 1138              	.LVL110:
 1139 0056 ECE7     		b	.L100
 1140              	.LVL111:
 1141              	.L104:
 419:FreeRTOS/timers.c ****             }
 1142              		.loc 1 419 0
 1143 0058 0023     		movs	r3, #0
 1144 005a 01A9     		add	r1, sp, #4
 1145              	.LVL112:
 1146 005c FFF7FEFF 		bl	xQueueGenericSendFromISR
 1147              	.LVL113:
 1148 0060 E7E7     		b	.L100
 1149              	.LVL114:
 1150              	.L106:
 392:FreeRTOS/timers.c ****         DaemonTaskMessage_t xMessage;
 1151              		.loc 1 392 0
 1152 0062 0020     		movs	r0, #0
 429:FreeRTOS/timers.c ****     }
 1153              		.loc 1 429 0
 1154 0064 E5E7     		b	.L100
 1155              	.L112:
 1156 0066 00BF     		.align	2
 1157              	.L111:
 1158 0068 00000000 		.word	.LANCHOR3
 1159              		.cfi_endproc
 1160              	.LFE8:
 1162              		.section	.text.xTimerGetTimerDaemonTaskHandle,"ax",%progbits
 1163              		.align	1
 1164              		.global	xTimerGetTimerDaemonTaskHandle
 1165              		.syntax unified
 1166              		.thumb
 1167              		.thumb_func
 1168              		.fpu softvfp
 1170              	xTimerGetTimerDaemonTaskHandle:
 1171              	.LFB9:
 434:FreeRTOS/timers.c ****         /* If xTimerGetTimerDaemonTaskHandle() is called before the scheduler has been
 1172              		.loc 1 434 0
 1173              		.cfi_startproc
 1174              		@ args = 0, pretend = 0, frame = 0
 1175              		@ frame_needed = 0, uses_anonymous_args = 0
 1176              		@ link register save eliminated.
 437:FreeRTOS/timers.c ****         return xTimerTaskHandle;
 1177              		.loc 1 437 0
 1178 0000 064B     		ldr	r3, .L117
 1179 0002 1868     		ldr	r0, [r3]
 1180 0004 00B1     		cbz	r0, .L116
 439:FreeRTOS/timers.c **** /*-----------------------------------------------------------*/
 1181              		.loc 1 439 0
 1182 0006 7047     		bx	lr
 1183              	.L116:
ARM GAS  /tmp/cczeOkKz.s 			page 44


 1184              	.LBB36:
 1185              	.LBB37:
 1186              		.loc 2 200 0
 1187              		.syntax unified
 1188              	@ 200 "FreeRTOS/ARM_CM3/portmacro.h" 1
 1189 0008 4FF05003 			mov r3, #80												
 1190 000c 83F31188 		msr basepri, r3											
 1191 0010 BFF36F8F 		isb														
 1192 0014 BFF34F8F 		dsb														
 1193              	
 1194              	@ 0 "" 2
 1195              	.LVL115:
 1196              		.thumb
 1197              		.syntax unified
 1198              	.L115:
 1199 0018 FEE7     		b	.L115
 1200              	.L118:
 1201 001a 00BF     		.align	2
 1202              	.L117:
 1203 001c 00000000 		.word	.LANCHOR6
 1204              	.LBE37:
 1205              	.LBE36:
 1206              		.cfi_endproc
 1207              	.LFE9:
 1209              		.section	.text.xTimerGetPeriod,"ax",%progbits
 1210              		.align	1
 1211              		.global	xTimerGetPeriod
 1212              		.syntax unified
 1213              		.thumb
 1214              		.thumb_func
 1215              		.fpu softvfp
 1217              	xTimerGetPeriod:
 1218              	.LFB10:
 443:FreeRTOS/timers.c ****         Timer_t * pxTimer = xTimer;
 1219              		.loc 1 443 0
 1220              		.cfi_startproc
 1221              		@ args = 0, pretend = 0, frame = 0
 1222              		@ frame_needed = 0, uses_anonymous_args = 0
 1223              		@ link register save eliminated.
 1224              	.LVL116:
 446:FreeRTOS/timers.c ****         return pxTimer->xTimerPeriodInTicks;
 1225              		.loc 1 446 0
 1226 0000 08B1     		cbz	r0, .L122
 448:FreeRTOS/timers.c **** /*-----------------------------------------------------------*/
 1227              		.loc 1 448 0
 1228 0002 8069     		ldr	r0, [r0, #24]
 1229              	.LVL117:
 1230 0004 7047     		bx	lr
 1231              	.LVL118:
 1232              	.L122:
 1233              	.LBB38:
 1234              	.LBB39:
 1235              		.loc 2 200 0
 1236              		.syntax unified
 1237              	@ 200 "FreeRTOS/ARM_CM3/portmacro.h" 1
 1238 0006 4FF05003 			mov r3, #80												
 1239 000a 83F31188 		msr basepri, r3											
ARM GAS  /tmp/cczeOkKz.s 			page 45


 1240 000e BFF36F8F 		isb														
 1241 0012 BFF34F8F 		dsb														
 1242              	
 1243              	@ 0 "" 2
 1244              	.LVL119:
 1245              		.thumb
 1246              		.syntax unified
 1247              	.L121:
 1248 0016 FEE7     		b	.L121
 1249              	.LBE39:
 1250              	.LBE38:
 1251              		.cfi_endproc
 1252              	.LFE10:
 1254              		.section	.text.vTimerSetReloadMode,"ax",%progbits
 1255              		.align	1
 1256              		.global	vTimerSetReloadMode
 1257              		.syntax unified
 1258              		.thumb
 1259              		.thumb_func
 1260              		.fpu softvfp
 1262              	vTimerSetReloadMode:
 1263              	.LFB11:
 453:FreeRTOS/timers.c ****         Timer_t * pxTimer = xTimer;
 1264              		.loc 1 453 0
 1265              		.cfi_startproc
 1266              		@ args = 0, pretend = 0, frame = 0
 1267              		@ frame_needed = 0, uses_anonymous_args = 0
 1268              	.LVL120:
 1269 0000 38B5     		push	{r3, r4, r5, lr}
 1270              	.LCFI26:
 1271              		.cfi_def_cfa_offset 16
 1272              		.cfi_offset 3, -16
 1273              		.cfi_offset 4, -12
 1274              		.cfi_offset 5, -8
 1275              		.cfi_offset 14, -4
 1276              	.LVL121:
 456:FreeRTOS/timers.c ****         taskENTER_CRITICAL();
 1277              		.loc 1 456 0
 1278 0002 40B9     		cbnz	r0, .L124
 1279              	.LBB40:
 1280              	.LBB41:
 1281              		.loc 2 200 0
 1282              		.syntax unified
 1283              	@ 200 "FreeRTOS/ARM_CM3/portmacro.h" 1
 1284 0004 4FF05003 			mov r3, #80												
 1285 0008 83F31188 		msr basepri, r3											
 1286 000c BFF36F8F 		isb														
 1287 0010 BFF34F8F 		dsb														
 1288              	
 1289              	@ 0 "" 2
 1290              	.LVL122:
 1291              		.thumb
 1292              		.syntax unified
 1293              	.L125:
 1294 0014 FEE7     		b	.L125
 1295              	.L124:
 1296 0016 0446     		mov	r4, r0
ARM GAS  /tmp/cczeOkKz.s 			page 46


 1297 0018 0D46     		mov	r5, r1
 1298              	.LBE41:
 1299              	.LBE40:
 457:FreeRTOS/timers.c ****         {
 1300              		.loc 1 457 0
 1301 001a FFF7FEFF 		bl	vPortEnterCritical
 1302              	.LVL123:
 459:FreeRTOS/timers.c ****             {
 1303              		.loc 1 459 0
 1304 001e 35B9     		cbnz	r5, .L129
 465:FreeRTOS/timers.c ****             }
 1305              		.loc 1 465 0
 1306 0020 94F82430 		ldrb	r3, [r4, #36]	@ zero_extendqisi2
 1307 0024 23F00403 		bic	r3, r3, #4
 1308 0028 84F82430 		strb	r3, [r4, #36]
 1309 002c 05E0     		b	.L127
 1310              	.L129:
 461:FreeRTOS/timers.c ****             }
 1311              		.loc 1 461 0
 1312 002e 94F82430 		ldrb	r3, [r4, #36]	@ zero_extendqisi2
 1313 0032 43F00403 		orr	r3, r3, #4
 1314 0036 84F82430 		strb	r3, [r4, #36]
 1315              	.L127:
 468:FreeRTOS/timers.c ****     }
 1316              		.loc 1 468 0
 1317 003a FFF7FEFF 		bl	vPortExitCritical
 1318              	.LVL124:
 469:FreeRTOS/timers.c **** /*-----------------------------------------------------------*/
 1319              		.loc 1 469 0
 1320 003e 38BD     		pop	{r3, r4, r5, pc}
 1321              		.cfi_endproc
 1322              	.LFE11:
 1324              		.section	.text.uxTimerGetReloadMode,"ax",%progbits
 1325              		.align	1
 1326              		.global	uxTimerGetReloadMode
 1327              		.syntax unified
 1328              		.thumb
 1329              		.thumb_func
 1330              		.fpu softvfp
 1332              	uxTimerGetReloadMode:
 1333              	.LFB12:
 473:FreeRTOS/timers.c ****         Timer_t * pxTimer = xTimer;
 1334              		.loc 1 473 0
 1335              		.cfi_startproc
 1336              		@ args = 0, pretend = 0, frame = 0
 1337              		@ frame_needed = 0, uses_anonymous_args = 0
 1338              	.LVL125:
 477:FreeRTOS/timers.c ****         taskENTER_CRITICAL();
 1339              		.loc 1 477 0
 1340 0000 40B9     		cbnz	r0, .L131
 1341              	.LBB42:
 1342              	.LBB43:
 1343              		.loc 2 200 0
 1344              		.syntax unified
 1345              	@ 200 "FreeRTOS/ARM_CM3/portmacro.h" 1
 1346 0002 4FF05003 			mov r3, #80												
 1347 0006 83F31188 		msr basepri, r3											
ARM GAS  /tmp/cczeOkKz.s 			page 47


 1348 000a BFF36F8F 		isb														
 1349 000e BFF34F8F 		dsb														
 1350              	
 1351              	@ 0 "" 2
 1352              	.LVL126:
 1353              		.thumb
 1354              		.syntax unified
 1355              	.L132:
 1356 0012 FEE7     		b	.L132
 1357              	.L131:
 1358              	.LBE43:
 1359              	.LBE42:
 473:FreeRTOS/timers.c ****         Timer_t * pxTimer = xTimer;
 1360              		.loc 1 473 0
 1361 0014 10B5     		push	{r4, lr}
 1362              	.LCFI27:
 1363              		.cfi_def_cfa_offset 8
 1364              		.cfi_offset 4, -8
 1365              		.cfi_offset 14, -4
 1366 0016 0446     		mov	r4, r0
 478:FreeRTOS/timers.c ****         {
 1367              		.loc 1 478 0
 1368 0018 FFF7FEFF 		bl	vPortEnterCritical
 1369              	.LVL127:
 480:FreeRTOS/timers.c ****             {
 1370              		.loc 1 480 0
 1371 001c 94F82430 		ldrb	r3, [r4, #36]	@ zero_extendqisi2
 1372 0020 13F0040F 		tst	r3, #4
 1373 0024 04D0     		beq	.L137
 488:FreeRTOS/timers.c ****             }
 1374              		.loc 1 488 0
 1375 0026 0124     		movs	r4, #1
 1376              	.LVL128:
 1377              	.L133:
 491:FreeRTOS/timers.c **** 
 1378              		.loc 1 491 0
 1379 0028 FFF7FEFF 		bl	vPortExitCritical
 1380              	.LVL129:
 494:FreeRTOS/timers.c **** /*-----------------------------------------------------------*/
 1381              		.loc 1 494 0
 1382 002c 2046     		mov	r0, r4
 1383 002e 10BD     		pop	{r4, pc}
 1384              	.LVL130:
 1385              	.L137:
 483:FreeRTOS/timers.c ****             }
 1386              		.loc 1 483 0
 1387 0030 0024     		movs	r4, #0
 1388              	.LVL131:
 1389 0032 F9E7     		b	.L133
 1390              		.cfi_endproc
 1391              	.LFE12:
 1393              		.section	.text.xTimerGetExpiryTime,"ax",%progbits
 1394              		.align	1
 1395              		.global	xTimerGetExpiryTime
 1396              		.syntax unified
 1397              		.thumb
 1398              		.thumb_func
ARM GAS  /tmp/cczeOkKz.s 			page 48


 1399              		.fpu softvfp
 1401              	xTimerGetExpiryTime:
 1402              	.LFB13:
 498:FreeRTOS/timers.c ****         Timer_t * pxTimer = xTimer;
 1403              		.loc 1 498 0
 1404              		.cfi_startproc
 1405              		@ args = 0, pretend = 0, frame = 0
 1406              		@ frame_needed = 0, uses_anonymous_args = 0
 1407              		@ link register save eliminated.
 1408              	.LVL132:
 502:FreeRTOS/timers.c ****         xReturn = listGET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ) );
 1409              		.loc 1 502 0
 1410 0000 08B1     		cbz	r0, .L141
 1411              	.LVL133:
 505:FreeRTOS/timers.c **** /*-----------------------------------------------------------*/
 1412              		.loc 1 505 0
 1413 0002 4068     		ldr	r0, [r0, #4]
 1414              	.LVL134:
 1415 0004 7047     		bx	lr
 1416              	.LVL135:
 1417              	.L141:
 1418              	.LBB44:
 1419              	.LBB45:
 1420              		.loc 2 200 0
 1421              		.syntax unified
 1422              	@ 200 "FreeRTOS/ARM_CM3/portmacro.h" 1
 1423 0006 4FF05003 			mov r3, #80												
 1424 000a 83F31188 		msr basepri, r3											
 1425 000e BFF36F8F 		isb														
 1426 0012 BFF34F8F 		dsb														
 1427              	
 1428              	@ 0 "" 2
 1429              	.LVL136:
 1430              		.thumb
 1431              		.syntax unified
 1432              	.L140:
 1433 0016 FEE7     		b	.L140
 1434              	.LBE45:
 1435              	.LBE44:
 1436              		.cfi_endproc
 1437              	.LFE13:
 1439              		.section	.text.pcTimerGetName,"ax",%progbits
 1440              		.align	1
 1441              		.global	pcTimerGetName
 1442              		.syntax unified
 1443              		.thumb
 1444              		.thumb_func
 1445              		.fpu softvfp
 1447              	pcTimerGetName:
 1448              	.LFB14:
 509:FreeRTOS/timers.c ****         Timer_t * pxTimer = xTimer;
 1449              		.loc 1 509 0
 1450              		.cfi_startproc
 1451              		@ args = 0, pretend = 0, frame = 0
 1452              		@ frame_needed = 0, uses_anonymous_args = 0
 1453              		@ link register save eliminated.
 1454              	.LVL137:
ARM GAS  /tmp/cczeOkKz.s 			page 49


 512:FreeRTOS/timers.c ****         return pxTimer->pcTimerName;
 1455              		.loc 1 512 0
 1456 0000 08B1     		cbz	r0, .L145
 514:FreeRTOS/timers.c **** /*-----------------------------------------------------------*/
 1457              		.loc 1 514 0
 1458 0002 0068     		ldr	r0, [r0]
 1459              	.LVL138:
 1460 0004 7047     		bx	lr
 1461              	.LVL139:
 1462              	.L145:
 1463              	.LBB46:
 1464              	.LBB47:
 1465              		.loc 2 200 0
 1466              		.syntax unified
 1467              	@ 200 "FreeRTOS/ARM_CM3/portmacro.h" 1
 1468 0006 4FF05003 			mov r3, #80												
 1469 000a 83F31188 		msr basepri, r3											
 1470 000e BFF36F8F 		isb														
 1471 0012 BFF34F8F 		dsb														
 1472              	
 1473              	@ 0 "" 2
 1474              	.LVL140:
 1475              		.thumb
 1476              		.syntax unified
 1477              	.L144:
 1478 0016 FEE7     		b	.L144
 1479              	.LBE47:
 1480              	.LBE46:
 1481              		.cfi_endproc
 1482              	.LFE14:
 1484              		.section	.text.xTimerIsTimerActive,"ax",%progbits
 1485              		.align	1
 1486              		.global	xTimerIsTimerActive
 1487              		.syntax unified
 1488              		.thumb
 1489              		.thumb_func
 1490              		.fpu softvfp
 1492              	xTimerIsTimerActive:
 1493              	.LFB25:
 977:FreeRTOS/timers.c **** /*-----------------------------------------------------------*/
 978:FreeRTOS/timers.c **** 
 979:FreeRTOS/timers.c ****     BaseType_t xTimerIsTimerActive( TimerHandle_t xTimer )
 980:FreeRTOS/timers.c ****     {
 1494              		.loc 1 980 0
 1495              		.cfi_startproc
 1496              		@ args = 0, pretend = 0, frame = 0
 1497              		@ frame_needed = 0, uses_anonymous_args = 0
 1498              	.LVL141:
 981:FreeRTOS/timers.c ****         BaseType_t xReturn;
 982:FreeRTOS/timers.c ****         Timer_t * pxTimer = xTimer;
 983:FreeRTOS/timers.c **** 
 984:FreeRTOS/timers.c ****         configASSERT( xTimer );
 1499              		.loc 1 984 0
 1500 0000 40B9     		cbnz	r0, .L147
 1501              	.LBB48:
 1502              	.LBB49:
 1503              		.loc 2 200 0
ARM GAS  /tmp/cczeOkKz.s 			page 50


 1504              		.syntax unified
 1505              	@ 200 "FreeRTOS/ARM_CM3/portmacro.h" 1
 1506 0002 4FF05003 			mov r3, #80												
 1507 0006 83F31188 		msr basepri, r3											
 1508 000a BFF36F8F 		isb														
 1509 000e BFF34F8F 		dsb														
 1510              	
 1511              	@ 0 "" 2
 1512              	.LVL142:
 1513              		.thumb
 1514              		.syntax unified
 1515              	.L148:
 1516 0012 FEE7     		b	.L148
 1517              	.L147:
 1518              	.LBE49:
 1519              	.LBE48:
 980:FreeRTOS/timers.c ****         BaseType_t xReturn;
 1520              		.loc 1 980 0
 1521 0014 10B5     		push	{r4, lr}
 1522              	.LCFI28:
 1523              		.cfi_def_cfa_offset 8
 1524              		.cfi_offset 4, -8
 1525              		.cfi_offset 14, -4
 1526 0016 0446     		mov	r4, r0
 985:FreeRTOS/timers.c **** 
 986:FreeRTOS/timers.c ****         /* Is the timer in the list of active timers? */
 987:FreeRTOS/timers.c ****         taskENTER_CRITICAL();
 1527              		.loc 1 987 0
 1528 0018 FFF7FEFF 		bl	vPortEnterCritical
 1529              	.LVL143:
 988:FreeRTOS/timers.c ****         {
 989:FreeRTOS/timers.c ****             if( ( pxTimer->ucStatus & tmrSTATUS_IS_ACTIVE ) == 0 )
 1530              		.loc 1 989 0
 1531 001c 94F82430 		ldrb	r3, [r4, #36]	@ zero_extendqisi2
 1532 0020 13F0010F 		tst	r3, #1
 1533 0024 04D0     		beq	.L153
 990:FreeRTOS/timers.c ****             {
 991:FreeRTOS/timers.c ****                 xReturn = pdFALSE;
 992:FreeRTOS/timers.c ****             }
 993:FreeRTOS/timers.c ****             else
 994:FreeRTOS/timers.c ****             {
 995:FreeRTOS/timers.c ****                 xReturn = pdTRUE;
 1534              		.loc 1 995 0
 1535 0026 0124     		movs	r4, #1
 1536              	.LVL144:
 1537              	.L149:
 996:FreeRTOS/timers.c ****             }
 997:FreeRTOS/timers.c ****         }
 998:FreeRTOS/timers.c ****         taskEXIT_CRITICAL();
 1538              		.loc 1 998 0
 1539 0028 FFF7FEFF 		bl	vPortExitCritical
 1540              	.LVL145:
 999:FreeRTOS/timers.c **** 
1000:FreeRTOS/timers.c ****         return xReturn;
1001:FreeRTOS/timers.c ****     } /*lint !e818 Can't be pointer to const due to the typedef. */
 1541              		.loc 1 1001 0
 1542 002c 2046     		mov	r0, r4
ARM GAS  /tmp/cczeOkKz.s 			page 51


 1543 002e 10BD     		pop	{r4, pc}
 1544              	.LVL146:
 1545              	.L153:
 991:FreeRTOS/timers.c ****             }
 1546              		.loc 1 991 0
 1547 0030 0024     		movs	r4, #0
 1548              	.LVL147:
 1549 0032 F9E7     		b	.L149
 1550              		.cfi_endproc
 1551              	.LFE25:
 1553              		.section	.text.pvTimerGetTimerID,"ax",%progbits
 1554              		.align	1
 1555              		.global	pvTimerGetTimerID
 1556              		.syntax unified
 1557              		.thumb
 1558              		.thumb_func
 1559              		.fpu softvfp
 1561              	pvTimerGetTimerID:
 1562              	.LFB26:
1002:FreeRTOS/timers.c **** /*-----------------------------------------------------------*/
1003:FreeRTOS/timers.c **** 
1004:FreeRTOS/timers.c ****     void * pvTimerGetTimerID( const TimerHandle_t xTimer )
1005:FreeRTOS/timers.c ****     {
 1563              		.loc 1 1005 0
 1564              		.cfi_startproc
 1565              		@ args = 0, pretend = 0, frame = 0
 1566              		@ frame_needed = 0, uses_anonymous_args = 0
 1567              	.LVL148:
1006:FreeRTOS/timers.c ****         Timer_t * const pxTimer = xTimer;
1007:FreeRTOS/timers.c ****         void * pvReturn;
1008:FreeRTOS/timers.c **** 
1009:FreeRTOS/timers.c ****         configASSERT( xTimer );
 1568              		.loc 1 1009 0
 1569 0000 40B9     		cbnz	r0, .L155
 1570              	.LBB50:
 1571              	.LBB51:
 1572              		.loc 2 200 0
 1573              		.syntax unified
 1574              	@ 200 "FreeRTOS/ARM_CM3/portmacro.h" 1
 1575 0002 4FF05003 			mov r3, #80												
 1576 0006 83F31188 		msr basepri, r3											
 1577 000a BFF36F8F 		isb														
 1578 000e BFF34F8F 		dsb														
 1579              	
 1580              	@ 0 "" 2
 1581              	.LVL149:
 1582              		.thumb
 1583              		.syntax unified
 1584              	.L156:
 1585 0012 FEE7     		b	.L156
 1586              	.L155:
 1587              	.LBE51:
 1588              	.LBE50:
1005:FreeRTOS/timers.c ****         Timer_t * const pxTimer = xTimer;
 1589              		.loc 1 1005 0
 1590 0014 10B5     		push	{r4, lr}
 1591              	.LCFI29:
ARM GAS  /tmp/cczeOkKz.s 			page 52


 1592              		.cfi_def_cfa_offset 8
 1593              		.cfi_offset 4, -8
 1594              		.cfi_offset 14, -4
 1595 0016 0446     		mov	r4, r0
1010:FreeRTOS/timers.c **** 
1011:FreeRTOS/timers.c ****         taskENTER_CRITICAL();
 1596              		.loc 1 1011 0
 1597 0018 FFF7FEFF 		bl	vPortEnterCritical
 1598              	.LVL150:
1012:FreeRTOS/timers.c ****         {
1013:FreeRTOS/timers.c ****             pvReturn = pxTimer->pvTimerID;
 1599              		.loc 1 1013 0
 1600 001c E469     		ldr	r4, [r4, #28]
 1601              	.LVL151:
1014:FreeRTOS/timers.c ****         }
1015:FreeRTOS/timers.c ****         taskEXIT_CRITICAL();
 1602              		.loc 1 1015 0
 1603 001e FFF7FEFF 		bl	vPortExitCritical
 1604              	.LVL152:
1016:FreeRTOS/timers.c **** 
1017:FreeRTOS/timers.c ****         return pvReturn;
1018:FreeRTOS/timers.c ****     }
 1605              		.loc 1 1018 0
 1606 0022 2046     		mov	r0, r4
 1607 0024 10BD     		pop	{r4, pc}
 1608              		.cfi_endproc
 1609              	.LFE26:
 1611              		.section	.text.vTimerSetTimerID,"ax",%progbits
 1612              		.align	1
 1613              		.global	vTimerSetTimerID
 1614              		.syntax unified
 1615              		.thumb
 1616              		.thumb_func
 1617              		.fpu softvfp
 1619              	vTimerSetTimerID:
 1620              	.LFB27:
1019:FreeRTOS/timers.c **** /*-----------------------------------------------------------*/
1020:FreeRTOS/timers.c **** 
1021:FreeRTOS/timers.c ****     void vTimerSetTimerID( TimerHandle_t xTimer,
1022:FreeRTOS/timers.c ****                            void * pvNewID )
1023:FreeRTOS/timers.c ****     {
 1621              		.loc 1 1023 0
 1622              		.cfi_startproc
 1623              		@ args = 0, pretend = 0, frame = 0
 1624              		@ frame_needed = 0, uses_anonymous_args = 0
 1625              	.LVL153:
 1626 0000 38B5     		push	{r3, r4, r5, lr}
 1627              	.LCFI30:
 1628              		.cfi_def_cfa_offset 16
 1629              		.cfi_offset 3, -16
 1630              		.cfi_offset 4, -12
 1631              		.cfi_offset 5, -8
 1632              		.cfi_offset 14, -4
 1633              	.LVL154:
1024:FreeRTOS/timers.c ****         Timer_t * const pxTimer = xTimer;
1025:FreeRTOS/timers.c **** 
1026:FreeRTOS/timers.c ****         configASSERT( xTimer );
ARM GAS  /tmp/cczeOkKz.s 			page 53


 1634              		.loc 1 1026 0
 1635 0002 40B9     		cbnz	r0, .L160
 1636              	.LBB52:
 1637              	.LBB53:
 1638              		.loc 2 200 0
 1639              		.syntax unified
 1640              	@ 200 "FreeRTOS/ARM_CM3/portmacro.h" 1
 1641 0004 4FF05003 			mov r3, #80												
 1642 0008 83F31188 		msr basepri, r3											
 1643 000c BFF36F8F 		isb														
 1644 0010 BFF34F8F 		dsb														
 1645              	
 1646              	@ 0 "" 2
 1647              	.LVL155:
 1648              		.thumb
 1649              		.syntax unified
 1650              	.L161:
 1651 0014 FEE7     		b	.L161
 1652              	.L160:
 1653 0016 0446     		mov	r4, r0
 1654 0018 0D46     		mov	r5, r1
 1655              	.LBE53:
 1656              	.LBE52:
1027:FreeRTOS/timers.c **** 
1028:FreeRTOS/timers.c ****         taskENTER_CRITICAL();
 1657              		.loc 1 1028 0
 1658 001a FFF7FEFF 		bl	vPortEnterCritical
 1659              	.LVL156:
1029:FreeRTOS/timers.c ****         {
1030:FreeRTOS/timers.c ****             pxTimer->pvTimerID = pvNewID;
 1660              		.loc 1 1030 0
 1661 001e E561     		str	r5, [r4, #28]
1031:FreeRTOS/timers.c ****         }
1032:FreeRTOS/timers.c ****         taskEXIT_CRITICAL();
 1662              		.loc 1 1032 0
 1663 0020 FFF7FEFF 		bl	vPortExitCritical
 1664              	.LVL157:
1033:FreeRTOS/timers.c ****     }
 1665              		.loc 1 1033 0
 1666 0024 38BD     		pop	{r3, r4, r5, pc}
 1667              		.cfi_endproc
 1668              	.LFE27:
 1670              		.section	.bss.pxCurrentTimerList,"aw",%nobits
 1671              		.align	2
 1672              		.set	.LANCHOR0,. + 0
 1675              	pxCurrentTimerList:
 1676 0000 00000000 		.space	4
 1677              		.section	.bss.pxOverflowTimerList,"aw",%nobits
 1678              		.align	2
 1679              		.set	.LANCHOR1,. + 0
 1682              	pxOverflowTimerList:
 1683 0000 00000000 		.space	4
 1684              		.section	.bss.xActiveTimerList1,"aw",%nobits
 1685              		.align	2
 1686              		.set	.LANCHOR4,. + 0
 1689              	xActiveTimerList1:
 1690 0000 00000000 		.space	20
ARM GAS  /tmp/cczeOkKz.s 			page 54


 1690      00000000 
 1690      00000000 
 1690      00000000 
 1690      00000000 
 1691              		.section	.bss.xActiveTimerList2,"aw",%nobits
 1692              		.align	2
 1693              		.set	.LANCHOR5,. + 0
 1696              	xActiveTimerList2:
 1697 0000 00000000 		.space	20
 1697      00000000 
 1697      00000000 
 1697      00000000 
 1697      00000000 
 1698              		.section	.bss.xLastTime.5453,"aw",%nobits
 1699              		.align	2
 1700              		.set	.LANCHOR2,. + 0
 1703              	xLastTime.5453:
 1704 0000 00000000 		.space	4
 1705              		.section	.bss.xTimerQueue,"aw",%nobits
 1706              		.align	2
 1707              		.set	.LANCHOR3,. + 0
 1710              	xTimerQueue:
 1711 0000 00000000 		.space	4
 1712              		.section	.bss.xTimerTaskHandle,"aw",%nobits
 1713              		.align	2
 1714              		.set	.LANCHOR6,. + 0
 1717              	xTimerTaskHandle:
 1718 0000 00000000 		.space	4
 1719              		.section	.rodata.prvCheckForValidListAndQueue.str1.4,"aMS",%progbits,1
 1720              		.align	2
 1721              	.LC0:
 1722 0000 546D7251 		.ascii	"TmrQ\000"
 1722      00
 1723              		.section	.rodata.xTimerCreateTimerTask.str1.4,"aMS",%progbits,1
 1724              		.align	2
 1725              	.LC1:
 1726 0000 546D7220 		.ascii	"Tmr Svc\000"
 1726      53766300 
 1727              		.text
 1728              	.Letext0:
 1729              		.file 3 "/usr/include/newlib/machine/_default_types.h"
 1730              		.file 4 "/usr/include/newlib/sys/lock.h"
 1731              		.file 5 "/usr/include/newlib/sys/_types.h"
 1732              		.file 6 "/usr/lib/gcc/arm-none-eabi/7.3.1/include/stddef.h"
 1733              		.file 7 "/usr/include/newlib/sys/reent.h"
 1734              		.file 8 "/usr/include/newlib/stdlib.h"
 1735              		.file 9 "/usr/include/newlib/sys/_stdint.h"
 1736              		.file 10 "FreeRTOS/ARM_CM3/FreeRTOSConfig.h"
 1737              		.file 11 "FreeRTOS/include/list.h"
 1738              		.file 12 "FreeRTOS/include/task.h"
 1739              		.file 13 "FreeRTOS/include/queue.h"
 1740              		.file 14 "FreeRTOS/include/timers.h"
 1741              		.file 15 "FreeRTOS/include/portable.h"
ARM GAS  /tmp/cczeOkKz.s 			page 55


DEFINED SYMBOLS
                            *ABS*:0000000000000000 timers.c
     /tmp/cczeOkKz.s:16     .text.prvGetNextExpireTime:0000000000000000 $t
     /tmp/cczeOkKz.s:22     .text.prvGetNextExpireTime:0000000000000000 prvGetNextExpireTime
     /tmp/cczeOkKz.s:61     .text.prvGetNextExpireTime:000000000000001c $d
     /tmp/cczeOkKz.s:66     .text.prvInsertTimerInActiveList:0000000000000000 $t
     /tmp/cczeOkKz.s:72     .text.prvInsertTimerInActiveList:0000000000000000 prvInsertTimerInActiveList
     /tmp/cczeOkKz.s:150    .text.prvInsertTimerInActiveList:0000000000000040 $d
     /tmp/cczeOkKz.s:156    .text.prvReloadTimer:0000000000000000 $t
     /tmp/cczeOkKz.s:162    .text.prvReloadTimer:0000000000000000 prvReloadTimer
     /tmp/cczeOkKz.s:209    .text.prvProcessExpiredTimer:0000000000000000 $t
     /tmp/cczeOkKz.s:215    .text.prvProcessExpiredTimer:0000000000000000 prvProcessExpiredTimer
     /tmp/cczeOkKz.s:269    .text.prvProcessExpiredTimer:000000000000003c $d
     /tmp/cczeOkKz.s:274    .text.prvSwitchTimerLists:0000000000000000 $t
     /tmp/cczeOkKz.s:280    .text.prvSwitchTimerLists:0000000000000000 prvSwitchTimerLists
     /tmp/cczeOkKz.s:323    .text.prvSwitchTimerLists:0000000000000028 $d
     /tmp/cczeOkKz.s:329    .text.prvSampleTimeNow:0000000000000000 $t
     /tmp/cczeOkKz.s:335    .text.prvSampleTimeNow:0000000000000000 prvSampleTimeNow
     /tmp/cczeOkKz.s:383    .text.prvSampleTimeNow:0000000000000028 $d
     /tmp/cczeOkKz.s:388    .text.prvProcessTimerOrBlockTask:0000000000000000 $t
     /tmp/cczeOkKz.s:394    .text.prvProcessTimerOrBlockTask:0000000000000000 prvProcessTimerOrBlockTask
     /tmp/cczeOkKz.s:499    .text.prvProcessTimerOrBlockTask:0000000000000068 $d
     /tmp/cczeOkKz.s:506    .text.prvProcessReceivedCommands:0000000000000000 $t
     /tmp/cczeOkKz.s:512    .text.prvProcessReceivedCommands:0000000000000000 prvProcessReceivedCommands
     /tmp/cczeOkKz.s:565    .text.prvProcessReceivedCommands:000000000000003a $d
     /tmp/cczeOkKz.s:692    .text.prvProcessReceivedCommands:00000000000000f0 $d
     /tmp/cczeOkKz.s:697    .text.prvTimerTask:0000000000000000 $t
     /tmp/cczeOkKz.s:703    .text.prvTimerTask:0000000000000000 prvTimerTask
     /tmp/cczeOkKz.s:735    .text.prvCheckForValidListAndQueue:0000000000000000 $t
     /tmp/cczeOkKz.s:741    .text.prvCheckForValidListAndQueue:0000000000000000 prvCheckForValidListAndQueue
     /tmp/cczeOkKz.s:803    .text.prvCheckForValidListAndQueue:0000000000000044 $d
     /tmp/cczeOkKz.s:813    .text.prvInitialiseNewTimer:0000000000000000 $t
     /tmp/cczeOkKz.s:819    .text.prvInitialiseNewTimer:0000000000000000 prvInitialiseNewTimer
     /tmp/cczeOkKz.s:891    .text.xTimerCreateTimerTask:0000000000000000 $t
     /tmp/cczeOkKz.s:898    .text.xTimerCreateTimerTask:0000000000000000 xTimerCreateTimerTask
     /tmp/cczeOkKz.s:963    .text.xTimerCreateTimerTask:000000000000003c $d
     /tmp/cczeOkKz.s:971    .text.xTimerCreate:0000000000000000 $t
     /tmp/cczeOkKz.s:978    .text.xTimerCreate:0000000000000000 xTimerCreate
     /tmp/cczeOkKz.s:1035   .text.xTimerGenericCommand:0000000000000000 $t
     /tmp/cczeOkKz.s:1042   .text.xTimerGenericCommand:0000000000000000 xTimerGenericCommand
     /tmp/cczeOkKz.s:1158   .text.xTimerGenericCommand:0000000000000068 $d
     /tmp/cczeOkKz.s:1163   .text.xTimerGetTimerDaemonTaskHandle:0000000000000000 $t
     /tmp/cczeOkKz.s:1170   .text.xTimerGetTimerDaemonTaskHandle:0000000000000000 xTimerGetTimerDaemonTaskHandle
     /tmp/cczeOkKz.s:1203   .text.xTimerGetTimerDaemonTaskHandle:000000000000001c $d
     /tmp/cczeOkKz.s:1210   .text.xTimerGetPeriod:0000000000000000 $t
     /tmp/cczeOkKz.s:1217   .text.xTimerGetPeriod:0000000000000000 xTimerGetPeriod
     /tmp/cczeOkKz.s:1255   .text.vTimerSetReloadMode:0000000000000000 $t
     /tmp/cczeOkKz.s:1262   .text.vTimerSetReloadMode:0000000000000000 vTimerSetReloadMode
     /tmp/cczeOkKz.s:1325   .text.uxTimerGetReloadMode:0000000000000000 $t
     /tmp/cczeOkKz.s:1332   .text.uxTimerGetReloadMode:0000000000000000 uxTimerGetReloadMode
     /tmp/cczeOkKz.s:1394   .text.xTimerGetExpiryTime:0000000000000000 $t
     /tmp/cczeOkKz.s:1401   .text.xTimerGetExpiryTime:0000000000000000 xTimerGetExpiryTime
     /tmp/cczeOkKz.s:1440   .text.pcTimerGetName:0000000000000000 $t
     /tmp/cczeOkKz.s:1447   .text.pcTimerGetName:0000000000000000 pcTimerGetName
     /tmp/cczeOkKz.s:1485   .text.xTimerIsTimerActive:0000000000000000 $t
     /tmp/cczeOkKz.s:1492   .text.xTimerIsTimerActive:0000000000000000 xTimerIsTimerActive
     /tmp/cczeOkKz.s:1554   .text.pvTimerGetTimerID:0000000000000000 $t
ARM GAS  /tmp/cczeOkKz.s 			page 56


     /tmp/cczeOkKz.s:1561   .text.pvTimerGetTimerID:0000000000000000 pvTimerGetTimerID
     /tmp/cczeOkKz.s:1612   .text.vTimerSetTimerID:0000000000000000 $t
     /tmp/cczeOkKz.s:1619   .text.vTimerSetTimerID:0000000000000000 vTimerSetTimerID
     /tmp/cczeOkKz.s:1671   .bss.pxCurrentTimerList:0000000000000000 $d
     /tmp/cczeOkKz.s:1675   .bss.pxCurrentTimerList:0000000000000000 pxCurrentTimerList
     /tmp/cczeOkKz.s:1678   .bss.pxOverflowTimerList:0000000000000000 $d
     /tmp/cczeOkKz.s:1682   .bss.pxOverflowTimerList:0000000000000000 pxOverflowTimerList
     /tmp/cczeOkKz.s:1685   .bss.xActiveTimerList1:0000000000000000 $d
     /tmp/cczeOkKz.s:1689   .bss.xActiveTimerList1:0000000000000000 xActiveTimerList1
     /tmp/cczeOkKz.s:1692   .bss.xActiveTimerList2:0000000000000000 $d
     /tmp/cczeOkKz.s:1696   .bss.xActiveTimerList2:0000000000000000 xActiveTimerList2
     /tmp/cczeOkKz.s:1699   .bss.xLastTime.5453:0000000000000000 $d
     /tmp/cczeOkKz.s:1703   .bss.xLastTime.5453:0000000000000000 xLastTime.5453
     /tmp/cczeOkKz.s:1706   .bss.xTimerQueue:0000000000000000 $d
     /tmp/cczeOkKz.s:1710   .bss.xTimerQueue:0000000000000000 xTimerQueue
     /tmp/cczeOkKz.s:1713   .bss.xTimerTaskHandle:0000000000000000 $d
     /tmp/cczeOkKz.s:1717   .bss.xTimerTaskHandle:0000000000000000 xTimerTaskHandle
     /tmp/cczeOkKz.s:1720   .rodata.prvCheckForValidListAndQueue.str1.4:0000000000000000 $d
     /tmp/cczeOkKz.s:1724   .rodata.xTimerCreateTimerTask.str1.4:0000000000000000 $d
     /tmp/cczeOkKz.s:574    .text.prvProcessReceivedCommands:0000000000000043 $d
     /tmp/cczeOkKz.s:574    .text.prvProcessReceivedCommands:0000000000000044 $t

UNDEFINED SYMBOLS
vListInsert
uxListRemove
xTaskGetTickCount
vTaskSuspendAll
vQueueWaitForMessageRestricted
xTaskResumeAll
xQueueReceive
vPortFree
vPortEnterCritical
vPortExitCritical
vListInitialise
xQueueGenericCreate
vQueueAddToRegistry
vListInitialiseItem
xTaskCreate
pvPortMalloc
xTaskGetSchedulerState
xQueueGenericSend
xQueueGenericSendFromISR
